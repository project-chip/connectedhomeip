/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include <app-common/zap-generated/cluster-objects.h>
#include <app/data-model/WrappedStructEncoder.h>

#include <variant>

namespace chip {
namespace app {
namespace Clusters {

namespace detail {

class StructDecodeIterator
{
public:
    // may return a context tag, a CHIP_ERROR (end iteration)
    using EntryElement = std::variant<uint8_t, CHIP_ERROR>;

    StructDecodeIterator(TLV::TLVReader & reader) : mReader(reader) {}

    // Iterate through structure elements. Returns one of:
    //   - uint8_t CONTEXT TAG (keep iterating)
    //   - CHIP_ERROR (including CHIP_NO_ERROR) which should be a final
    //     return value (stop iterating)
    EntryElement Next()
    {
        if (!mEntered)
        {
            VerifyOrReturnError(TLV::kTLVType_Structure == mReader.GetType(), CHIP_ERROR_WRONG_TLV_TYPE);
            ReturnErrorOnFailure(mReader.EnterContainer(mOuter));
            mEntered = true;
        }

        while (true)
        {
            CHIP_ERROR err = mReader.Next();
            if (err != CHIP_NO_ERROR)
            {
                VerifyOrReturnError(err == CHIP_ERROR_END_OF_TLV, err);
                break;
            }

            const TLV::Tag tag = mReader.GetTag();
            if (!TLV::IsContextTag(tag))
            {
                continue;
            }

            // we know context tags are 8-bit
            return static_cast<uint8_t>(TLV::TagNumFromTag(tag));
        }

        return mReader.ExitContainer(mOuter);
    }

private:
    bool mEntered = false;
    TLV::TLVType mOuter;
    TLV::TLVReader & mReader;
};

// Structs shared across multiple clusters.
namespace Structs {

namespace ModeTagStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMfgCode), mfgCode);
    encoder.Encode(to_underlying(Fields::kValue), value);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMfgCode))
        {
            err = DataModel::Decode(reader, mfgCode);
        }
        else if (__context_tag == to_underlying(Fields::kValue))
        {
            err = DataModel::Decode(reader, value);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ModeTagStruct

namespace ModeOptionStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLabel), label);
    encoder.Encode(to_underlying(Fields::kMode), mode);
    encoder.Encode(to_underlying(Fields::kModeTags), modeTags);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLabel))
        {
            err = DataModel::Decode(reader, label);
        }
        else if (__context_tag == to_underlying(Fields::kMode))
        {
            err = DataModel::Decode(reader, mode);
        }
        else if (__context_tag == to_underlying(Fields::kModeTags))
        {
            err = DataModel::Decode(reader, modeTags);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ModeOptionStruct

namespace MeasurementAccuracyRangeStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kRangeMin), rangeMin);
    encoder.Encode(to_underlying(Fields::kRangeMax), rangeMax);
    encoder.Encode(to_underlying(Fields::kPercentMax), percentMax);
    encoder.Encode(to_underlying(Fields::kPercentMin), percentMin);
    encoder.Encode(to_underlying(Fields::kPercentTypical), percentTypical);
    encoder.Encode(to_underlying(Fields::kFixedMax), fixedMax);
    encoder.Encode(to_underlying(Fields::kFixedMin), fixedMin);
    encoder.Encode(to_underlying(Fields::kFixedTypical), fixedTypical);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kRangeMin))
        {
            err = DataModel::Decode(reader, rangeMin);
        }
        else if (__context_tag == to_underlying(Fields::kRangeMax))
        {
            err = DataModel::Decode(reader, rangeMax);
        }
        else if (__context_tag == to_underlying(Fields::kPercentMax))
        {
            err = DataModel::Decode(reader, percentMax);
        }
        else if (__context_tag == to_underlying(Fields::kPercentMin))
        {
            err = DataModel::Decode(reader, percentMin);
        }
        else if (__context_tag == to_underlying(Fields::kPercentTypical))
        {
            err = DataModel::Decode(reader, percentTypical);
        }
        else if (__context_tag == to_underlying(Fields::kFixedMax))
        {
            err = DataModel::Decode(reader, fixedMax);
        }
        else if (__context_tag == to_underlying(Fields::kFixedMin))
        {
            err = DataModel::Decode(reader, fixedMin);
        }
        else if (__context_tag == to_underlying(Fields::kFixedTypical))
        {
            err = DataModel::Decode(reader, fixedTypical);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace MeasurementAccuracyRangeStruct

namespace MeasurementAccuracyStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMeasurementType), measurementType);
    encoder.Encode(to_underlying(Fields::kMeasured), measured);
    encoder.Encode(to_underlying(Fields::kMinMeasuredValue), minMeasuredValue);
    encoder.Encode(to_underlying(Fields::kMaxMeasuredValue), maxMeasuredValue);
    encoder.Encode(to_underlying(Fields::kAccuracyRanges), accuracyRanges);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMeasurementType))
        {
            err = DataModel::Decode(reader, measurementType);
        }
        else if (__context_tag == to_underlying(Fields::kMeasured))
        {
            err = DataModel::Decode(reader, measured);
        }
        else if (__context_tag == to_underlying(Fields::kMinMeasuredValue))
        {
            err = DataModel::Decode(reader, minMeasuredValue);
        }
        else if (__context_tag == to_underlying(Fields::kMaxMeasuredValue))
        {
            err = DataModel::Decode(reader, maxMeasuredValue);
        }
        else if (__context_tag == to_underlying(Fields::kAccuracyRanges))
        {
            err = DataModel::Decode(reader, accuracyRanges);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace MeasurementAccuracyStruct

namespace ApplicationStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCatalogVendorID), catalogVendorID);
    encoder.Encode(to_underlying(Fields::kApplicationID), applicationID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCatalogVendorID))
        {
            err = DataModel::Decode(reader, catalogVendorID);
        }
        else if (__context_tag == to_underlying(Fields::kApplicationID))
        {
            err = DataModel::Decode(reader, applicationID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ApplicationStruct

namespace ErrorStateStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kErrorStateID), errorStateID);
    encoder.Encode(to_underlying(Fields::kErrorStateLabel), errorStateLabel);
    encoder.Encode(to_underlying(Fields::kErrorStateDetails), errorStateDetails);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kErrorStateID))
        {
            err = DataModel::Decode(reader, errorStateID);
        }
        else if (__context_tag == to_underlying(Fields::kErrorStateLabel))
        {
            err = DataModel::Decode(reader, errorStateLabel);
        }
        else if (__context_tag == to_underlying(Fields::kErrorStateDetails))
        {
            err = DataModel::Decode(reader, errorStateDetails);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ErrorStateStruct

namespace LabelStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLabel), label);
    encoder.Encode(to_underlying(Fields::kValue), value);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLabel))
        {
            err = DataModel::Decode(reader, label);
        }
        else if (__context_tag == to_underlying(Fields::kValue))
        {
            err = DataModel::Decode(reader, value);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace LabelStruct

namespace OperationalStateStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOperationalStateID), operationalStateID);
    encoder.Encode(to_underlying(Fields::kOperationalStateLabel), operationalStateLabel);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kOperationalStateID))
        {
            err = DataModel::Decode(reader, operationalStateID);
        }
        else if (__context_tag == to_underlying(Fields::kOperationalStateLabel))
        {
            err = DataModel::Decode(reader, operationalStateLabel);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace OperationalStateStruct
} // namespace Structs
} // namespace detail

namespace Identify {

namespace Commands {
namespace Identify {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kIdentifyTime), identifyTime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kIdentifyTime))
        {
            err = DataModel::Decode(reader, identifyTime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Identify.
namespace TriggerEffect {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kEffectIdentifier), effectIdentifier);
    encoder.Encode(to_underlying(Fields::kEffectVariant), effectVariant);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kEffectIdentifier))
        {
            err = DataModel::Decode(reader, effectIdentifier);
        }
        else if (__context_tag == to_underlying(Fields::kEffectVariant))
        {
            err = DataModel::Decode(reader, effectVariant);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TriggerEffect.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::IdentifyTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, identifyTime);
    case Attributes::IdentifyType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, identifyType);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace Identify
namespace Groups {

namespace Commands {
namespace AddGroup {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    encoder.Encode(to_underlying(Fields::kGroupName), groupName);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else if (__context_tag == to_underlying(Fields::kGroupName))
        {
            err = DataModel::Decode(reader, groupName);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AddGroup.
namespace AddGroupResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AddGroupResponse.
namespace ViewGroup {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ViewGroup.
namespace ViewGroupResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    encoder.Encode(to_underlying(Fields::kGroupName), groupName);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else if (__context_tag == to_underlying(Fields::kGroupName))
        {
            err = DataModel::Decode(reader, groupName);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ViewGroupResponse.
namespace GetGroupMembership {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupList), groupList);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupList))
        {
            err = DataModel::Decode(reader, groupList);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetGroupMembership.
namespace GetGroupMembershipResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCapacity), capacity);
    encoder.Encode(to_underlying(Fields::kGroupList), groupList);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCapacity))
        {
            err = DataModel::Decode(reader, capacity);
        }
        else if (__context_tag == to_underlying(Fields::kGroupList))
        {
            err = DataModel::Decode(reader, groupList);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetGroupMembershipResponse.
namespace RemoveGroup {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RemoveGroup.
namespace RemoveGroupResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RemoveGroupResponse.
namespace RemoveAllGroups {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace RemoveAllGroups.
namespace AddGroupIfIdentifying {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    encoder.Encode(to_underlying(Fields::kGroupName), groupName);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else if (__context_tag == to_underlying(Fields::kGroupName))
        {
            err = DataModel::Decode(reader, groupName);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AddGroupIfIdentifying.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::NameSupport::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nameSupport);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace Groups
namespace OnOff {

namespace Commands {
namespace Off {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Off.
namespace On {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace On.
namespace Toggle {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Toggle.
namespace OffWithEffect {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kEffectIdentifier), effectIdentifier);
    encoder.Encode(to_underlying(Fields::kEffectVariant), effectVariant);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kEffectIdentifier))
        {
            err = DataModel::Decode(reader, effectIdentifier);
        }
        else if (__context_tag == to_underlying(Fields::kEffectVariant))
        {
            err = DataModel::Decode(reader, effectVariant);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace OffWithEffect.
namespace OnWithRecallGlobalScene {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace OnWithRecallGlobalScene.
namespace OnWithTimedOff {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOnOffControl), onOffControl);
    encoder.Encode(to_underlying(Fields::kOnTime), onTime);
    encoder.Encode(to_underlying(Fields::kOffWaitTime), offWaitTime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kOnOffControl))
        {
            err = DataModel::Decode(reader, onOffControl);
        }
        else if (__context_tag == to_underlying(Fields::kOnTime))
        {
            err = DataModel::Decode(reader, onTime);
        }
        else if (__context_tag == to_underlying(Fields::kOffWaitTime))
        {
            err = DataModel::Decode(reader, offWaitTime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace OnWithTimedOff.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::OnOff::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, onOff);
    case Attributes::GlobalSceneControl::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, globalSceneControl);
    case Attributes::OnTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, onTime);
    case Attributes::OffWaitTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, offWaitTime);
    case Attributes::StartUpOnOff::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, startUpOnOff);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace OnOff
namespace OnOffSwitchConfiguration {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::SwitchType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, switchType);
    case Attributes::SwitchActions::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, switchActions);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace OnOffSwitchConfiguration
namespace LevelControl {

namespace Commands {
namespace MoveToLevel {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLevel), level);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLevel))
        {
            err = DataModel::Decode(reader, level);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MoveToLevel.
namespace Move {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMoveMode), moveMode);
    encoder.Encode(to_underlying(Fields::kRate), rate);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMoveMode))
        {
            err = DataModel::Decode(reader, moveMode);
        }
        else if (__context_tag == to_underlying(Fields::kRate))
        {
            err = DataModel::Decode(reader, rate);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Move.
namespace Step {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStepMode), stepMode);
    encoder.Encode(to_underlying(Fields::kStepSize), stepSize);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStepMode))
        {
            err = DataModel::Decode(reader, stepMode);
        }
        else if (__context_tag == to_underlying(Fields::kStepSize))
        {
            err = DataModel::Decode(reader, stepSize);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Step.
namespace Stop {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Stop.
namespace MoveToLevelWithOnOff {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLevel), level);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLevel))
        {
            err = DataModel::Decode(reader, level);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MoveToLevelWithOnOff.
namespace MoveWithOnOff {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMoveMode), moveMode);
    encoder.Encode(to_underlying(Fields::kRate), rate);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMoveMode))
        {
            err = DataModel::Decode(reader, moveMode);
        }
        else if (__context_tag == to_underlying(Fields::kRate))
        {
            err = DataModel::Decode(reader, rate);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MoveWithOnOff.
namespace StepWithOnOff {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStepMode), stepMode);
    encoder.Encode(to_underlying(Fields::kStepSize), stepSize);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStepMode))
        {
            err = DataModel::Decode(reader, stepMode);
        }
        else if (__context_tag == to_underlying(Fields::kStepSize))
        {
            err = DataModel::Decode(reader, stepSize);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StepWithOnOff.
namespace StopWithOnOff {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StopWithOnOff.
namespace MoveToClosestFrequency {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kFrequency), frequency);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kFrequency))
        {
            err = DataModel::Decode(reader, frequency);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MoveToClosestFrequency.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::CurrentLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentLevel);
    case Attributes::RemainingTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, remainingTime);
    case Attributes::MinLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minLevel);
    case Attributes::MaxLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxLevel);
    case Attributes::CurrentFrequency::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentFrequency);
    case Attributes::MinFrequency::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minFrequency);
    case Attributes::MaxFrequency::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxFrequency);
    case Attributes::Options::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, options);
    case Attributes::OnOffTransitionTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, onOffTransitionTime);
    case Attributes::OnLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, onLevel);
    case Attributes::OnTransitionTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, onTransitionTime);
    case Attributes::OffTransitionTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, offTransitionTime);
    case Attributes::DefaultMoveRate::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, defaultMoveRate);
    case Attributes::StartUpCurrentLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, startUpCurrentLevel);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace LevelControl
namespace BinaryInputBasic {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::ActiveText::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeText);
    case Attributes::Description::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, description);
    case Attributes::InactiveText::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, inactiveText);
    case Attributes::OutOfService::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, outOfService);
    case Attributes::Polarity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, polarity);
    case Attributes::PresentValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, presentValue);
    case Attributes::Reliability::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, reliability);
    case Attributes::StatusFlags::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, statusFlags);
    case Attributes::ApplicationType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, applicationType);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace BinaryInputBasic
namespace PulseWidthModulation {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace PulseWidthModulation
namespace Descriptor {
namespace Structs {

namespace DeviceTypeStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kDeviceType), deviceType);
    encoder.Encode(to_underlying(Fields::kRevision), revision);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDeviceType))
        {
            err = DataModel::Decode(reader, deviceType);
        }
        else if (__context_tag == to_underlying(Fields::kRevision))
        {
            err = DataModel::Decode(reader, revision);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace DeviceTypeStruct

namespace SemanticTagStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMfgCode), mfgCode);
    encoder.Encode(to_underlying(Fields::kNamespaceID), namespaceID);
    encoder.Encode(to_underlying(Fields::kTag), tag);
    encoder.Encode(to_underlying(Fields::kLabel), label);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMfgCode))
        {
            err = DataModel::Decode(reader, mfgCode);
        }
        else if (__context_tag == to_underlying(Fields::kNamespaceID))
        {
            err = DataModel::Decode(reader, namespaceID);
        }
        else if (__context_tag == to_underlying(Fields::kTag))
        {
            err = DataModel::Decode(reader, tag);
        }
        else if (__context_tag == to_underlying(Fields::kLabel))
        {
            err = DataModel::Decode(reader, label);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace SemanticTagStruct
} // namespace Structs

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::DeviceTypeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, deviceTypeList);
    case Attributes::ServerList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, serverList);
    case Attributes::ClientList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clientList);
    case Attributes::PartsList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, partsList);
    case Attributes::TagList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, tagList);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace Descriptor
namespace Binding {
namespace Structs {

namespace TargetStruct {
CHIP_ERROR Type::EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    return DoEncode(aWriter, aTag, NullOptional);
}

CHIP_ERROR Type::EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const
{
    return DoEncode(aWriter, aTag, MakeOptional(aAccessingFabricIndex));
}

CHIP_ERROR Type::DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const
{

    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };

    encoder.Encode(to_underlying(Fields::kNode), node);
    encoder.Encode(to_underlying(Fields::kGroup), group);
    encoder.Encode(to_underlying(Fields::kEndpoint), endpoint);
    encoder.Encode(to_underlying(Fields::kCluster), cluster);
    if (aAccessingFabricIndex.HasValue())
    {
        encoder.Encode(to_underlying(Fields::kFabricIndex), fabricIndex);
    }

    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNode))
        {
            err = DataModel::Decode(reader, node);
        }
        else if (__context_tag == to_underlying(Fields::kGroup))
        {
            err = DataModel::Decode(reader, group);
        }
        else if (__context_tag == to_underlying(Fields::kEndpoint))
        {
            err = DataModel::Decode(reader, endpoint);
        }
        else if (__context_tag == to_underlying(Fields::kCluster))
        {
            err = DataModel::Decode(reader, cluster);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace TargetStruct
} // namespace Structs

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Binding::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, binding);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace Binding
namespace AccessControl {
namespace Structs {

namespace AccessControlTargetStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCluster), cluster);
    encoder.Encode(to_underlying(Fields::kEndpoint), endpoint);
    encoder.Encode(to_underlying(Fields::kDeviceType), deviceType);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCluster))
        {
            err = DataModel::Decode(reader, cluster);
        }
        else if (__context_tag == to_underlying(Fields::kEndpoint))
        {
            err = DataModel::Decode(reader, endpoint);
        }
        else if (__context_tag == to_underlying(Fields::kDeviceType))
        {
            err = DataModel::Decode(reader, deviceType);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace AccessControlTargetStruct

namespace AccessControlEntryStruct {
CHIP_ERROR Type::EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    return DoEncode(aWriter, aTag, NullOptional);
}

CHIP_ERROR Type::EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const
{
    return DoEncode(aWriter, aTag, MakeOptional(aAccessingFabricIndex));
}

CHIP_ERROR Type::DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const
{
    bool includeSensitive = !aAccessingFabricIndex.HasValue() || (aAccessingFabricIndex.Value() == fabricIndex);

    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };

    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kPrivilege), privilege);
    }
    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kAuthMode), authMode);
    }
    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kSubjects), subjects);
    }
    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kTargets), targets);
    }
    if (aAccessingFabricIndex.HasValue())
    {
        encoder.Encode(to_underlying(Fields::kFabricIndex), fabricIndex);
    }

    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPrivilege))
        {
            err = DataModel::Decode(reader, privilege);
        }
        else if (__context_tag == to_underlying(Fields::kAuthMode))
        {
            err = DataModel::Decode(reader, authMode);
        }
        else if (__context_tag == to_underlying(Fields::kSubjects))
        {
            err = DataModel::Decode(reader, subjects);
        }
        else if (__context_tag == to_underlying(Fields::kTargets))
        {
            err = DataModel::Decode(reader, targets);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace AccessControlEntryStruct

namespace AccessControlExtensionStruct {
CHIP_ERROR Type::EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    return DoEncode(aWriter, aTag, NullOptional);
}

CHIP_ERROR Type::EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const
{
    return DoEncode(aWriter, aTag, MakeOptional(aAccessingFabricIndex));
}

CHIP_ERROR Type::DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const
{
    bool includeSensitive = !aAccessingFabricIndex.HasValue() || (aAccessingFabricIndex.Value() == fabricIndex);

    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };

    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kData), data);
    }
    if (aAccessingFabricIndex.HasValue())
    {
        encoder.Encode(to_underlying(Fields::kFabricIndex), fabricIndex);
    }

    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace AccessControlExtensionStruct
} // namespace Structs

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Acl::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acl);
    case Attributes::Extension::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, extension);
    case Attributes::SubjectsPerAccessControlEntry::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, subjectsPerAccessControlEntry);
    case Attributes::TargetsPerAccessControlEntry::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, targetsPerAccessControlEntry);
    case Attributes::AccessControlEntriesPerFabric::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, accessControlEntriesPerFabric);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace AccessControlEntryChanged {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kAdminNodeID), adminNodeID));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kAdminPasscodeID), adminPasscodeID));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kChangeType), changeType));
    ReturnErrorOnFailure(DataModel::EncodeForRead(aWriter, TLV::ContextTag(Fields::kLatestValue), GetFabricIndex(), latestValue));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kFabricIndex), fabricIndex));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAdminNodeID))
        {
            err = DataModel::Decode(reader, adminNodeID);
        }
        else if (__context_tag == to_underlying(Fields::kAdminPasscodeID))
        {
            err = DataModel::Decode(reader, adminPasscodeID);
        }
        else if (__context_tag == to_underlying(Fields::kChangeType))
        {
            err = DataModel::Decode(reader, changeType);
        }
        else if (__context_tag == to_underlying(Fields::kLatestValue))
        {
            err = DataModel::Decode(reader, latestValue);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AccessControlEntryChanged.
namespace AccessControlExtensionChanged {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kAdminNodeID), adminNodeID));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kAdminPasscodeID), adminPasscodeID));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kChangeType), changeType));
    ReturnErrorOnFailure(DataModel::EncodeForRead(aWriter, TLV::ContextTag(Fields::kLatestValue), GetFabricIndex(), latestValue));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kFabricIndex), fabricIndex));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAdminNodeID))
        {
            err = DataModel::Decode(reader, adminNodeID);
        }
        else if (__context_tag == to_underlying(Fields::kAdminPasscodeID))
        {
            err = DataModel::Decode(reader, adminPasscodeID);
        }
        else if (__context_tag == to_underlying(Fields::kChangeType))
        {
            err = DataModel::Decode(reader, changeType);
        }
        else if (__context_tag == to_underlying(Fields::kLatestValue))
        {
            err = DataModel::Decode(reader, latestValue);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AccessControlExtensionChanged.
} // namespace Events

} // namespace AccessControl
namespace Actions {
namespace Structs {

namespace ActionStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kActionID), actionID);
    encoder.Encode(to_underlying(Fields::kName), name);
    encoder.Encode(to_underlying(Fields::kType), type);
    encoder.Encode(to_underlying(Fields::kEndpointListID), endpointListID);
    encoder.Encode(to_underlying(Fields::kSupportedCommands), supportedCommands);
    encoder.Encode(to_underlying(Fields::kState), state);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActionID))
        {
            err = DataModel::Decode(reader, actionID);
        }
        else if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else if (__context_tag == to_underlying(Fields::kType))
        {
            err = DataModel::Decode(reader, type);
        }
        else if (__context_tag == to_underlying(Fields::kEndpointListID))
        {
            err = DataModel::Decode(reader, endpointListID);
        }
        else if (__context_tag == to_underlying(Fields::kSupportedCommands))
        {
            err = DataModel::Decode(reader, supportedCommands);
        }
        else if (__context_tag == to_underlying(Fields::kState))
        {
            err = DataModel::Decode(reader, state);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ActionStruct

namespace EndpointListStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kEndpointListID), endpointListID);
    encoder.Encode(to_underlying(Fields::kName), name);
    encoder.Encode(to_underlying(Fields::kType), type);
    encoder.Encode(to_underlying(Fields::kEndpoints), endpoints);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kEndpointListID))
        {
            err = DataModel::Decode(reader, endpointListID);
        }
        else if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else if (__context_tag == to_underlying(Fields::kType))
        {
            err = DataModel::Decode(reader, type);
        }
        else if (__context_tag == to_underlying(Fields::kEndpoints))
        {
            err = DataModel::Decode(reader, endpoints);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace EndpointListStruct
} // namespace Structs

namespace Commands {
namespace InstantAction {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kActionID), actionID);
    encoder.Encode(to_underlying(Fields::kInvokeID), invokeID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActionID))
        {
            err = DataModel::Decode(reader, actionID);
        }
        else if (__context_tag == to_underlying(Fields::kInvokeID))
        {
            err = DataModel::Decode(reader, invokeID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace InstantAction.
namespace InstantActionWithTransition {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kActionID), actionID);
    encoder.Encode(to_underlying(Fields::kInvokeID), invokeID);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActionID))
        {
            err = DataModel::Decode(reader, actionID);
        }
        else if (__context_tag == to_underlying(Fields::kInvokeID))
        {
            err = DataModel::Decode(reader, invokeID);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace InstantActionWithTransition.
namespace StartAction {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kActionID), actionID);
    encoder.Encode(to_underlying(Fields::kInvokeID), invokeID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActionID))
        {
            err = DataModel::Decode(reader, actionID);
        }
        else if (__context_tag == to_underlying(Fields::kInvokeID))
        {
            err = DataModel::Decode(reader, invokeID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StartAction.
namespace StartActionWithDuration {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kActionID), actionID);
    encoder.Encode(to_underlying(Fields::kInvokeID), invokeID);
    encoder.Encode(to_underlying(Fields::kDuration), duration);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActionID))
        {
            err = DataModel::Decode(reader, actionID);
        }
        else if (__context_tag == to_underlying(Fields::kInvokeID))
        {
            err = DataModel::Decode(reader, invokeID);
        }
        else if (__context_tag == to_underlying(Fields::kDuration))
        {
            err = DataModel::Decode(reader, duration);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StartActionWithDuration.
namespace StopAction {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kActionID), actionID);
    encoder.Encode(to_underlying(Fields::kInvokeID), invokeID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActionID))
        {
            err = DataModel::Decode(reader, actionID);
        }
        else if (__context_tag == to_underlying(Fields::kInvokeID))
        {
            err = DataModel::Decode(reader, invokeID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StopAction.
namespace PauseAction {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kActionID), actionID);
    encoder.Encode(to_underlying(Fields::kInvokeID), invokeID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActionID))
        {
            err = DataModel::Decode(reader, actionID);
        }
        else if (__context_tag == to_underlying(Fields::kInvokeID))
        {
            err = DataModel::Decode(reader, invokeID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace PauseAction.
namespace PauseActionWithDuration {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kActionID), actionID);
    encoder.Encode(to_underlying(Fields::kInvokeID), invokeID);
    encoder.Encode(to_underlying(Fields::kDuration), duration);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActionID))
        {
            err = DataModel::Decode(reader, actionID);
        }
        else if (__context_tag == to_underlying(Fields::kInvokeID))
        {
            err = DataModel::Decode(reader, invokeID);
        }
        else if (__context_tag == to_underlying(Fields::kDuration))
        {
            err = DataModel::Decode(reader, duration);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace PauseActionWithDuration.
namespace ResumeAction {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kActionID), actionID);
    encoder.Encode(to_underlying(Fields::kInvokeID), invokeID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActionID))
        {
            err = DataModel::Decode(reader, actionID);
        }
        else if (__context_tag == to_underlying(Fields::kInvokeID))
        {
            err = DataModel::Decode(reader, invokeID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ResumeAction.
namespace EnableAction {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kActionID), actionID);
    encoder.Encode(to_underlying(Fields::kInvokeID), invokeID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActionID))
        {
            err = DataModel::Decode(reader, actionID);
        }
        else if (__context_tag == to_underlying(Fields::kInvokeID))
        {
            err = DataModel::Decode(reader, invokeID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace EnableAction.
namespace EnableActionWithDuration {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kActionID), actionID);
    encoder.Encode(to_underlying(Fields::kInvokeID), invokeID);
    encoder.Encode(to_underlying(Fields::kDuration), duration);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActionID))
        {
            err = DataModel::Decode(reader, actionID);
        }
        else if (__context_tag == to_underlying(Fields::kInvokeID))
        {
            err = DataModel::Decode(reader, invokeID);
        }
        else if (__context_tag == to_underlying(Fields::kDuration))
        {
            err = DataModel::Decode(reader, duration);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace EnableActionWithDuration.
namespace DisableAction {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kActionID), actionID);
    encoder.Encode(to_underlying(Fields::kInvokeID), invokeID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActionID))
        {
            err = DataModel::Decode(reader, actionID);
        }
        else if (__context_tag == to_underlying(Fields::kInvokeID))
        {
            err = DataModel::Decode(reader, invokeID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace DisableAction.
namespace DisableActionWithDuration {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kActionID), actionID);
    encoder.Encode(to_underlying(Fields::kInvokeID), invokeID);
    encoder.Encode(to_underlying(Fields::kDuration), duration);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActionID))
        {
            err = DataModel::Decode(reader, actionID);
        }
        else if (__context_tag == to_underlying(Fields::kInvokeID))
        {
            err = DataModel::Decode(reader, invokeID);
        }
        else if (__context_tag == to_underlying(Fields::kDuration))
        {
            err = DataModel::Decode(reader, duration);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace DisableActionWithDuration.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::ActionList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, actionList);
    case Attributes::EndpointLists::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, endpointLists);
    case Attributes::SetupURL::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, setupURL);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace StateChanged {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kActionID), actionID));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kInvokeID), invokeID));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kNewState), newState));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActionID))
        {
            err = DataModel::Decode(reader, actionID);
        }
        else if (__context_tag == to_underlying(Fields::kInvokeID))
        {
            err = DataModel::Decode(reader, invokeID);
        }
        else if (__context_tag == to_underlying(Fields::kNewState))
        {
            err = DataModel::Decode(reader, newState);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StateChanged.
namespace ActionFailed {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kActionID), actionID));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kInvokeID), invokeID));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kNewState), newState));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kError), error));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActionID))
        {
            err = DataModel::Decode(reader, actionID);
        }
        else if (__context_tag == to_underlying(Fields::kInvokeID))
        {
            err = DataModel::Decode(reader, invokeID);
        }
        else if (__context_tag == to_underlying(Fields::kNewState))
        {
            err = DataModel::Decode(reader, newState);
        }
        else if (__context_tag == to_underlying(Fields::kError))
        {
            err = DataModel::Decode(reader, error);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ActionFailed.
} // namespace Events

} // namespace Actions
namespace BasicInformation {
namespace Structs {

namespace CapabilityMinimaStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCaseSessionsPerFabric), caseSessionsPerFabric);
    encoder.Encode(to_underlying(Fields::kSubscriptionsPerFabric), subscriptionsPerFabric);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCaseSessionsPerFabric))
        {
            err = DataModel::Decode(reader, caseSessionsPerFabric);
        }
        else if (__context_tag == to_underlying(Fields::kSubscriptionsPerFabric))
        {
            err = DataModel::Decode(reader, subscriptionsPerFabric);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace CapabilityMinimaStruct

namespace ProductAppearanceStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kFinish), finish);
    encoder.Encode(to_underlying(Fields::kPrimaryColor), primaryColor);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kFinish))
        {
            err = DataModel::Decode(reader, finish);
        }
        else if (__context_tag == to_underlying(Fields::kPrimaryColor))
        {
            err = DataModel::Decode(reader, primaryColor);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ProductAppearanceStruct
} // namespace Structs

namespace Commands {
namespace MfgSpecificPing {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace MfgSpecificPing.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::DataModelRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dataModelRevision);
    case Attributes::VendorName::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, vendorName);
    case Attributes::VendorID::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, vendorID);
    case Attributes::ProductName::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, productName);
    case Attributes::ProductID::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, productID);
    case Attributes::NodeLabel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nodeLabel);
    case Attributes::Location::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, location);
    case Attributes::HardwareVersion::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, hardwareVersion);
    case Attributes::HardwareVersionString::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, hardwareVersionString);
    case Attributes::SoftwareVersion::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, softwareVersion);
    case Attributes::SoftwareVersionString::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, softwareVersionString);
    case Attributes::ManufacturingDate::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, manufacturingDate);
    case Attributes::PartNumber::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, partNumber);
    case Attributes::ProductURL::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, productURL);
    case Attributes::ProductLabel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, productLabel);
    case Attributes::SerialNumber::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, serialNumber);
    case Attributes::LocalConfigDisabled::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, localConfigDisabled);
    case Attributes::Reachable::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, reachable);
    case Attributes::UniqueID::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, uniqueID);
    case Attributes::CapabilityMinima::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, capabilityMinima);
    case Attributes::ProductAppearance::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, productAppearance);
    case Attributes::SpecificationVersion::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, specificationVersion);
    case Attributes::MaxPathsPerInvoke::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxPathsPerInvoke);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace StartUp {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSoftwareVersion), softwareVersion));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSoftwareVersion))
        {
            err = DataModel::Decode(reader, softwareVersion);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StartUp.
namespace ShutDown {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ShutDown.
namespace Leave {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kFabricIndex), fabricIndex));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Leave.
namespace ReachableChanged {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kReachableNewValue), reachableNewValue));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kReachableNewValue))
        {
            err = DataModel::Decode(reader, reachableNewValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ReachableChanged.
} // namespace Events

} // namespace BasicInformation
namespace OtaSoftwareUpdateProvider {

namespace Commands {
namespace QueryImage {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kVendorID), vendorID);
    encoder.Encode(to_underlying(Fields::kProductID), productID);
    encoder.Encode(to_underlying(Fields::kSoftwareVersion), softwareVersion);
    encoder.Encode(to_underlying(Fields::kProtocolsSupported), protocolsSupported);
    encoder.Encode(to_underlying(Fields::kHardwareVersion), hardwareVersion);
    encoder.Encode(to_underlying(Fields::kLocation), location);
    encoder.Encode(to_underlying(Fields::kRequestorCanConsent), requestorCanConsent);
    encoder.Encode(to_underlying(Fields::kMetadataForProvider), metadataForProvider);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kVendorID))
        {
            err = DataModel::Decode(reader, vendorID);
        }
        else if (__context_tag == to_underlying(Fields::kProductID))
        {
            err = DataModel::Decode(reader, productID);
        }
        else if (__context_tag == to_underlying(Fields::kSoftwareVersion))
        {
            err = DataModel::Decode(reader, softwareVersion);
        }
        else if (__context_tag == to_underlying(Fields::kProtocolsSupported))
        {
            err = DataModel::Decode(reader, protocolsSupported);
        }
        else if (__context_tag == to_underlying(Fields::kHardwareVersion))
        {
            err = DataModel::Decode(reader, hardwareVersion);
        }
        else if (__context_tag == to_underlying(Fields::kLocation))
        {
            err = DataModel::Decode(reader, location);
        }
        else if (__context_tag == to_underlying(Fields::kRequestorCanConsent))
        {
            err = DataModel::Decode(reader, requestorCanConsent);
        }
        else if (__context_tag == to_underlying(Fields::kMetadataForProvider))
        {
            err = DataModel::Decode(reader, metadataForProvider);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace QueryImage.
namespace QueryImageResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kDelayedActionTime), delayedActionTime);
    encoder.Encode(to_underlying(Fields::kImageURI), imageURI);
    encoder.Encode(to_underlying(Fields::kSoftwareVersion), softwareVersion);
    encoder.Encode(to_underlying(Fields::kSoftwareVersionString), softwareVersionString);
    encoder.Encode(to_underlying(Fields::kUpdateToken), updateToken);
    encoder.Encode(to_underlying(Fields::kUserConsentNeeded), userConsentNeeded);
    encoder.Encode(to_underlying(Fields::kMetadataForRequestor), metadataForRequestor);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kDelayedActionTime))
        {
            err = DataModel::Decode(reader, delayedActionTime);
        }
        else if (__context_tag == to_underlying(Fields::kImageURI))
        {
            err = DataModel::Decode(reader, imageURI);
        }
        else if (__context_tag == to_underlying(Fields::kSoftwareVersion))
        {
            err = DataModel::Decode(reader, softwareVersion);
        }
        else if (__context_tag == to_underlying(Fields::kSoftwareVersionString))
        {
            err = DataModel::Decode(reader, softwareVersionString);
        }
        else if (__context_tag == to_underlying(Fields::kUpdateToken))
        {
            err = DataModel::Decode(reader, updateToken);
        }
        else if (__context_tag == to_underlying(Fields::kUserConsentNeeded))
        {
            err = DataModel::Decode(reader, userConsentNeeded);
        }
        else if (__context_tag == to_underlying(Fields::kMetadataForRequestor))
        {
            err = DataModel::Decode(reader, metadataForRequestor);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace QueryImageResponse.
namespace ApplyUpdateRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kUpdateToken), updateToken);
    encoder.Encode(to_underlying(Fields::kNewVersion), newVersion);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kUpdateToken))
        {
            err = DataModel::Decode(reader, updateToken);
        }
        else if (__context_tag == to_underlying(Fields::kNewVersion))
        {
            err = DataModel::Decode(reader, newVersion);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ApplyUpdateRequest.
namespace ApplyUpdateResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kAction), action);
    encoder.Encode(to_underlying(Fields::kDelayedActionTime), delayedActionTime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAction))
        {
            err = DataModel::Decode(reader, action);
        }
        else if (__context_tag == to_underlying(Fields::kDelayedActionTime))
        {
            err = DataModel::Decode(reader, delayedActionTime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ApplyUpdateResponse.
namespace NotifyUpdateApplied {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kUpdateToken), updateToken);
    encoder.Encode(to_underlying(Fields::kSoftwareVersion), softwareVersion);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kUpdateToken))
        {
            err = DataModel::Decode(reader, updateToken);
        }
        else if (__context_tag == to_underlying(Fields::kSoftwareVersion))
        {
            err = DataModel::Decode(reader, softwareVersion);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace NotifyUpdateApplied.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace OtaSoftwareUpdateProvider
namespace OtaSoftwareUpdateRequestor {
namespace Structs {

namespace ProviderLocation {
CHIP_ERROR Type::EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    return DoEncode(aWriter, aTag, NullOptional);
}

CHIP_ERROR Type::EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const
{
    return DoEncode(aWriter, aTag, MakeOptional(aAccessingFabricIndex));
}

CHIP_ERROR Type::DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const
{

    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };

    encoder.Encode(to_underlying(Fields::kProviderNodeID), providerNodeID);
    encoder.Encode(to_underlying(Fields::kEndpoint), endpoint);
    if (aAccessingFabricIndex.HasValue())
    {
        encoder.Encode(to_underlying(Fields::kFabricIndex), fabricIndex);
    }

    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kProviderNodeID))
        {
            err = DataModel::Decode(reader, providerNodeID);
        }
        else if (__context_tag == to_underlying(Fields::kEndpoint))
        {
            err = DataModel::Decode(reader, endpoint);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ProviderLocation
} // namespace Structs

namespace Commands {
namespace AnnounceOTAProvider {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kProviderNodeID), providerNodeID);
    encoder.Encode(to_underlying(Fields::kVendorID), vendorID);
    encoder.Encode(to_underlying(Fields::kAnnouncementReason), announcementReason);
    encoder.Encode(to_underlying(Fields::kMetadataForNode), metadataForNode);
    encoder.Encode(to_underlying(Fields::kEndpoint), endpoint);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kProviderNodeID))
        {
            err = DataModel::Decode(reader, providerNodeID);
        }
        else if (__context_tag == to_underlying(Fields::kVendorID))
        {
            err = DataModel::Decode(reader, vendorID);
        }
        else if (__context_tag == to_underlying(Fields::kAnnouncementReason))
        {
            err = DataModel::Decode(reader, announcementReason);
        }
        else if (__context_tag == to_underlying(Fields::kMetadataForNode))
        {
            err = DataModel::Decode(reader, metadataForNode);
        }
        else if (__context_tag == to_underlying(Fields::kEndpoint))
        {
            err = DataModel::Decode(reader, endpoint);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AnnounceOTAProvider.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::DefaultOTAProviders::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, defaultOTAProviders);
    case Attributes::UpdatePossible::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, updatePossible);
    case Attributes::UpdateState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, updateState);
    case Attributes::UpdateStateProgress::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, updateStateProgress);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace StateTransition {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPreviousState), previousState));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kNewState), newState));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kReason), reason));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kTargetSoftwareVersion), targetSoftwareVersion));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPreviousState))
        {
            err = DataModel::Decode(reader, previousState);
        }
        else if (__context_tag == to_underlying(Fields::kNewState))
        {
            err = DataModel::Decode(reader, newState);
        }
        else if (__context_tag == to_underlying(Fields::kReason))
        {
            err = DataModel::Decode(reader, reason);
        }
        else if (__context_tag == to_underlying(Fields::kTargetSoftwareVersion))
        {
            err = DataModel::Decode(reader, targetSoftwareVersion);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StateTransition.
namespace VersionApplied {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSoftwareVersion), softwareVersion));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kProductID), productID));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSoftwareVersion))
        {
            err = DataModel::Decode(reader, softwareVersion);
        }
        else if (__context_tag == to_underlying(Fields::kProductID))
        {
            err = DataModel::Decode(reader, productID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace VersionApplied.
namespace DownloadError {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSoftwareVersion), softwareVersion));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kBytesDownloaded), bytesDownloaded));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kProgressPercent), progressPercent));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPlatformCode), platformCode));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSoftwareVersion))
        {
            err = DataModel::Decode(reader, softwareVersion);
        }
        else if (__context_tag == to_underlying(Fields::kBytesDownloaded))
        {
            err = DataModel::Decode(reader, bytesDownloaded);
        }
        else if (__context_tag == to_underlying(Fields::kProgressPercent))
        {
            err = DataModel::Decode(reader, progressPercent);
        }
        else if (__context_tag == to_underlying(Fields::kPlatformCode))
        {
            err = DataModel::Decode(reader, platformCode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace DownloadError.
} // namespace Events

} // namespace OtaSoftwareUpdateRequestor
namespace LocalizationConfiguration {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::ActiveLocale::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeLocale);
    case Attributes::SupportedLocales::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedLocales);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace LocalizationConfiguration
namespace TimeFormatLocalization {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::HourFormat::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, hourFormat);
    case Attributes::ActiveCalendarType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeCalendarType);
    case Attributes::SupportedCalendarTypes::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedCalendarTypes);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace TimeFormatLocalization
namespace UnitLocalization {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::TemperatureUnit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, temperatureUnit);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace UnitLocalization
namespace PowerSourceConfiguration {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Sources::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, sources);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace PowerSourceConfiguration
namespace PowerSource {
namespace Structs {

namespace BatChargeFaultChangeType {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCurrent), current);
    encoder.Encode(to_underlying(Fields::kPrevious), previous);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCurrent))
        {
            err = DataModel::Decode(reader, current);
        }
        else if (__context_tag == to_underlying(Fields::kPrevious))
        {
            err = DataModel::Decode(reader, previous);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace BatChargeFaultChangeType

namespace BatFaultChangeType {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCurrent), current);
    encoder.Encode(to_underlying(Fields::kPrevious), previous);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCurrent))
        {
            err = DataModel::Decode(reader, current);
        }
        else if (__context_tag == to_underlying(Fields::kPrevious))
        {
            err = DataModel::Decode(reader, previous);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace BatFaultChangeType

namespace WiredFaultChangeType {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCurrent), current);
    encoder.Encode(to_underlying(Fields::kPrevious), previous);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCurrent))
        {
            err = DataModel::Decode(reader, current);
        }
        else if (__context_tag == to_underlying(Fields::kPrevious))
        {
            err = DataModel::Decode(reader, previous);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace WiredFaultChangeType
} // namespace Structs

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Status::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, status);
    case Attributes::Order::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, order);
    case Attributes::Description::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, description);
    case Attributes::WiredAssessedInputVoltage::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, wiredAssessedInputVoltage);
    case Attributes::WiredAssessedInputFrequency::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, wiredAssessedInputFrequency);
    case Attributes::WiredCurrentType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, wiredCurrentType);
    case Attributes::WiredAssessedCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, wiredAssessedCurrent);
    case Attributes::WiredNominalVoltage::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, wiredNominalVoltage);
    case Attributes::WiredMaximumCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, wiredMaximumCurrent);
    case Attributes::WiredPresent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, wiredPresent);
    case Attributes::ActiveWiredFaults::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeWiredFaults);
    case Attributes::BatVoltage::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batVoltage);
    case Attributes::BatPercentRemaining::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batPercentRemaining);
    case Attributes::BatTimeRemaining::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batTimeRemaining);
    case Attributes::BatChargeLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batChargeLevel);
    case Attributes::BatReplacementNeeded::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batReplacementNeeded);
    case Attributes::BatReplaceability::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batReplaceability);
    case Attributes::BatPresent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batPresent);
    case Attributes::ActiveBatFaults::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeBatFaults);
    case Attributes::BatReplacementDescription::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batReplacementDescription);
    case Attributes::BatCommonDesignation::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batCommonDesignation);
    case Attributes::BatANSIDesignation::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batANSIDesignation);
    case Attributes::BatIECDesignation::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batIECDesignation);
    case Attributes::BatApprovedChemistry::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batApprovedChemistry);
    case Attributes::BatCapacity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batCapacity);
    case Attributes::BatQuantity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batQuantity);
    case Attributes::BatChargeState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batChargeState);
    case Attributes::BatTimeToFullCharge::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batTimeToFullCharge);
    case Attributes::BatFunctionalWhileCharging::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batFunctionalWhileCharging);
    case Attributes::BatChargingCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batChargingCurrent);
    case Attributes::ActiveBatChargeFaults::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeBatChargeFaults);
    case Attributes::EndpointList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, endpointList);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace WiredFaultChange {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCurrent), current));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPrevious), previous));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCurrent))
        {
            err = DataModel::Decode(reader, current);
        }
        else if (__context_tag == to_underlying(Fields::kPrevious))
        {
            err = DataModel::Decode(reader, previous);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace WiredFaultChange.
namespace BatFaultChange {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCurrent), current));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPrevious), previous));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCurrent))
        {
            err = DataModel::Decode(reader, current);
        }
        else if (__context_tag == to_underlying(Fields::kPrevious))
        {
            err = DataModel::Decode(reader, previous);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace BatFaultChange.
namespace BatChargeFaultChange {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCurrent), current));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPrevious), previous));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCurrent))
        {
            err = DataModel::Decode(reader, current);
        }
        else if (__context_tag == to_underlying(Fields::kPrevious))
        {
            err = DataModel::Decode(reader, previous);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace BatChargeFaultChange.
} // namespace Events

} // namespace PowerSource
namespace GeneralCommissioning {
namespace Structs {

namespace BasicCommissioningInfo {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kFailSafeExpiryLengthSeconds), failSafeExpiryLengthSeconds);
    encoder.Encode(to_underlying(Fields::kMaxCumulativeFailsafeSeconds), maxCumulativeFailsafeSeconds);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kFailSafeExpiryLengthSeconds))
        {
            err = DataModel::Decode(reader, failSafeExpiryLengthSeconds);
        }
        else if (__context_tag == to_underlying(Fields::kMaxCumulativeFailsafeSeconds))
        {
            err = DataModel::Decode(reader, maxCumulativeFailsafeSeconds);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace BasicCommissioningInfo
} // namespace Structs

namespace Commands {
namespace ArmFailSafe {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kExpiryLengthSeconds), expiryLengthSeconds);
    encoder.Encode(to_underlying(Fields::kBreadcrumb), breadcrumb);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kExpiryLengthSeconds))
        {
            err = DataModel::Decode(reader, expiryLengthSeconds);
        }
        else if (__context_tag == to_underlying(Fields::kBreadcrumb))
        {
            err = DataModel::Decode(reader, breadcrumb);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ArmFailSafe.
namespace ArmFailSafeResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kErrorCode), errorCode);
    encoder.Encode(to_underlying(Fields::kDebugText), debugText);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kErrorCode))
        {
            err = DataModel::Decode(reader, errorCode);
        }
        else if (__context_tag == to_underlying(Fields::kDebugText))
        {
            err = DataModel::Decode(reader, debugText);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ArmFailSafeResponse.
namespace SetRegulatoryConfig {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNewRegulatoryConfig), newRegulatoryConfig);
    encoder.Encode(to_underlying(Fields::kCountryCode), countryCode);
    encoder.Encode(to_underlying(Fields::kBreadcrumb), breadcrumb);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNewRegulatoryConfig))
        {
            err = DataModel::Decode(reader, newRegulatoryConfig);
        }
        else if (__context_tag == to_underlying(Fields::kCountryCode))
        {
            err = DataModel::Decode(reader, countryCode);
        }
        else if (__context_tag == to_underlying(Fields::kBreadcrumb))
        {
            err = DataModel::Decode(reader, breadcrumb);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetRegulatoryConfig.
namespace SetRegulatoryConfigResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kErrorCode), errorCode);
    encoder.Encode(to_underlying(Fields::kDebugText), debugText);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kErrorCode))
        {
            err = DataModel::Decode(reader, errorCode);
        }
        else if (__context_tag == to_underlying(Fields::kDebugText))
        {
            err = DataModel::Decode(reader, debugText);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetRegulatoryConfigResponse.
namespace CommissioningComplete {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace CommissioningComplete.
namespace CommissioningCompleteResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kErrorCode), errorCode);
    encoder.Encode(to_underlying(Fields::kDebugText), debugText);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kErrorCode))
        {
            err = DataModel::Decode(reader, errorCode);
        }
        else if (__context_tag == to_underlying(Fields::kDebugText))
        {
            err = DataModel::Decode(reader, debugText);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace CommissioningCompleteResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Breadcrumb::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, breadcrumb);
    case Attributes::BasicCommissioningInfo::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, basicCommissioningInfo);
    case Attributes::RegulatoryConfig::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, regulatoryConfig);
    case Attributes::LocationCapability::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, locationCapability);
    case Attributes::SupportsConcurrentConnection::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportsConcurrentConnection);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace GeneralCommissioning
namespace NetworkCommissioning {
namespace Structs {

namespace NetworkInfoStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNetworkID), networkID);
    encoder.Encode(to_underlying(Fields::kConnected), connected);
    encoder.Encode(to_underlying(Fields::kNetworkIdentifier), networkIdentifier);
    encoder.Encode(to_underlying(Fields::kClientIdentifier), clientIdentifier);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNetworkID))
        {
            err = DataModel::Decode(reader, networkID);
        }
        else if (__context_tag == to_underlying(Fields::kConnected))
        {
            err = DataModel::Decode(reader, connected);
        }
        else if (__context_tag == to_underlying(Fields::kNetworkIdentifier))
        {
            err = DataModel::Decode(reader, networkIdentifier);
        }
        else if (__context_tag == to_underlying(Fields::kClientIdentifier))
        {
            err = DataModel::Decode(reader, clientIdentifier);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace NetworkInfoStruct

namespace ThreadInterfaceScanResultStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPanId), panId);
    encoder.Encode(to_underlying(Fields::kExtendedPanId), extendedPanId);
    encoder.Encode(to_underlying(Fields::kNetworkName), networkName);
    encoder.Encode(to_underlying(Fields::kChannel), channel);
    encoder.Encode(to_underlying(Fields::kVersion), version);
    encoder.Encode(to_underlying(Fields::kExtendedAddress), extendedAddress);
    encoder.Encode(to_underlying(Fields::kRssi), rssi);
    encoder.Encode(to_underlying(Fields::kLqi), lqi);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPanId))
        {
            err = DataModel::Decode(reader, panId);
        }
        else if (__context_tag == to_underlying(Fields::kExtendedPanId))
        {
            err = DataModel::Decode(reader, extendedPanId);
        }
        else if (__context_tag == to_underlying(Fields::kNetworkName))
        {
            err = DataModel::Decode(reader, networkName);
        }
        else if (__context_tag == to_underlying(Fields::kChannel))
        {
            err = DataModel::Decode(reader, channel);
        }
        else if (__context_tag == to_underlying(Fields::kVersion))
        {
            err = DataModel::Decode(reader, version);
        }
        else if (__context_tag == to_underlying(Fields::kExtendedAddress))
        {
            err = DataModel::Decode(reader, extendedAddress);
        }
        else if (__context_tag == to_underlying(Fields::kRssi))
        {
            err = DataModel::Decode(reader, rssi);
        }
        else if (__context_tag == to_underlying(Fields::kLqi))
        {
            err = DataModel::Decode(reader, lqi);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ThreadInterfaceScanResultStruct

namespace WiFiInterfaceScanResultStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kSecurity), security);
    encoder.Encode(to_underlying(Fields::kSsid), ssid);
    encoder.Encode(to_underlying(Fields::kBssid), bssid);
    encoder.Encode(to_underlying(Fields::kChannel), channel);
    encoder.Encode(to_underlying(Fields::kWiFiBand), wiFiBand);
    encoder.Encode(to_underlying(Fields::kRssi), rssi);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSecurity))
        {
            err = DataModel::Decode(reader, security);
        }
        else if (__context_tag == to_underlying(Fields::kSsid))
        {
            err = DataModel::Decode(reader, ssid);
        }
        else if (__context_tag == to_underlying(Fields::kBssid))
        {
            err = DataModel::Decode(reader, bssid);
        }
        else if (__context_tag == to_underlying(Fields::kChannel))
        {
            err = DataModel::Decode(reader, channel);
        }
        else if (__context_tag == to_underlying(Fields::kWiFiBand))
        {
            err = DataModel::Decode(reader, wiFiBand);
        }
        else if (__context_tag == to_underlying(Fields::kRssi))
        {
            err = DataModel::Decode(reader, rssi);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace WiFiInterfaceScanResultStruct
} // namespace Structs

namespace Commands {
namespace ScanNetworks {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kSsid), ssid);
    encoder.Encode(to_underlying(Fields::kBreadcrumb), breadcrumb);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSsid))
        {
            err = DataModel::Decode(reader, ssid);
        }
        else if (__context_tag == to_underlying(Fields::kBreadcrumb))
        {
            err = DataModel::Decode(reader, breadcrumb);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ScanNetworks.
namespace ScanNetworksResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNetworkingStatus), networkingStatus);
    encoder.Encode(to_underlying(Fields::kDebugText), debugText);
    encoder.Encode(to_underlying(Fields::kWiFiScanResults), wiFiScanResults);
    encoder.Encode(to_underlying(Fields::kThreadScanResults), threadScanResults);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNetworkingStatus))
        {
            err = DataModel::Decode(reader, networkingStatus);
        }
        else if (__context_tag == to_underlying(Fields::kDebugText))
        {
            err = DataModel::Decode(reader, debugText);
        }
        else if (__context_tag == to_underlying(Fields::kWiFiScanResults))
        {
            err = DataModel::Decode(reader, wiFiScanResults);
        }
        else if (__context_tag == to_underlying(Fields::kThreadScanResults))
        {
            err = DataModel::Decode(reader, threadScanResults);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ScanNetworksResponse.
namespace AddOrUpdateWiFiNetwork {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kSsid), ssid);
    encoder.Encode(to_underlying(Fields::kCredentials), credentials);
    encoder.Encode(to_underlying(Fields::kBreadcrumb), breadcrumb);
    encoder.Encode(to_underlying(Fields::kNetworkIdentity), networkIdentity);
    encoder.Encode(to_underlying(Fields::kClientIdentifier), clientIdentifier);
    encoder.Encode(to_underlying(Fields::kPossessionNonce), possessionNonce);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSsid))
        {
            err = DataModel::Decode(reader, ssid);
        }
        else if (__context_tag == to_underlying(Fields::kCredentials))
        {
            err = DataModel::Decode(reader, credentials);
        }
        else if (__context_tag == to_underlying(Fields::kBreadcrumb))
        {
            err = DataModel::Decode(reader, breadcrumb);
        }
        else if (__context_tag == to_underlying(Fields::kNetworkIdentity))
        {
            err = DataModel::Decode(reader, networkIdentity);
        }
        else if (__context_tag == to_underlying(Fields::kClientIdentifier))
        {
            err = DataModel::Decode(reader, clientIdentifier);
        }
        else if (__context_tag == to_underlying(Fields::kPossessionNonce))
        {
            err = DataModel::Decode(reader, possessionNonce);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AddOrUpdateWiFiNetwork.
namespace AddOrUpdateThreadNetwork {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOperationalDataset), operationalDataset);
    encoder.Encode(to_underlying(Fields::kBreadcrumb), breadcrumb);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kOperationalDataset))
        {
            err = DataModel::Decode(reader, operationalDataset);
        }
        else if (__context_tag == to_underlying(Fields::kBreadcrumb))
        {
            err = DataModel::Decode(reader, breadcrumb);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AddOrUpdateThreadNetwork.
namespace RemoveNetwork {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNetworkID), networkID);
    encoder.Encode(to_underlying(Fields::kBreadcrumb), breadcrumb);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNetworkID))
        {
            err = DataModel::Decode(reader, networkID);
        }
        else if (__context_tag == to_underlying(Fields::kBreadcrumb))
        {
            err = DataModel::Decode(reader, breadcrumb);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RemoveNetwork.
namespace NetworkConfigResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNetworkingStatus), networkingStatus);
    encoder.Encode(to_underlying(Fields::kDebugText), debugText);
    encoder.Encode(to_underlying(Fields::kNetworkIndex), networkIndex);
    encoder.Encode(to_underlying(Fields::kClientIdentity), clientIdentity);
    encoder.Encode(to_underlying(Fields::kPossessionSignature), possessionSignature);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNetworkingStatus))
        {
            err = DataModel::Decode(reader, networkingStatus);
        }
        else if (__context_tag == to_underlying(Fields::kDebugText))
        {
            err = DataModel::Decode(reader, debugText);
        }
        else if (__context_tag == to_underlying(Fields::kNetworkIndex))
        {
            err = DataModel::Decode(reader, networkIndex);
        }
        else if (__context_tag == to_underlying(Fields::kClientIdentity))
        {
            err = DataModel::Decode(reader, clientIdentity);
        }
        else if (__context_tag == to_underlying(Fields::kPossessionSignature))
        {
            err = DataModel::Decode(reader, possessionSignature);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace NetworkConfigResponse.
namespace ConnectNetwork {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNetworkID), networkID);
    encoder.Encode(to_underlying(Fields::kBreadcrumb), breadcrumb);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNetworkID))
        {
            err = DataModel::Decode(reader, networkID);
        }
        else if (__context_tag == to_underlying(Fields::kBreadcrumb))
        {
            err = DataModel::Decode(reader, breadcrumb);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ConnectNetwork.
namespace ConnectNetworkResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNetworkingStatus), networkingStatus);
    encoder.Encode(to_underlying(Fields::kDebugText), debugText);
    encoder.Encode(to_underlying(Fields::kErrorValue), errorValue);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNetworkingStatus))
        {
            err = DataModel::Decode(reader, networkingStatus);
        }
        else if (__context_tag == to_underlying(Fields::kDebugText))
        {
            err = DataModel::Decode(reader, debugText);
        }
        else if (__context_tag == to_underlying(Fields::kErrorValue))
        {
            err = DataModel::Decode(reader, errorValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ConnectNetworkResponse.
namespace ReorderNetwork {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNetworkID), networkID);
    encoder.Encode(to_underlying(Fields::kNetworkIndex), networkIndex);
    encoder.Encode(to_underlying(Fields::kBreadcrumb), breadcrumb);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNetworkID))
        {
            err = DataModel::Decode(reader, networkID);
        }
        else if (__context_tag == to_underlying(Fields::kNetworkIndex))
        {
            err = DataModel::Decode(reader, networkIndex);
        }
        else if (__context_tag == to_underlying(Fields::kBreadcrumb))
        {
            err = DataModel::Decode(reader, breadcrumb);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ReorderNetwork.
namespace QueryIdentity {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kKeyIdentifier), keyIdentifier);
    encoder.Encode(to_underlying(Fields::kPossessionNonce), possessionNonce);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kKeyIdentifier))
        {
            err = DataModel::Decode(reader, keyIdentifier);
        }
        else if (__context_tag == to_underlying(Fields::kPossessionNonce))
        {
            err = DataModel::Decode(reader, possessionNonce);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace QueryIdentity.
namespace QueryIdentityResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kIdentity), identity);
    encoder.Encode(to_underlying(Fields::kPossessionSignature), possessionSignature);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kIdentity))
        {
            err = DataModel::Decode(reader, identity);
        }
        else if (__context_tag == to_underlying(Fields::kPossessionSignature))
        {
            err = DataModel::Decode(reader, possessionSignature);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace QueryIdentityResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MaxNetworks::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxNetworks);
    case Attributes::Networks::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, networks);
    case Attributes::ScanMaxTimeSeconds::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, scanMaxTimeSeconds);
    case Attributes::ConnectMaxTimeSeconds::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, connectMaxTimeSeconds);
    case Attributes::InterfaceEnabled::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, interfaceEnabled);
    case Attributes::LastNetworkingStatus::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lastNetworkingStatus);
    case Attributes::LastNetworkID::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lastNetworkID);
    case Attributes::LastConnectErrorValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lastConnectErrorValue);
    case Attributes::SupportedWiFiBands::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedWiFiBands);
    case Attributes::SupportedThreadFeatures::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedThreadFeatures);
    case Attributes::ThreadVersion::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, threadVersion);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace NetworkCommissioning
namespace DiagnosticLogs {

namespace Commands {
namespace RetrieveLogsRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kIntent), intent);
    encoder.Encode(to_underlying(Fields::kRequestedProtocol), requestedProtocol);
    encoder.Encode(to_underlying(Fields::kTransferFileDesignator), transferFileDesignator);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kIntent))
        {
            err = DataModel::Decode(reader, intent);
        }
        else if (__context_tag == to_underlying(Fields::kRequestedProtocol))
        {
            err = DataModel::Decode(reader, requestedProtocol);
        }
        else if (__context_tag == to_underlying(Fields::kTransferFileDesignator))
        {
            err = DataModel::Decode(reader, transferFileDesignator);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RetrieveLogsRequest.
namespace RetrieveLogsResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kLogContent), logContent);
    encoder.Encode(to_underlying(Fields::kUTCTimeStamp), UTCTimeStamp);
    encoder.Encode(to_underlying(Fields::kTimeSinceBoot), timeSinceBoot);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kLogContent))
        {
            err = DataModel::Decode(reader, logContent);
        }
        else if (__context_tag == to_underlying(Fields::kUTCTimeStamp))
        {
            err = DataModel::Decode(reader, UTCTimeStamp);
        }
        else if (__context_tag == to_underlying(Fields::kTimeSinceBoot))
        {
            err = DataModel::Decode(reader, timeSinceBoot);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RetrieveLogsResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace DiagnosticLogs
namespace GeneralDiagnostics {
namespace Structs {

namespace NetworkInterface {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kName), name);
    encoder.Encode(to_underlying(Fields::kIsOperational), isOperational);
    encoder.Encode(to_underlying(Fields::kOffPremiseServicesReachableIPv4), offPremiseServicesReachableIPv4);
    encoder.Encode(to_underlying(Fields::kOffPremiseServicesReachableIPv6), offPremiseServicesReachableIPv6);
    encoder.Encode(to_underlying(Fields::kHardwareAddress), hardwareAddress);
    encoder.Encode(to_underlying(Fields::kIPv4Addresses), IPv4Addresses);
    encoder.Encode(to_underlying(Fields::kIPv6Addresses), IPv6Addresses);
    encoder.Encode(to_underlying(Fields::kType), type);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else if (__context_tag == to_underlying(Fields::kIsOperational))
        {
            err = DataModel::Decode(reader, isOperational);
        }
        else if (__context_tag == to_underlying(Fields::kOffPremiseServicesReachableIPv4))
        {
            err = DataModel::Decode(reader, offPremiseServicesReachableIPv4);
        }
        else if (__context_tag == to_underlying(Fields::kOffPremiseServicesReachableIPv6))
        {
            err = DataModel::Decode(reader, offPremiseServicesReachableIPv6);
        }
        else if (__context_tag == to_underlying(Fields::kHardwareAddress))
        {
            err = DataModel::Decode(reader, hardwareAddress);
        }
        else if (__context_tag == to_underlying(Fields::kIPv4Addresses))
        {
            err = DataModel::Decode(reader, IPv4Addresses);
        }
        else if (__context_tag == to_underlying(Fields::kIPv6Addresses))
        {
            err = DataModel::Decode(reader, IPv6Addresses);
        }
        else if (__context_tag == to_underlying(Fields::kType))
        {
            err = DataModel::Decode(reader, type);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace NetworkInterface
} // namespace Structs

namespace Commands {
namespace TestEventTrigger {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kEnableKey), enableKey);
    encoder.Encode(to_underlying(Fields::kEventTrigger), eventTrigger);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kEnableKey))
        {
            err = DataModel::Decode(reader, enableKey);
        }
        else if (__context_tag == to_underlying(Fields::kEventTrigger))
        {
            err = DataModel::Decode(reader, eventTrigger);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestEventTrigger.
namespace TimeSnapshot {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace TimeSnapshot.
namespace TimeSnapshotResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kSystemTimeMs), systemTimeMs);
    encoder.Encode(to_underlying(Fields::kPosixTimeMs), posixTimeMs);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSystemTimeMs))
        {
            err = DataModel::Decode(reader, systemTimeMs);
        }
        else if (__context_tag == to_underlying(Fields::kPosixTimeMs))
        {
            err = DataModel::Decode(reader, posixTimeMs);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TimeSnapshotResponse.
namespace PayloadTestRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kEnableKey), enableKey);
    encoder.Encode(to_underlying(Fields::kValue), value);
    encoder.Encode(to_underlying(Fields::kCount), count);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kEnableKey))
        {
            err = DataModel::Decode(reader, enableKey);
        }
        else if (__context_tag == to_underlying(Fields::kValue))
        {
            err = DataModel::Decode(reader, value);
        }
        else if (__context_tag == to_underlying(Fields::kCount))
        {
            err = DataModel::Decode(reader, count);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace PayloadTestRequest.
namespace PayloadTestResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPayload), payload);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPayload))
        {
            err = DataModel::Decode(reader, payload);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace PayloadTestResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::NetworkInterfaces::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, networkInterfaces);
    case Attributes::RebootCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rebootCount);
    case Attributes::UpTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, upTime);
    case Attributes::TotalOperationalHours::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, totalOperationalHours);
    case Attributes::BootReason::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, bootReason);
    case Attributes::ActiveHardwareFaults::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeHardwareFaults);
    case Attributes::ActiveRadioFaults::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeRadioFaults);
    case Attributes::ActiveNetworkFaults::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeNetworkFaults);
    case Attributes::TestEventTriggersEnabled::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, testEventTriggersEnabled);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace HardwareFaultChange {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCurrent), current));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPrevious), previous));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCurrent))
        {
            err = DataModel::Decode(reader, current);
        }
        else if (__context_tag == to_underlying(Fields::kPrevious))
        {
            err = DataModel::Decode(reader, previous);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace HardwareFaultChange.
namespace RadioFaultChange {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCurrent), current));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPrevious), previous));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCurrent))
        {
            err = DataModel::Decode(reader, current);
        }
        else if (__context_tag == to_underlying(Fields::kPrevious))
        {
            err = DataModel::Decode(reader, previous);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RadioFaultChange.
namespace NetworkFaultChange {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCurrent), current));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPrevious), previous));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCurrent))
        {
            err = DataModel::Decode(reader, current);
        }
        else if (__context_tag == to_underlying(Fields::kPrevious))
        {
            err = DataModel::Decode(reader, previous);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace NetworkFaultChange.
namespace BootReason {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kBootReason), bootReason));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kBootReason))
        {
            err = DataModel::Decode(reader, bootReason);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace BootReason.
} // namespace Events

} // namespace GeneralDiagnostics
namespace SoftwareDiagnostics {
namespace Structs {

namespace ThreadMetricsStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kId), id);
    encoder.Encode(to_underlying(Fields::kName), name);
    encoder.Encode(to_underlying(Fields::kStackFreeCurrent), stackFreeCurrent);
    encoder.Encode(to_underlying(Fields::kStackFreeMinimum), stackFreeMinimum);
    encoder.Encode(to_underlying(Fields::kStackSize), stackSize);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kId))
        {
            err = DataModel::Decode(reader, id);
        }
        else if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else if (__context_tag == to_underlying(Fields::kStackFreeCurrent))
        {
            err = DataModel::Decode(reader, stackFreeCurrent);
        }
        else if (__context_tag == to_underlying(Fields::kStackFreeMinimum))
        {
            err = DataModel::Decode(reader, stackFreeMinimum);
        }
        else if (__context_tag == to_underlying(Fields::kStackSize))
        {
            err = DataModel::Decode(reader, stackSize);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ThreadMetricsStruct
} // namespace Structs

namespace Commands {
namespace ResetWatermarks {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ResetWatermarks.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::ThreadMetrics::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, threadMetrics);
    case Attributes::CurrentHeapFree::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentHeapFree);
    case Attributes::CurrentHeapUsed::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentHeapUsed);
    case Attributes::CurrentHeapHighWatermark::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentHeapHighWatermark);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace SoftwareFault {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kId), id));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kName), name));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kFaultRecording), faultRecording));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kId))
        {
            err = DataModel::Decode(reader, id);
        }
        else if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else if (__context_tag == to_underlying(Fields::kFaultRecording))
        {
            err = DataModel::Decode(reader, faultRecording);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SoftwareFault.
} // namespace Events

} // namespace SoftwareDiagnostics
namespace ThreadNetworkDiagnostics {
namespace Structs {

namespace NeighborTableStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kExtAddress), extAddress);
    encoder.Encode(to_underlying(Fields::kAge), age);
    encoder.Encode(to_underlying(Fields::kRloc16), rloc16);
    encoder.Encode(to_underlying(Fields::kLinkFrameCounter), linkFrameCounter);
    encoder.Encode(to_underlying(Fields::kMleFrameCounter), mleFrameCounter);
    encoder.Encode(to_underlying(Fields::kLqi), lqi);
    encoder.Encode(to_underlying(Fields::kAverageRssi), averageRssi);
    encoder.Encode(to_underlying(Fields::kLastRssi), lastRssi);
    encoder.Encode(to_underlying(Fields::kFrameErrorRate), frameErrorRate);
    encoder.Encode(to_underlying(Fields::kMessageErrorRate), messageErrorRate);
    encoder.Encode(to_underlying(Fields::kRxOnWhenIdle), rxOnWhenIdle);
    encoder.Encode(to_underlying(Fields::kFullThreadDevice), fullThreadDevice);
    encoder.Encode(to_underlying(Fields::kFullNetworkData), fullNetworkData);
    encoder.Encode(to_underlying(Fields::kIsChild), isChild);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kExtAddress))
        {
            err = DataModel::Decode(reader, extAddress);
        }
        else if (__context_tag == to_underlying(Fields::kAge))
        {
            err = DataModel::Decode(reader, age);
        }
        else if (__context_tag == to_underlying(Fields::kRloc16))
        {
            err = DataModel::Decode(reader, rloc16);
        }
        else if (__context_tag == to_underlying(Fields::kLinkFrameCounter))
        {
            err = DataModel::Decode(reader, linkFrameCounter);
        }
        else if (__context_tag == to_underlying(Fields::kMleFrameCounter))
        {
            err = DataModel::Decode(reader, mleFrameCounter);
        }
        else if (__context_tag == to_underlying(Fields::kLqi))
        {
            err = DataModel::Decode(reader, lqi);
        }
        else if (__context_tag == to_underlying(Fields::kAverageRssi))
        {
            err = DataModel::Decode(reader, averageRssi);
        }
        else if (__context_tag == to_underlying(Fields::kLastRssi))
        {
            err = DataModel::Decode(reader, lastRssi);
        }
        else if (__context_tag == to_underlying(Fields::kFrameErrorRate))
        {
            err = DataModel::Decode(reader, frameErrorRate);
        }
        else if (__context_tag == to_underlying(Fields::kMessageErrorRate))
        {
            err = DataModel::Decode(reader, messageErrorRate);
        }
        else if (__context_tag == to_underlying(Fields::kRxOnWhenIdle))
        {
            err = DataModel::Decode(reader, rxOnWhenIdle);
        }
        else if (__context_tag == to_underlying(Fields::kFullThreadDevice))
        {
            err = DataModel::Decode(reader, fullThreadDevice);
        }
        else if (__context_tag == to_underlying(Fields::kFullNetworkData))
        {
            err = DataModel::Decode(reader, fullNetworkData);
        }
        else if (__context_tag == to_underlying(Fields::kIsChild))
        {
            err = DataModel::Decode(reader, isChild);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace NeighborTableStruct

namespace OperationalDatasetComponents {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kActiveTimestampPresent), activeTimestampPresent);
    encoder.Encode(to_underlying(Fields::kPendingTimestampPresent), pendingTimestampPresent);
    encoder.Encode(to_underlying(Fields::kMasterKeyPresent), masterKeyPresent);
    encoder.Encode(to_underlying(Fields::kNetworkNamePresent), networkNamePresent);
    encoder.Encode(to_underlying(Fields::kExtendedPanIdPresent), extendedPanIdPresent);
    encoder.Encode(to_underlying(Fields::kMeshLocalPrefixPresent), meshLocalPrefixPresent);
    encoder.Encode(to_underlying(Fields::kDelayPresent), delayPresent);
    encoder.Encode(to_underlying(Fields::kPanIdPresent), panIdPresent);
    encoder.Encode(to_underlying(Fields::kChannelPresent), channelPresent);
    encoder.Encode(to_underlying(Fields::kPskcPresent), pskcPresent);
    encoder.Encode(to_underlying(Fields::kSecurityPolicyPresent), securityPolicyPresent);
    encoder.Encode(to_underlying(Fields::kChannelMaskPresent), channelMaskPresent);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActiveTimestampPresent))
        {
            err = DataModel::Decode(reader, activeTimestampPresent);
        }
        else if (__context_tag == to_underlying(Fields::kPendingTimestampPresent))
        {
            err = DataModel::Decode(reader, pendingTimestampPresent);
        }
        else if (__context_tag == to_underlying(Fields::kMasterKeyPresent))
        {
            err = DataModel::Decode(reader, masterKeyPresent);
        }
        else if (__context_tag == to_underlying(Fields::kNetworkNamePresent))
        {
            err = DataModel::Decode(reader, networkNamePresent);
        }
        else if (__context_tag == to_underlying(Fields::kExtendedPanIdPresent))
        {
            err = DataModel::Decode(reader, extendedPanIdPresent);
        }
        else if (__context_tag == to_underlying(Fields::kMeshLocalPrefixPresent))
        {
            err = DataModel::Decode(reader, meshLocalPrefixPresent);
        }
        else if (__context_tag == to_underlying(Fields::kDelayPresent))
        {
            err = DataModel::Decode(reader, delayPresent);
        }
        else if (__context_tag == to_underlying(Fields::kPanIdPresent))
        {
            err = DataModel::Decode(reader, panIdPresent);
        }
        else if (__context_tag == to_underlying(Fields::kChannelPresent))
        {
            err = DataModel::Decode(reader, channelPresent);
        }
        else if (__context_tag == to_underlying(Fields::kPskcPresent))
        {
            err = DataModel::Decode(reader, pskcPresent);
        }
        else if (__context_tag == to_underlying(Fields::kSecurityPolicyPresent))
        {
            err = DataModel::Decode(reader, securityPolicyPresent);
        }
        else if (__context_tag == to_underlying(Fields::kChannelMaskPresent))
        {
            err = DataModel::Decode(reader, channelMaskPresent);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace OperationalDatasetComponents

namespace RouteTableStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kExtAddress), extAddress);
    encoder.Encode(to_underlying(Fields::kRloc16), rloc16);
    encoder.Encode(to_underlying(Fields::kRouterId), routerId);
    encoder.Encode(to_underlying(Fields::kNextHop), nextHop);
    encoder.Encode(to_underlying(Fields::kPathCost), pathCost);
    encoder.Encode(to_underlying(Fields::kLQIIn), LQIIn);
    encoder.Encode(to_underlying(Fields::kLQIOut), LQIOut);
    encoder.Encode(to_underlying(Fields::kAge), age);
    encoder.Encode(to_underlying(Fields::kAllocated), allocated);
    encoder.Encode(to_underlying(Fields::kLinkEstablished), linkEstablished);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kExtAddress))
        {
            err = DataModel::Decode(reader, extAddress);
        }
        else if (__context_tag == to_underlying(Fields::kRloc16))
        {
            err = DataModel::Decode(reader, rloc16);
        }
        else if (__context_tag == to_underlying(Fields::kRouterId))
        {
            err = DataModel::Decode(reader, routerId);
        }
        else if (__context_tag == to_underlying(Fields::kNextHop))
        {
            err = DataModel::Decode(reader, nextHop);
        }
        else if (__context_tag == to_underlying(Fields::kPathCost))
        {
            err = DataModel::Decode(reader, pathCost);
        }
        else if (__context_tag == to_underlying(Fields::kLQIIn))
        {
            err = DataModel::Decode(reader, LQIIn);
        }
        else if (__context_tag == to_underlying(Fields::kLQIOut))
        {
            err = DataModel::Decode(reader, LQIOut);
        }
        else if (__context_tag == to_underlying(Fields::kAge))
        {
            err = DataModel::Decode(reader, age);
        }
        else if (__context_tag == to_underlying(Fields::kAllocated))
        {
            err = DataModel::Decode(reader, allocated);
        }
        else if (__context_tag == to_underlying(Fields::kLinkEstablished))
        {
            err = DataModel::Decode(reader, linkEstablished);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace RouteTableStruct

namespace SecurityPolicy {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kRotationTime), rotationTime);
    encoder.Encode(to_underlying(Fields::kFlags), flags);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kRotationTime))
        {
            err = DataModel::Decode(reader, rotationTime);
        }
        else if (__context_tag == to_underlying(Fields::kFlags))
        {
            err = DataModel::Decode(reader, flags);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace SecurityPolicy
} // namespace Structs

namespace Commands {
namespace ResetCounts {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ResetCounts.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Channel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, channel);
    case Attributes::RoutingRole::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, routingRole);
    case Attributes::NetworkName::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, networkName);
    case Attributes::PanId::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, panId);
    case Attributes::ExtendedPanId::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, extendedPanId);
    case Attributes::MeshLocalPrefix::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, meshLocalPrefix);
    case Attributes::OverrunCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, overrunCount);
    case Attributes::NeighborTable::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, neighborTable);
    case Attributes::RouteTable::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, routeTable);
    case Attributes::PartitionId::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, partitionId);
    case Attributes::Weighting::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, weighting);
    case Attributes::DataVersion::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dataVersion);
    case Attributes::StableDataVersion::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, stableDataVersion);
    case Attributes::LeaderRouterId::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, leaderRouterId);
    case Attributes::DetachedRoleCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, detachedRoleCount);
    case Attributes::ChildRoleCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, childRoleCount);
    case Attributes::RouterRoleCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, routerRoleCount);
    case Attributes::LeaderRoleCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, leaderRoleCount);
    case Attributes::AttachAttemptCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attachAttemptCount);
    case Attributes::PartitionIdChangeCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, partitionIdChangeCount);
    case Attributes::BetterPartitionAttachAttemptCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, betterPartitionAttachAttemptCount);
    case Attributes::ParentChangeCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, parentChangeCount);
    case Attributes::TxTotalCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txTotalCount);
    case Attributes::TxUnicastCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txUnicastCount);
    case Attributes::TxBroadcastCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txBroadcastCount);
    case Attributes::TxAckRequestedCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txAckRequestedCount);
    case Attributes::TxAckedCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txAckedCount);
    case Attributes::TxNoAckRequestedCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txNoAckRequestedCount);
    case Attributes::TxDataCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txDataCount);
    case Attributes::TxDataPollCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txDataPollCount);
    case Attributes::TxBeaconCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txBeaconCount);
    case Attributes::TxBeaconRequestCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txBeaconRequestCount);
    case Attributes::TxOtherCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txOtherCount);
    case Attributes::TxRetryCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txRetryCount);
    case Attributes::TxDirectMaxRetryExpiryCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txDirectMaxRetryExpiryCount);
    case Attributes::TxIndirectMaxRetryExpiryCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txIndirectMaxRetryExpiryCount);
    case Attributes::TxErrCcaCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txErrCcaCount);
    case Attributes::TxErrAbortCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txErrAbortCount);
    case Attributes::TxErrBusyChannelCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txErrBusyChannelCount);
    case Attributes::RxTotalCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxTotalCount);
    case Attributes::RxUnicastCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxUnicastCount);
    case Attributes::RxBroadcastCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxBroadcastCount);
    case Attributes::RxDataCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxDataCount);
    case Attributes::RxDataPollCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxDataPollCount);
    case Attributes::RxBeaconCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxBeaconCount);
    case Attributes::RxBeaconRequestCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxBeaconRequestCount);
    case Attributes::RxOtherCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxOtherCount);
    case Attributes::RxAddressFilteredCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxAddressFilteredCount);
    case Attributes::RxDestAddrFilteredCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxDestAddrFilteredCount);
    case Attributes::RxDuplicatedCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxDuplicatedCount);
    case Attributes::RxErrNoFrameCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxErrNoFrameCount);
    case Attributes::RxErrUnknownNeighborCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxErrUnknownNeighborCount);
    case Attributes::RxErrInvalidSrcAddrCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxErrInvalidSrcAddrCount);
    case Attributes::RxErrSecCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxErrSecCount);
    case Attributes::RxErrFcsCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxErrFcsCount);
    case Attributes::RxErrOtherCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rxErrOtherCount);
    case Attributes::ActiveTimestamp::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeTimestamp);
    case Attributes::PendingTimestamp::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, pendingTimestamp);
    case Attributes::Delay::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, delay);
    case Attributes::SecurityPolicy::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, securityPolicy);
    case Attributes::ChannelPage0Mask::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, channelPage0Mask);
    case Attributes::OperationalDatasetComponents::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, operationalDatasetComponents);
    case Attributes::ActiveNetworkFaultsList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeNetworkFaultsList);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace ConnectionStatus {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kConnectionStatus), connectionStatus));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kConnectionStatus))
        {
            err = DataModel::Decode(reader, connectionStatus);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ConnectionStatus.
namespace NetworkFaultChange {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCurrent), current));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPrevious), previous));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCurrent))
        {
            err = DataModel::Decode(reader, current);
        }
        else if (__context_tag == to_underlying(Fields::kPrevious))
        {
            err = DataModel::Decode(reader, previous);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace NetworkFaultChange.
} // namespace Events

} // namespace ThreadNetworkDiagnostics
namespace WiFiNetworkDiagnostics {

namespace Commands {
namespace ResetCounts {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ResetCounts.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Bssid::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, bssid);
    case Attributes::SecurityType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, securityType);
    case Attributes::WiFiVersion::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, wiFiVersion);
    case Attributes::ChannelNumber::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, channelNumber);
    case Attributes::Rssi::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rssi);
    case Attributes::BeaconLostCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, beaconLostCount);
    case Attributes::BeaconRxCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, beaconRxCount);
    case Attributes::PacketMulticastRxCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, packetMulticastRxCount);
    case Attributes::PacketMulticastTxCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, packetMulticastTxCount);
    case Attributes::PacketUnicastRxCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, packetUnicastRxCount);
    case Attributes::PacketUnicastTxCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, packetUnicastTxCount);
    case Attributes::CurrentMaxRate::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentMaxRate);
    case Attributes::OverrunCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, overrunCount);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace Disconnection {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kReasonCode), reasonCode));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kReasonCode))
        {
            err = DataModel::Decode(reader, reasonCode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Disconnection.
namespace AssociationFailure {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kAssociationFailureCause), associationFailureCause));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kStatus), status));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAssociationFailureCause))
        {
            err = DataModel::Decode(reader, associationFailureCause);
        }
        else if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AssociationFailure.
namespace ConnectionStatus {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kConnectionStatus), connectionStatus));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kConnectionStatus))
        {
            err = DataModel::Decode(reader, connectionStatus);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ConnectionStatus.
} // namespace Events

} // namespace WiFiNetworkDiagnostics
namespace EthernetNetworkDiagnostics {

namespace Commands {
namespace ResetCounts {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ResetCounts.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::PHYRate::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, PHYRate);
    case Attributes::FullDuplex::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, fullDuplex);
    case Attributes::PacketRxCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, packetRxCount);
    case Attributes::PacketTxCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, packetTxCount);
    case Attributes::TxErrCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, txErrCount);
    case Attributes::CollisionCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, collisionCount);
    case Attributes::OverrunCount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, overrunCount);
    case Attributes::CarrierDetect::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, carrierDetect);
    case Attributes::TimeSinceReset::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, timeSinceReset);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace EthernetNetworkDiagnostics
namespace TimeSynchronization {
namespace Structs {

namespace DSTOffsetStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOffset), offset);
    encoder.Encode(to_underlying(Fields::kValidStarting), validStarting);
    encoder.Encode(to_underlying(Fields::kValidUntil), validUntil);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kOffset))
        {
            err = DataModel::Decode(reader, offset);
        }
        else if (__context_tag == to_underlying(Fields::kValidStarting))
        {
            err = DataModel::Decode(reader, validStarting);
        }
        else if (__context_tag == to_underlying(Fields::kValidUntil))
        {
            err = DataModel::Decode(reader, validUntil);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace DSTOffsetStruct

namespace FabricScopedTrustedTimeSourceStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNodeID), nodeID);
    encoder.Encode(to_underlying(Fields::kEndpoint), endpoint);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNodeID))
        {
            err = DataModel::Decode(reader, nodeID);
        }
        else if (__context_tag == to_underlying(Fields::kEndpoint))
        {
            err = DataModel::Decode(reader, endpoint);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace FabricScopedTrustedTimeSourceStruct

namespace TimeZoneStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOffset), offset);
    encoder.Encode(to_underlying(Fields::kValidAt), validAt);
    encoder.Encode(to_underlying(Fields::kName), name);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kOffset))
        {
            err = DataModel::Decode(reader, offset);
        }
        else if (__context_tag == to_underlying(Fields::kValidAt))
        {
            err = DataModel::Decode(reader, validAt);
        }
        else if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace TimeZoneStruct

namespace TrustedTimeSourceStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kFabricIndex), fabricIndex);
    encoder.Encode(to_underlying(Fields::kNodeID), nodeID);
    encoder.Encode(to_underlying(Fields::kEndpoint), endpoint);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else if (__context_tag == to_underlying(Fields::kNodeID))
        {
            err = DataModel::Decode(reader, nodeID);
        }
        else if (__context_tag == to_underlying(Fields::kEndpoint))
        {
            err = DataModel::Decode(reader, endpoint);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace TrustedTimeSourceStruct
} // namespace Structs

namespace Commands {
namespace SetUTCTime {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kUTCTime), UTCTime);
    encoder.Encode(to_underlying(Fields::kGranularity), granularity);
    encoder.Encode(to_underlying(Fields::kTimeSource), timeSource);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kUTCTime))
        {
            err = DataModel::Decode(reader, UTCTime);
        }
        else if (__context_tag == to_underlying(Fields::kGranularity))
        {
            err = DataModel::Decode(reader, granularity);
        }
        else if (__context_tag == to_underlying(Fields::kTimeSource))
        {
            err = DataModel::Decode(reader, timeSource);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetUTCTime.
namespace SetTrustedTimeSource {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTrustedTimeSource), trustedTimeSource);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTrustedTimeSource))
        {
            err = DataModel::Decode(reader, trustedTimeSource);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetTrustedTimeSource.
namespace SetTimeZone {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTimeZone), timeZone);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTimeZone))
        {
            err = DataModel::Decode(reader, timeZone);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetTimeZone.
namespace SetTimeZoneResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kDSTOffsetRequired), DSTOffsetRequired);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDSTOffsetRequired))
        {
            err = DataModel::Decode(reader, DSTOffsetRequired);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetTimeZoneResponse.
namespace SetDSTOffset {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kDSTOffset), DSTOffset);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDSTOffset))
        {
            err = DataModel::Decode(reader, DSTOffset);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetDSTOffset.
namespace SetDefaultNTP {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kDefaultNTP), defaultNTP);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDefaultNTP))
        {
            err = DataModel::Decode(reader, defaultNTP);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetDefaultNTP.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::UTCTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, UTCTime);
    case Attributes::Granularity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, granularity);
    case Attributes::TimeSource::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, timeSource);
    case Attributes::TrustedTimeSource::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, trustedTimeSource);
    case Attributes::DefaultNTP::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, defaultNTP);
    case Attributes::TimeZone::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, timeZone);
    case Attributes::DSTOffset::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, DSTOffset);
    case Attributes::LocalTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, localTime);
    case Attributes::TimeZoneDatabase::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, timeZoneDatabase);
    case Attributes::NTPServerAvailable::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, NTPServerAvailable);
    case Attributes::TimeZoneListMaxSize::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, timeZoneListMaxSize);
    case Attributes::DSTOffsetListMaxSize::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, DSTOffsetListMaxSize);
    case Attributes::SupportsDNSResolve::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportsDNSResolve);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace DSTTableEmpty {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace DSTTableEmpty.
namespace DSTStatus {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kDSTOffsetActive), DSTOffsetActive));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDSTOffsetActive))
        {
            err = DataModel::Decode(reader, DSTOffsetActive);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace DSTStatus.
namespace TimeZoneStatus {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kOffset), offset));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kName), name));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kOffset))
        {
            err = DataModel::Decode(reader, offset);
        }
        else if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TimeZoneStatus.
namespace TimeFailure {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace TimeFailure.
namespace MissingTrustedTimeSource {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace MissingTrustedTimeSource.
} // namespace Events

} // namespace TimeSynchronization
namespace BridgedDeviceBasicInformation {
namespace Structs {

namespace ProductAppearanceStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kFinish), finish);
    encoder.Encode(to_underlying(Fields::kPrimaryColor), primaryColor);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kFinish))
        {
            err = DataModel::Decode(reader, finish);
        }
        else if (__context_tag == to_underlying(Fields::kPrimaryColor))
        {
            err = DataModel::Decode(reader, primaryColor);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ProductAppearanceStruct
} // namespace Structs

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::VendorName::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, vendorName);
    case Attributes::VendorID::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, vendorID);
    case Attributes::ProductName::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, productName);
    case Attributes::NodeLabel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nodeLabel);
    case Attributes::HardwareVersion::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, hardwareVersion);
    case Attributes::HardwareVersionString::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, hardwareVersionString);
    case Attributes::SoftwareVersion::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, softwareVersion);
    case Attributes::SoftwareVersionString::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, softwareVersionString);
    case Attributes::ManufacturingDate::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, manufacturingDate);
    case Attributes::PartNumber::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, partNumber);
    case Attributes::ProductURL::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, productURL);
    case Attributes::ProductLabel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, productLabel);
    case Attributes::SerialNumber::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, serialNumber);
    case Attributes::Reachable::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, reachable);
    case Attributes::UniqueID::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, uniqueID);
    case Attributes::ProductAppearance::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, productAppearance);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace StartUp {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSoftwareVersion), softwareVersion));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSoftwareVersion))
        {
            err = DataModel::Decode(reader, softwareVersion);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StartUp.
namespace ShutDown {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ShutDown.
namespace Leave {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Leave.
namespace ReachableChanged {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kReachableNewValue), reachableNewValue));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kReachableNewValue))
        {
            err = DataModel::Decode(reader, reachableNewValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ReachableChanged.
} // namespace Events

} // namespace BridgedDeviceBasicInformation
namespace Switch {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::NumberOfPositions::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfPositions);
    case Attributes::CurrentPosition::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentPosition);
    case Attributes::MultiPressMax::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, multiPressMax);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace SwitchLatched {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kNewPosition), newPosition));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNewPosition))
        {
            err = DataModel::Decode(reader, newPosition);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SwitchLatched.
namespace InitialPress {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kNewPosition), newPosition));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNewPosition))
        {
            err = DataModel::Decode(reader, newPosition);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace InitialPress.
namespace LongPress {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kNewPosition), newPosition));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNewPosition))
        {
            err = DataModel::Decode(reader, newPosition);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace LongPress.
namespace ShortRelease {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPreviousPosition), previousPosition));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPreviousPosition))
        {
            err = DataModel::Decode(reader, previousPosition);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ShortRelease.
namespace LongRelease {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPreviousPosition), previousPosition));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPreviousPosition))
        {
            err = DataModel::Decode(reader, previousPosition);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace LongRelease.
namespace MultiPressOngoing {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kNewPosition), newPosition));
    ReturnErrorOnFailure(
        DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCurrentNumberOfPressesCounted), currentNumberOfPressesCounted));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNewPosition))
        {
            err = DataModel::Decode(reader, newPosition);
        }
        else if (__context_tag == to_underlying(Fields::kCurrentNumberOfPressesCounted))
        {
            err = DataModel::Decode(reader, currentNumberOfPressesCounted);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MultiPressOngoing.
namespace MultiPressComplete {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPreviousPosition), previousPosition));
    ReturnErrorOnFailure(
        DataModel::Encode(aWriter, TLV::ContextTag(Fields::kTotalNumberOfPressesCounted), totalNumberOfPressesCounted));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPreviousPosition))
        {
            err = DataModel::Decode(reader, previousPosition);
        }
        else if (__context_tag == to_underlying(Fields::kTotalNumberOfPressesCounted))
        {
            err = DataModel::Decode(reader, totalNumberOfPressesCounted);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MultiPressComplete.
} // namespace Events

} // namespace Switch
namespace AdministratorCommissioning {

namespace Commands {
namespace OpenCommissioningWindow {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCommissioningTimeout), commissioningTimeout);
    encoder.Encode(to_underlying(Fields::kPAKEPasscodeVerifier), PAKEPasscodeVerifier);
    encoder.Encode(to_underlying(Fields::kDiscriminator), discriminator);
    encoder.Encode(to_underlying(Fields::kIterations), iterations);
    encoder.Encode(to_underlying(Fields::kSalt), salt);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCommissioningTimeout))
        {
            err = DataModel::Decode(reader, commissioningTimeout);
        }
        else if (__context_tag == to_underlying(Fields::kPAKEPasscodeVerifier))
        {
            err = DataModel::Decode(reader, PAKEPasscodeVerifier);
        }
        else if (__context_tag == to_underlying(Fields::kDiscriminator))
        {
            err = DataModel::Decode(reader, discriminator);
        }
        else if (__context_tag == to_underlying(Fields::kIterations))
        {
            err = DataModel::Decode(reader, iterations);
        }
        else if (__context_tag == to_underlying(Fields::kSalt))
        {
            err = DataModel::Decode(reader, salt);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace OpenCommissioningWindow.
namespace OpenBasicCommissioningWindow {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCommissioningTimeout), commissioningTimeout);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCommissioningTimeout))
        {
            err = DataModel::Decode(reader, commissioningTimeout);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace OpenBasicCommissioningWindow.
namespace RevokeCommissioning {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace RevokeCommissioning.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::WindowStatus::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, windowStatus);
    case Attributes::AdminFabricIndex::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, adminFabricIndex);
    case Attributes::AdminVendorId::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, adminVendorId);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace AdministratorCommissioning
namespace OperationalCredentials {
namespace Structs {

namespace FabricDescriptorStruct {
CHIP_ERROR Type::EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    return DoEncode(aWriter, aTag, NullOptional);
}

CHIP_ERROR Type::EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const
{
    return DoEncode(aWriter, aTag, MakeOptional(aAccessingFabricIndex));
}

CHIP_ERROR Type::DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const
{

    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };

    encoder.Encode(to_underlying(Fields::kRootPublicKey), rootPublicKey);
    encoder.Encode(to_underlying(Fields::kVendorID), vendorID);
    encoder.Encode(to_underlying(Fields::kFabricID), fabricID);
    encoder.Encode(to_underlying(Fields::kNodeID), nodeID);
    encoder.Encode(to_underlying(Fields::kLabel), label);
    if (aAccessingFabricIndex.HasValue())
    {
        encoder.Encode(to_underlying(Fields::kFabricIndex), fabricIndex);
    }

    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kRootPublicKey))
        {
            err = DataModel::Decode(reader, rootPublicKey);
        }
        else if (__context_tag == to_underlying(Fields::kVendorID))
        {
            err = DataModel::Decode(reader, vendorID);
        }
        else if (__context_tag == to_underlying(Fields::kFabricID))
        {
            err = DataModel::Decode(reader, fabricID);
        }
        else if (__context_tag == to_underlying(Fields::kNodeID))
        {
            err = DataModel::Decode(reader, nodeID);
        }
        else if (__context_tag == to_underlying(Fields::kLabel))
        {
            err = DataModel::Decode(reader, label);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace FabricDescriptorStruct

namespace NOCStruct {
CHIP_ERROR Type::EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    return DoEncode(aWriter, aTag, NullOptional);
}

CHIP_ERROR Type::EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const
{
    return DoEncode(aWriter, aTag, MakeOptional(aAccessingFabricIndex));
}

CHIP_ERROR Type::DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const
{
    bool includeSensitive = !aAccessingFabricIndex.HasValue() || (aAccessingFabricIndex.Value() == fabricIndex);

    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };

    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kNoc), noc);
    }
    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kIcac), icac);
    }
    if (aAccessingFabricIndex.HasValue())
    {
        encoder.Encode(to_underlying(Fields::kFabricIndex), fabricIndex);
    }

    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNoc))
        {
            err = DataModel::Decode(reader, noc);
        }
        else if (__context_tag == to_underlying(Fields::kIcac))
        {
            err = DataModel::Decode(reader, icac);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace NOCStruct
} // namespace Structs

namespace Commands {
namespace AttestationRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kAttestationNonce), attestationNonce);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAttestationNonce))
        {
            err = DataModel::Decode(reader, attestationNonce);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AttestationRequest.
namespace AttestationResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kAttestationElements), attestationElements);
    encoder.Encode(to_underlying(Fields::kAttestationSignature), attestationSignature);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAttestationElements))
        {
            err = DataModel::Decode(reader, attestationElements);
        }
        else if (__context_tag == to_underlying(Fields::kAttestationSignature))
        {
            err = DataModel::Decode(reader, attestationSignature);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AttestationResponse.
namespace CertificateChainRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCertificateType), certificateType);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCertificateType))
        {
            err = DataModel::Decode(reader, certificateType);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace CertificateChainRequest.
namespace CertificateChainResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCertificate), certificate);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCertificate))
        {
            err = DataModel::Decode(reader, certificate);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace CertificateChainResponse.
namespace CSRRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCSRNonce), CSRNonce);
    encoder.Encode(to_underlying(Fields::kIsForUpdateNOC), isForUpdateNOC);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCSRNonce))
        {
            err = DataModel::Decode(reader, CSRNonce);
        }
        else if (__context_tag == to_underlying(Fields::kIsForUpdateNOC))
        {
            err = DataModel::Decode(reader, isForUpdateNOC);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace CSRRequest.
namespace CSRResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNOCSRElements), NOCSRElements);
    encoder.Encode(to_underlying(Fields::kAttestationSignature), attestationSignature);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNOCSRElements))
        {
            err = DataModel::Decode(reader, NOCSRElements);
        }
        else if (__context_tag == to_underlying(Fields::kAttestationSignature))
        {
            err = DataModel::Decode(reader, attestationSignature);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace CSRResponse.
namespace AddNOC {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNOCValue), NOCValue);
    encoder.Encode(to_underlying(Fields::kICACValue), ICACValue);
    encoder.Encode(to_underlying(Fields::kIPKValue), IPKValue);
    encoder.Encode(to_underlying(Fields::kCaseAdminSubject), caseAdminSubject);
    encoder.Encode(to_underlying(Fields::kAdminVendorId), adminVendorId);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNOCValue))
        {
            err = DataModel::Decode(reader, NOCValue);
        }
        else if (__context_tag == to_underlying(Fields::kICACValue))
        {
            err = DataModel::Decode(reader, ICACValue);
        }
        else if (__context_tag == to_underlying(Fields::kIPKValue))
        {
            err = DataModel::Decode(reader, IPKValue);
        }
        else if (__context_tag == to_underlying(Fields::kCaseAdminSubject))
        {
            err = DataModel::Decode(reader, caseAdminSubject);
        }
        else if (__context_tag == to_underlying(Fields::kAdminVendorId))
        {
            err = DataModel::Decode(reader, adminVendorId);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AddNOC.
namespace UpdateNOC {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNOCValue), NOCValue);
    encoder.Encode(to_underlying(Fields::kICACValue), ICACValue);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNOCValue))
        {
            err = DataModel::Decode(reader, NOCValue);
        }
        else if (__context_tag == to_underlying(Fields::kICACValue))
        {
            err = DataModel::Decode(reader, ICACValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace UpdateNOC.
namespace NOCResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatusCode), statusCode);
    encoder.Encode(to_underlying(Fields::kFabricIndex), fabricIndex);
    encoder.Encode(to_underlying(Fields::kDebugText), debugText);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatusCode))
        {
            err = DataModel::Decode(reader, statusCode);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else if (__context_tag == to_underlying(Fields::kDebugText))
        {
            err = DataModel::Decode(reader, debugText);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace NOCResponse.
namespace UpdateFabricLabel {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLabel), label);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLabel))
        {
            err = DataModel::Decode(reader, label);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace UpdateFabricLabel.
namespace RemoveFabric {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kFabricIndex), fabricIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RemoveFabric.
namespace AddTrustedRootCertificate {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kRootCACertificate), rootCACertificate);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kRootCACertificate))
        {
            err = DataModel::Decode(reader, rootCACertificate);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AddTrustedRootCertificate.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::NOCs::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, NOCs);
    case Attributes::Fabrics::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, fabrics);
    case Attributes::SupportedFabrics::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedFabrics);
    case Attributes::CommissionedFabrics::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, commissionedFabrics);
    case Attributes::TrustedRootCertificates::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, trustedRootCertificates);
    case Attributes::CurrentFabricIndex::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentFabricIndex);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace OperationalCredentials
namespace GroupKeyManagement {
namespace Structs {

namespace GroupInfoMapStruct {
CHIP_ERROR Type::EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    return DoEncode(aWriter, aTag, NullOptional);
}

CHIP_ERROR Type::EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const
{
    return DoEncode(aWriter, aTag, MakeOptional(aAccessingFabricIndex));
}

CHIP_ERROR Type::DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const
{

    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };

    encoder.Encode(to_underlying(Fields::kGroupId), groupId);
    encoder.Encode(to_underlying(Fields::kEndpoints), endpoints);
    encoder.Encode(to_underlying(Fields::kGroupName), groupName);
    if (aAccessingFabricIndex.HasValue())
    {
        encoder.Encode(to_underlying(Fields::kFabricIndex), fabricIndex);
    }

    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupId))
        {
            err = DataModel::Decode(reader, groupId);
        }
        else if (__context_tag == to_underlying(Fields::kEndpoints))
        {
            err = DataModel::Decode(reader, endpoints);
        }
        else if (__context_tag == to_underlying(Fields::kGroupName))
        {
            err = DataModel::Decode(reader, groupName);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace GroupInfoMapStruct

namespace GroupKeyMapStruct {
CHIP_ERROR Type::EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    return DoEncode(aWriter, aTag, NullOptional);
}

CHIP_ERROR Type::EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const
{
    return DoEncode(aWriter, aTag, MakeOptional(aAccessingFabricIndex));
}

CHIP_ERROR Type::DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const
{

    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };

    encoder.Encode(to_underlying(Fields::kGroupId), groupId);
    encoder.Encode(to_underlying(Fields::kGroupKeySetID), groupKeySetID);
    if (aAccessingFabricIndex.HasValue())
    {
        encoder.Encode(to_underlying(Fields::kFabricIndex), fabricIndex);
    }

    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupId))
        {
            err = DataModel::Decode(reader, groupId);
        }
        else if (__context_tag == to_underlying(Fields::kGroupKeySetID))
        {
            err = DataModel::Decode(reader, groupKeySetID);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace GroupKeyMapStruct

namespace GroupKeySetStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupKeySetID), groupKeySetID);
    encoder.Encode(to_underlying(Fields::kGroupKeySecurityPolicy), groupKeySecurityPolicy);
    encoder.Encode(to_underlying(Fields::kEpochKey0), epochKey0);
    encoder.Encode(to_underlying(Fields::kEpochStartTime0), epochStartTime0);
    encoder.Encode(to_underlying(Fields::kEpochKey1), epochKey1);
    encoder.Encode(to_underlying(Fields::kEpochStartTime1), epochStartTime1);
    encoder.Encode(to_underlying(Fields::kEpochKey2), epochKey2);
    encoder.Encode(to_underlying(Fields::kEpochStartTime2), epochStartTime2);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupKeySetID))
        {
            err = DataModel::Decode(reader, groupKeySetID);
        }
        else if (__context_tag == to_underlying(Fields::kGroupKeySecurityPolicy))
        {
            err = DataModel::Decode(reader, groupKeySecurityPolicy);
        }
        else if (__context_tag == to_underlying(Fields::kEpochKey0))
        {
            err = DataModel::Decode(reader, epochKey0);
        }
        else if (__context_tag == to_underlying(Fields::kEpochStartTime0))
        {
            err = DataModel::Decode(reader, epochStartTime0);
        }
        else if (__context_tag == to_underlying(Fields::kEpochKey1))
        {
            err = DataModel::Decode(reader, epochKey1);
        }
        else if (__context_tag == to_underlying(Fields::kEpochStartTime1))
        {
            err = DataModel::Decode(reader, epochStartTime1);
        }
        else if (__context_tag == to_underlying(Fields::kEpochKey2))
        {
            err = DataModel::Decode(reader, epochKey2);
        }
        else if (__context_tag == to_underlying(Fields::kEpochStartTime2))
        {
            err = DataModel::Decode(reader, epochStartTime2);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace GroupKeySetStruct
} // namespace Structs

namespace Commands {
namespace KeySetWrite {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupKeySet), groupKeySet);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupKeySet))
        {
            err = DataModel::Decode(reader, groupKeySet);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace KeySetWrite.
namespace KeySetRead {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupKeySetID), groupKeySetID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupKeySetID))
        {
            err = DataModel::Decode(reader, groupKeySetID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace KeySetRead.
namespace KeySetReadResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupKeySet), groupKeySet);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupKeySet))
        {
            err = DataModel::Decode(reader, groupKeySet);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace KeySetReadResponse.
namespace KeySetRemove {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupKeySetID), groupKeySetID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupKeySetID))
        {
            err = DataModel::Decode(reader, groupKeySetID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace KeySetRemove.
namespace KeySetReadAllIndices {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace KeySetReadAllIndices.
namespace KeySetReadAllIndicesResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupKeySetIDs), groupKeySetIDs);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupKeySetIDs))
        {
            err = DataModel::Decode(reader, groupKeySetIDs);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace KeySetReadAllIndicesResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::GroupKeyMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, groupKeyMap);
    case Attributes::GroupTable::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, groupTable);
    case Attributes::MaxGroupsPerFabric::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxGroupsPerFabric);
    case Attributes::MaxGroupKeysPerFabric::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxGroupKeysPerFabric);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace GroupKeyManagement
namespace FixedLabel {
namespace Structs {} // namespace Structs

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::LabelList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, labelList);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace FixedLabel
namespace UserLabel {
namespace Structs {} // namespace Structs

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::LabelList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, labelList);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace UserLabel
namespace ProxyConfiguration {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace ProxyConfiguration
namespace ProxyDiscovery {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace ProxyDiscovery
namespace ProxyValid {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace ProxyValid
namespace BooleanState {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::StateValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, stateValue);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace StateChange {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kStateValue), stateValue));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStateValue))
        {
            err = DataModel::Decode(reader, stateValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StateChange.
} // namespace Events

} // namespace BooleanState
namespace IcdManagement {
namespace Structs {

namespace MonitoringRegistrationStruct {
CHIP_ERROR Type::EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    return DoEncode(aWriter, aTag, NullOptional);
}

CHIP_ERROR Type::EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const
{
    return DoEncode(aWriter, aTag, MakeOptional(aAccessingFabricIndex));
}

CHIP_ERROR Type::DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const
{
    bool includeSensitive = !aAccessingFabricIndex.HasValue() || (aAccessingFabricIndex.Value() == fabricIndex);

    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };

    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kCheckInNodeID), checkInNodeID);
    }
    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kMonitoredSubject), monitoredSubject);
    }
    if (aAccessingFabricIndex.HasValue())
    {
        encoder.Encode(to_underlying(Fields::kFabricIndex), fabricIndex);
    }

    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCheckInNodeID))
        {
            err = DataModel::Decode(reader, checkInNodeID);
        }
        else if (__context_tag == to_underlying(Fields::kMonitoredSubject))
        {
            err = DataModel::Decode(reader, monitoredSubject);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace MonitoringRegistrationStruct
} // namespace Structs

namespace Commands {
namespace RegisterClient {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCheckInNodeID), checkInNodeID);
    encoder.Encode(to_underlying(Fields::kMonitoredSubject), monitoredSubject);
    encoder.Encode(to_underlying(Fields::kKey), key);
    encoder.Encode(to_underlying(Fields::kVerificationKey), verificationKey);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCheckInNodeID))
        {
            err = DataModel::Decode(reader, checkInNodeID);
        }
        else if (__context_tag == to_underlying(Fields::kMonitoredSubject))
        {
            err = DataModel::Decode(reader, monitoredSubject);
        }
        else if (__context_tag == to_underlying(Fields::kKey))
        {
            err = DataModel::Decode(reader, key);
        }
        else if (__context_tag == to_underlying(Fields::kVerificationKey))
        {
            err = DataModel::Decode(reader, verificationKey);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RegisterClient.
namespace RegisterClientResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kICDCounter), ICDCounter);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kICDCounter))
        {
            err = DataModel::Decode(reader, ICDCounter);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RegisterClientResponse.
namespace UnregisterClient {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCheckInNodeID), checkInNodeID);
    encoder.Encode(to_underlying(Fields::kVerificationKey), verificationKey);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCheckInNodeID))
        {
            err = DataModel::Decode(reader, checkInNodeID);
        }
        else if (__context_tag == to_underlying(Fields::kVerificationKey))
        {
            err = DataModel::Decode(reader, verificationKey);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace UnregisterClient.
namespace StayActiveRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStayActiveDuration), stayActiveDuration);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStayActiveDuration))
        {
            err = DataModel::Decode(reader, stayActiveDuration);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StayActiveRequest.
namespace StayActiveResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPromisedActiveDuration), promisedActiveDuration);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPromisedActiveDuration))
        {
            err = DataModel::Decode(reader, promisedActiveDuration);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StayActiveResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::IdleModeDuration::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, idleModeDuration);
    case Attributes::ActiveModeDuration::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeModeDuration);
    case Attributes::ActiveModeThreshold::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeModeThreshold);
    case Attributes::RegisteredClients::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, registeredClients);
    case Attributes::ICDCounter::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ICDCounter);
    case Attributes::ClientsSupportedPerFabric::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clientsSupportedPerFabric);
    case Attributes::UserActiveModeTriggerHint::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, userActiveModeTriggerHint);
    case Attributes::UserActiveModeTriggerInstruction::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, userActiveModeTriggerInstruction);
    case Attributes::OperatingMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, operatingMode);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace IcdManagement
namespace Timer {

namespace Commands {
namespace SetTimer {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNewTime), newTime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNewTime))
        {
            err = DataModel::Decode(reader, newTime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetTimer.
namespace ResetTimer {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ResetTimer.
namespace AddTime {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kAdditionalTime), additionalTime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAdditionalTime))
        {
            err = DataModel::Decode(reader, additionalTime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AddTime.
namespace ReduceTime {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTimeReduction), timeReduction);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTimeReduction))
        {
            err = DataModel::Decode(reader, timeReduction);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ReduceTime.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::SetTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, setTime);
    case Attributes::TimeRemaining::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, timeRemaining);
    case Attributes::TimerState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, timerState);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace Timer
namespace OvenCavityOperationalState {
namespace Structs {} // namespace Structs

namespace Commands {
namespace Pause {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Pause.
namespace Stop {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Stop.
namespace Start {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Start.
namespace Resume {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Resume.
namespace OperationalCommandResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCommandResponseState), commandResponseState);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCommandResponseState))
        {
            err = DataModel::Decode(reader, commandResponseState);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace OperationalCommandResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::PhaseList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, phaseList);
    case Attributes::CurrentPhase::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentPhase);
    case Attributes::CountdownTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, countdownTime);
    case Attributes::OperationalStateList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, operationalStateList);
    case Attributes::OperationalState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, operationalState);
    case Attributes::OperationalError::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, operationalError);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace OperationalError {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kErrorState), errorState));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kErrorState))
        {
            err = DataModel::Decode(reader, errorState);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace OperationalError.
namespace OperationCompletion {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCompletionErrorCode), completionErrorCode));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kTotalOperationalTime), totalOperationalTime));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPausedTime), pausedTime));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCompletionErrorCode))
        {
            err = DataModel::Decode(reader, completionErrorCode);
        }
        else if (__context_tag == to_underlying(Fields::kTotalOperationalTime))
        {
            err = DataModel::Decode(reader, totalOperationalTime);
        }
        else if (__context_tag == to_underlying(Fields::kPausedTime))
        {
            err = DataModel::Decode(reader, pausedTime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace OperationCompletion.
} // namespace Events

} // namespace OvenCavityOperationalState
namespace OvenMode {
namespace Structs {} // namespace Structs

namespace Commands {
namespace ChangeToMode {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNewMode), newMode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNewMode))
        {
            err = DataModel::Decode(reader, newMode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToMode.
namespace ChangeToModeResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kStatusText), statusText);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kStatusText))
        {
            err = DataModel::Decode(reader, statusText);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToModeResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::SupportedModes::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedModes);
    case Attributes::CurrentMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentMode);
    case Attributes::StartUpMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, startUpMode);
    case Attributes::OnMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, onMode);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace OvenMode
namespace LaundryDryerControls {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::SupportedDrynessLevels::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedDrynessLevels);
    case Attributes::SelectedDrynessLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, selectedDrynessLevel);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace LaundryDryerControls
namespace ModeSelect {
namespace Structs {

namespace SemanticTagStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMfgCode), mfgCode);
    encoder.Encode(to_underlying(Fields::kValue), value);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMfgCode))
        {
            err = DataModel::Decode(reader, mfgCode);
        }
        else if (__context_tag == to_underlying(Fields::kValue))
        {
            err = DataModel::Decode(reader, value);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace SemanticTagStruct

namespace ModeOptionStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLabel), label);
    encoder.Encode(to_underlying(Fields::kMode), mode);
    encoder.Encode(to_underlying(Fields::kSemanticTags), semanticTags);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLabel))
        {
            err = DataModel::Decode(reader, label);
        }
        else if (__context_tag == to_underlying(Fields::kMode))
        {
            err = DataModel::Decode(reader, mode);
        }
        else if (__context_tag == to_underlying(Fields::kSemanticTags))
        {
            err = DataModel::Decode(reader, semanticTags);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ModeOptionStruct
} // namespace Structs

namespace Commands {
namespace ChangeToMode {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNewMode), newMode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNewMode))
        {
            err = DataModel::Decode(reader, newMode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToMode.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Description::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, description);
    case Attributes::StandardNamespace::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, standardNamespace);
    case Attributes::SupportedModes::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedModes);
    case Attributes::CurrentMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentMode);
    case Attributes::StartUpMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, startUpMode);
    case Attributes::OnMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, onMode);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace ModeSelect
namespace LaundryWasherMode {
namespace Structs {} // namespace Structs

namespace Commands {
namespace ChangeToMode {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNewMode), newMode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNewMode))
        {
            err = DataModel::Decode(reader, newMode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToMode.
namespace ChangeToModeResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kStatusText), statusText);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kStatusText))
        {
            err = DataModel::Decode(reader, statusText);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToModeResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::SupportedModes::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedModes);
    case Attributes::CurrentMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentMode);
    case Attributes::StartUpMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, startUpMode);
    case Attributes::OnMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, onMode);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace LaundryWasherMode
namespace RefrigeratorAndTemperatureControlledCabinetMode {
namespace Structs {} // namespace Structs

namespace Commands {
namespace ChangeToMode {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNewMode), newMode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNewMode))
        {
            err = DataModel::Decode(reader, newMode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToMode.
namespace ChangeToModeResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kStatusText), statusText);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kStatusText))
        {
            err = DataModel::Decode(reader, statusText);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToModeResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::SupportedModes::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedModes);
    case Attributes::CurrentMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentMode);
    case Attributes::StartUpMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, startUpMode);
    case Attributes::OnMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, onMode);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace RefrigeratorAndTemperatureControlledCabinetMode
namespace LaundryWasherControls {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::SpinSpeeds::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, spinSpeeds);
    case Attributes::SpinSpeedCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, spinSpeedCurrent);
    case Attributes::NumberOfRinses::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfRinses);
    case Attributes::SupportedRinses::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedRinses);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace LaundryWasherControls
namespace RvcRunMode {
namespace Structs {} // namespace Structs

namespace Commands {
namespace ChangeToMode {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNewMode), newMode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNewMode))
        {
            err = DataModel::Decode(reader, newMode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToMode.
namespace ChangeToModeResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kStatusText), statusText);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kStatusText))
        {
            err = DataModel::Decode(reader, statusText);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToModeResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::SupportedModes::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedModes);
    case Attributes::CurrentMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentMode);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace RvcRunMode
namespace RvcCleanMode {
namespace Structs {} // namespace Structs

namespace Commands {
namespace ChangeToMode {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNewMode), newMode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNewMode))
        {
            err = DataModel::Decode(reader, newMode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToMode.
namespace ChangeToModeResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kStatusText), statusText);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kStatusText))
        {
            err = DataModel::Decode(reader, statusText);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToModeResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::SupportedModes::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedModes);
    case Attributes::CurrentMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentMode);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace RvcCleanMode
namespace TemperatureControl {

namespace Commands {
namespace SetTemperature {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTargetTemperature), targetTemperature);
    encoder.Encode(to_underlying(Fields::kTargetTemperatureLevel), targetTemperatureLevel);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTargetTemperature))
        {
            err = DataModel::Decode(reader, targetTemperature);
        }
        else if (__context_tag == to_underlying(Fields::kTargetTemperatureLevel))
        {
            err = DataModel::Decode(reader, targetTemperatureLevel);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetTemperature.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::TemperatureSetpoint::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, temperatureSetpoint);
    case Attributes::MinTemperature::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minTemperature);
    case Attributes::MaxTemperature::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxTemperature);
    case Attributes::Step::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, step);
    case Attributes::SelectedTemperatureLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, selectedTemperatureLevel);
    case Attributes::SupportedTemperatureLevels::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedTemperatureLevels);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace TemperatureControl
namespace RefrigeratorAlarm {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Mask::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, mask);
    case Attributes::State::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, state);
    case Attributes::Supported::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supported);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace Notify {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kActive), active));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kInactive), inactive));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kState), state));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kMask), mask));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActive))
        {
            err = DataModel::Decode(reader, active);
        }
        else if (__context_tag == to_underlying(Fields::kInactive))
        {
            err = DataModel::Decode(reader, inactive);
        }
        else if (__context_tag == to_underlying(Fields::kState))
        {
            err = DataModel::Decode(reader, state);
        }
        else if (__context_tag == to_underlying(Fields::kMask))
        {
            err = DataModel::Decode(reader, mask);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Notify.
} // namespace Events

} // namespace RefrigeratorAlarm
namespace DishwasherMode {
namespace Structs {} // namespace Structs

namespace Commands {
namespace ChangeToMode {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNewMode), newMode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNewMode))
        {
            err = DataModel::Decode(reader, newMode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToMode.
namespace ChangeToModeResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kStatusText), statusText);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kStatusText))
        {
            err = DataModel::Decode(reader, statusText);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToModeResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::SupportedModes::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedModes);
    case Attributes::CurrentMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentMode);
    case Attributes::StartUpMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, startUpMode);
    case Attributes::OnMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, onMode);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace DishwasherMode
namespace AirQuality {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::AirQuality::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, airQuality);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace AirQuality
namespace SmokeCoAlarm {

namespace Commands {
namespace SelfTestRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace SelfTestRequest.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::ExpressedState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, expressedState);
    case Attributes::SmokeState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, smokeState);
    case Attributes::COState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, COState);
    case Attributes::BatteryAlert::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batteryAlert);
    case Attributes::DeviceMuted::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, deviceMuted);
    case Attributes::TestInProgress::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, testInProgress);
    case Attributes::HardwareFaultAlert::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, hardwareFaultAlert);
    case Attributes::EndOfServiceAlert::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, endOfServiceAlert);
    case Attributes::InterconnectSmokeAlarm::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, interconnectSmokeAlarm);
    case Attributes::InterconnectCOAlarm::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, interconnectCOAlarm);
    case Attributes::ContaminationState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, contaminationState);
    case Attributes::SmokeSensitivityLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, smokeSensitivityLevel);
    case Attributes::ExpiryDate::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, expiryDate);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace SmokeAlarm {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kAlarmSeverityLevel), alarmSeverityLevel));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAlarmSeverityLevel))
        {
            err = DataModel::Decode(reader, alarmSeverityLevel);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SmokeAlarm.
namespace COAlarm {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kAlarmSeverityLevel), alarmSeverityLevel));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAlarmSeverityLevel))
        {
            err = DataModel::Decode(reader, alarmSeverityLevel);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace COAlarm.
namespace LowBattery {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kAlarmSeverityLevel), alarmSeverityLevel));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAlarmSeverityLevel))
        {
            err = DataModel::Decode(reader, alarmSeverityLevel);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace LowBattery.
namespace HardwareFault {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace HardwareFault.
namespace EndOfService {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace EndOfService.
namespace SelfTestComplete {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace SelfTestComplete.
namespace AlarmMuted {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace AlarmMuted.
namespace MuteEnded {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace MuteEnded.
namespace InterconnectSmokeAlarm {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kAlarmSeverityLevel), alarmSeverityLevel));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAlarmSeverityLevel))
        {
            err = DataModel::Decode(reader, alarmSeverityLevel);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace InterconnectSmokeAlarm.
namespace InterconnectCOAlarm {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kAlarmSeverityLevel), alarmSeverityLevel));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAlarmSeverityLevel))
        {
            err = DataModel::Decode(reader, alarmSeverityLevel);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace InterconnectCOAlarm.
namespace AllClear {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace AllClear.
} // namespace Events

} // namespace SmokeCoAlarm
namespace DishwasherAlarm {

namespace Commands {
namespace Reset {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kAlarms), alarms);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAlarms))
        {
            err = DataModel::Decode(reader, alarms);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Reset.
namespace ModifyEnabledAlarms {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMask), mask);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMask))
        {
            err = DataModel::Decode(reader, mask);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ModifyEnabledAlarms.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Mask::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, mask);
    case Attributes::Latch::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, latch);
    case Attributes::State::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, state);
    case Attributes::Supported::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supported);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace Notify {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kActive), active));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kInactive), inactive));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kState), state));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kMask), mask));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kActive))
        {
            err = DataModel::Decode(reader, active);
        }
        else if (__context_tag == to_underlying(Fields::kInactive))
        {
            err = DataModel::Decode(reader, inactive);
        }
        else if (__context_tag == to_underlying(Fields::kState))
        {
            err = DataModel::Decode(reader, state);
        }
        else if (__context_tag == to_underlying(Fields::kMask))
        {
            err = DataModel::Decode(reader, mask);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Notify.
} // namespace Events

} // namespace DishwasherAlarm
namespace MicrowaveOvenMode {
namespace Structs {} // namespace Structs

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::SupportedModes::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedModes);
    case Attributes::CurrentMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentMode);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace MicrowaveOvenMode
namespace MicrowaveOvenControl {

namespace Commands {
namespace SetCookingParameters {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCookMode), cookMode);
    encoder.Encode(to_underlying(Fields::kCookTime), cookTime);
    encoder.Encode(to_underlying(Fields::kPowerSetting), powerSetting);
    encoder.Encode(to_underlying(Fields::kWattSettingIndex), wattSettingIndex);
    encoder.Encode(to_underlying(Fields::kStartAfterSetting), startAfterSetting);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCookMode))
        {
            err = DataModel::Decode(reader, cookMode);
        }
        else if (__context_tag == to_underlying(Fields::kCookTime))
        {
            err = DataModel::Decode(reader, cookTime);
        }
        else if (__context_tag == to_underlying(Fields::kPowerSetting))
        {
            err = DataModel::Decode(reader, powerSetting);
        }
        else if (__context_tag == to_underlying(Fields::kWattSettingIndex))
        {
            err = DataModel::Decode(reader, wattSettingIndex);
        }
        else if (__context_tag == to_underlying(Fields::kStartAfterSetting))
        {
            err = DataModel::Decode(reader, startAfterSetting);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetCookingParameters.
namespace AddMoreTime {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTimeToAdd), timeToAdd);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTimeToAdd))
        {
            err = DataModel::Decode(reader, timeToAdd);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AddMoreTime.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::CookTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, cookTime);
    case Attributes::MaxCookTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxCookTime);
    case Attributes::PowerSetting::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, powerSetting);
    case Attributes::MinPower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minPower);
    case Attributes::MaxPower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxPower);
    case Attributes::PowerStep::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, powerStep);
    case Attributes::SupportedWatts::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedWatts);
    case Attributes::SelectedWattIndex::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, selectedWattIndex);
    case Attributes::WattRating::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, wattRating);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace MicrowaveOvenControl
namespace OperationalState {
namespace Structs {} // namespace Structs

namespace Commands {
namespace Pause {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Pause.
namespace Stop {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Stop.
namespace Start {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Start.
namespace Resume {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Resume.
namespace OperationalCommandResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCommandResponseState), commandResponseState);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCommandResponseState))
        {
            err = DataModel::Decode(reader, commandResponseState);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace OperationalCommandResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::PhaseList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, phaseList);
    case Attributes::CurrentPhase::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentPhase);
    case Attributes::CountdownTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, countdownTime);
    case Attributes::OperationalStateList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, operationalStateList);
    case Attributes::OperationalState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, operationalState);
    case Attributes::OperationalError::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, operationalError);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace OperationalError {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kErrorState), errorState));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kErrorState))
        {
            err = DataModel::Decode(reader, errorState);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace OperationalError.
namespace OperationCompletion {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCompletionErrorCode), completionErrorCode));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kTotalOperationalTime), totalOperationalTime));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPausedTime), pausedTime));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCompletionErrorCode))
        {
            err = DataModel::Decode(reader, completionErrorCode);
        }
        else if (__context_tag == to_underlying(Fields::kTotalOperationalTime))
        {
            err = DataModel::Decode(reader, totalOperationalTime);
        }
        else if (__context_tag == to_underlying(Fields::kPausedTime))
        {
            err = DataModel::Decode(reader, pausedTime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace OperationCompletion.
} // namespace Events

} // namespace OperationalState
namespace RvcOperationalState {
namespace Structs {} // namespace Structs

namespace Commands {
namespace Pause {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Pause.
namespace Resume {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Resume.
namespace OperationalCommandResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCommandResponseState), commandResponseState);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCommandResponseState))
        {
            err = DataModel::Decode(reader, commandResponseState);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace OperationalCommandResponse.
namespace GoHome {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace GoHome.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::PhaseList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, phaseList);
    case Attributes::CurrentPhase::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentPhase);
    case Attributes::CountdownTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, countdownTime);
    case Attributes::OperationalStateList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, operationalStateList);
    case Attributes::OperationalState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, operationalState);
    case Attributes::OperationalError::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, operationalError);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace OperationalError {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kErrorState), errorState));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kErrorState))
        {
            err = DataModel::Decode(reader, errorState);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace OperationalError.
namespace OperationCompletion {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCompletionErrorCode), completionErrorCode));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kTotalOperationalTime), totalOperationalTime));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPausedTime), pausedTime));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCompletionErrorCode))
        {
            err = DataModel::Decode(reader, completionErrorCode);
        }
        else if (__context_tag == to_underlying(Fields::kTotalOperationalTime))
        {
            err = DataModel::Decode(reader, totalOperationalTime);
        }
        else if (__context_tag == to_underlying(Fields::kPausedTime))
        {
            err = DataModel::Decode(reader, pausedTime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace OperationCompletion.
} // namespace Events

} // namespace RvcOperationalState
namespace ScenesManagement {
namespace Structs {

namespace AttributeValuePair {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kAttributeID), attributeID);
    encoder.Encode(to_underlying(Fields::kAttributeValue), attributeValue);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAttributeID))
        {
            err = DataModel::Decode(reader, attributeID);
        }
        else if (__context_tag == to_underlying(Fields::kAttributeValue))
        {
            err = DataModel::Decode(reader, attributeValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace AttributeValuePair

namespace ExtensionFieldSet {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kClusterID), clusterID);
    encoder.Encode(to_underlying(Fields::kAttributeValueList), attributeValueList);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kClusterID))
        {
            err = DataModel::Decode(reader, clusterID);
        }
        else if (__context_tag == to_underlying(Fields::kAttributeValueList))
        {
            err = DataModel::Decode(reader, attributeValueList);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ExtensionFieldSet

namespace SceneInfoStruct {
CHIP_ERROR Type::EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    return DoEncode(aWriter, aTag, NullOptional);
}

CHIP_ERROR Type::EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const
{
    return DoEncode(aWriter, aTag, MakeOptional(aAccessingFabricIndex));
}

CHIP_ERROR Type::DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const
{
    bool includeSensitive = !aAccessingFabricIndex.HasValue() || (aAccessingFabricIndex.Value() == fabricIndex);

    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };

    encoder.Encode(to_underlying(Fields::kSceneCount), sceneCount);
    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kCurrentScene), currentScene);
    }
    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kCurrentGroup), currentGroup);
    }
    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kSceneValid), sceneValid);
    }
    encoder.Encode(to_underlying(Fields::kRemainingCapacity), remainingCapacity);
    if (aAccessingFabricIndex.HasValue())
    {
        encoder.Encode(to_underlying(Fields::kFabricIndex), fabricIndex);
    }

    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSceneCount))
        {
            err = DataModel::Decode(reader, sceneCount);
        }
        else if (__context_tag == to_underlying(Fields::kCurrentScene))
        {
            err = DataModel::Decode(reader, currentScene);
        }
        else if (__context_tag == to_underlying(Fields::kCurrentGroup))
        {
            err = DataModel::Decode(reader, currentGroup);
        }
        else if (__context_tag == to_underlying(Fields::kSceneValid))
        {
            err = DataModel::Decode(reader, sceneValid);
        }
        else if (__context_tag == to_underlying(Fields::kRemainingCapacity))
        {
            err = DataModel::Decode(reader, remainingCapacity);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace SceneInfoStruct
} // namespace Structs

namespace Commands {
namespace AddScene {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    encoder.Encode(to_underlying(Fields::kSceneID), sceneID);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kSceneName), sceneName);
    encoder.Encode(to_underlying(Fields::kExtensionFieldSets), extensionFieldSets);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else if (__context_tag == to_underlying(Fields::kSceneID))
        {
            err = DataModel::Decode(reader, sceneID);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kSceneName))
        {
            err = DataModel::Decode(reader, sceneName);
        }
        else if (__context_tag == to_underlying(Fields::kExtensionFieldSets))
        {
            err = DataModel::Decode(reader, extensionFieldSets);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AddScene.
namespace AddSceneResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    encoder.Encode(to_underlying(Fields::kSceneID), sceneID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else if (__context_tag == to_underlying(Fields::kSceneID))
        {
            err = DataModel::Decode(reader, sceneID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AddSceneResponse.
namespace ViewScene {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    encoder.Encode(to_underlying(Fields::kSceneID), sceneID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else if (__context_tag == to_underlying(Fields::kSceneID))
        {
            err = DataModel::Decode(reader, sceneID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ViewScene.
namespace ViewSceneResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    encoder.Encode(to_underlying(Fields::kSceneID), sceneID);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kSceneName), sceneName);
    encoder.Encode(to_underlying(Fields::kExtensionFieldSets), extensionFieldSets);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else if (__context_tag == to_underlying(Fields::kSceneID))
        {
            err = DataModel::Decode(reader, sceneID);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kSceneName))
        {
            err = DataModel::Decode(reader, sceneName);
        }
        else if (__context_tag == to_underlying(Fields::kExtensionFieldSets))
        {
            err = DataModel::Decode(reader, extensionFieldSets);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ViewSceneResponse.
namespace RemoveScene {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    encoder.Encode(to_underlying(Fields::kSceneID), sceneID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else if (__context_tag == to_underlying(Fields::kSceneID))
        {
            err = DataModel::Decode(reader, sceneID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RemoveScene.
namespace RemoveSceneResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    encoder.Encode(to_underlying(Fields::kSceneID), sceneID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else if (__context_tag == to_underlying(Fields::kSceneID))
        {
            err = DataModel::Decode(reader, sceneID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RemoveSceneResponse.
namespace RemoveAllScenes {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RemoveAllScenes.
namespace RemoveAllScenesResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RemoveAllScenesResponse.
namespace StoreScene {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    encoder.Encode(to_underlying(Fields::kSceneID), sceneID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else if (__context_tag == to_underlying(Fields::kSceneID))
        {
            err = DataModel::Decode(reader, sceneID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StoreScene.
namespace StoreSceneResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    encoder.Encode(to_underlying(Fields::kSceneID), sceneID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else if (__context_tag == to_underlying(Fields::kSceneID))
        {
            err = DataModel::Decode(reader, sceneID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StoreSceneResponse.
namespace RecallScene {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    encoder.Encode(to_underlying(Fields::kSceneID), sceneID);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else if (__context_tag == to_underlying(Fields::kSceneID))
        {
            err = DataModel::Decode(reader, sceneID);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RecallScene.
namespace GetSceneMembership {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetSceneMembership.
namespace GetSceneMembershipResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kCapacity), capacity);
    encoder.Encode(to_underlying(Fields::kGroupID), groupID);
    encoder.Encode(to_underlying(Fields::kSceneList), sceneList);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kCapacity))
        {
            err = DataModel::Decode(reader, capacity);
        }
        else if (__context_tag == to_underlying(Fields::kGroupID))
        {
            err = DataModel::Decode(reader, groupID);
        }
        else if (__context_tag == to_underlying(Fields::kSceneList))
        {
            err = DataModel::Decode(reader, sceneList);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetSceneMembershipResponse.
namespace CopyScene {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMode), mode);
    encoder.Encode(to_underlying(Fields::kGroupIdentifierFrom), groupIdentifierFrom);
    encoder.Encode(to_underlying(Fields::kSceneIdentifierFrom), sceneIdentifierFrom);
    encoder.Encode(to_underlying(Fields::kGroupIdentifierTo), groupIdentifierTo);
    encoder.Encode(to_underlying(Fields::kSceneIdentifierTo), sceneIdentifierTo);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMode))
        {
            err = DataModel::Decode(reader, mode);
        }
        else if (__context_tag == to_underlying(Fields::kGroupIdentifierFrom))
        {
            err = DataModel::Decode(reader, groupIdentifierFrom);
        }
        else if (__context_tag == to_underlying(Fields::kSceneIdentifierFrom))
        {
            err = DataModel::Decode(reader, sceneIdentifierFrom);
        }
        else if (__context_tag == to_underlying(Fields::kGroupIdentifierTo))
        {
            err = DataModel::Decode(reader, groupIdentifierTo);
        }
        else if (__context_tag == to_underlying(Fields::kSceneIdentifierTo))
        {
            err = DataModel::Decode(reader, sceneIdentifierTo);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace CopyScene.
namespace CopySceneResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kGroupIdentifierFrom), groupIdentifierFrom);
    encoder.Encode(to_underlying(Fields::kSceneIdentifierFrom), sceneIdentifierFrom);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kGroupIdentifierFrom))
        {
            err = DataModel::Decode(reader, groupIdentifierFrom);
        }
        else if (__context_tag == to_underlying(Fields::kSceneIdentifierFrom))
        {
            err = DataModel::Decode(reader, sceneIdentifierFrom);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace CopySceneResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::LastConfiguredBy::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lastConfiguredBy);
    case Attributes::SceneTableSize::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, sceneTableSize);
    case Attributes::FabricSceneInfo::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, fabricSceneInfo);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace ScenesManagement
namespace HepaFilterMonitoring {
namespace Structs {

namespace ReplacementProductStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kProductIdentifierType), productIdentifierType);
    encoder.Encode(to_underlying(Fields::kProductIdentifierValue), productIdentifierValue);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kProductIdentifierType))
        {
            err = DataModel::Decode(reader, productIdentifierType);
        }
        else if (__context_tag == to_underlying(Fields::kProductIdentifierValue))
        {
            err = DataModel::Decode(reader, productIdentifierValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ReplacementProductStruct
} // namespace Structs

namespace Commands {
namespace ResetCondition {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ResetCondition.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Condition::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, condition);
    case Attributes::DegradationDirection::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, degradationDirection);
    case Attributes::ChangeIndication::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, changeIndication);
    case Attributes::InPlaceIndicator::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, inPlaceIndicator);
    case Attributes::LastChangedTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lastChangedTime);
    case Attributes::ReplacementProductList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, replacementProductList);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace HepaFilterMonitoring
namespace ActivatedCarbonFilterMonitoring {
namespace Structs {

namespace ReplacementProductStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kProductIdentifierType), productIdentifierType);
    encoder.Encode(to_underlying(Fields::kProductIdentifierValue), productIdentifierValue);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kProductIdentifierType))
        {
            err = DataModel::Decode(reader, productIdentifierType);
        }
        else if (__context_tag == to_underlying(Fields::kProductIdentifierValue))
        {
            err = DataModel::Decode(reader, productIdentifierValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ReplacementProductStruct
} // namespace Structs

namespace Commands {
namespace ResetCondition {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ResetCondition.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Condition::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, condition);
    case Attributes::DegradationDirection::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, degradationDirection);
    case Attributes::ChangeIndication::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, changeIndication);
    case Attributes::InPlaceIndicator::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, inPlaceIndicator);
    case Attributes::LastChangedTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lastChangedTime);
    case Attributes::ReplacementProductList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, replacementProductList);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace ActivatedCarbonFilterMonitoring
namespace BooleanStateConfiguration {

namespace Commands {
namespace SuppressAlarm {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kAlarmsToSuppress), alarmsToSuppress);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAlarmsToSuppress))
        {
            err = DataModel::Decode(reader, alarmsToSuppress);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SuppressAlarm.
namespace EnableDisableAlarm {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kAlarmsToEnableDisable), alarmsToEnableDisable);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAlarmsToEnableDisable))
        {
            err = DataModel::Decode(reader, alarmsToEnableDisable);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace EnableDisableAlarm.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::CurrentSensitivityLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentSensitivityLevel);
    case Attributes::SupportedSensitivityLevels::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedSensitivityLevels);
    case Attributes::DefaultSensitivityLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, defaultSensitivityLevel);
    case Attributes::AlarmsActive::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, alarmsActive);
    case Attributes::AlarmsSuppressed::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, alarmsSuppressed);
    case Attributes::AlarmsEnabled::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, alarmsEnabled);
    case Attributes::AlarmsSupported::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, alarmsSupported);
    case Attributes::SensorFault::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, sensorFault);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace AlarmsStateChanged {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kAlarmsActive), alarmsActive));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kAlarmsSuppressed), alarmsSuppressed));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAlarmsActive))
        {
            err = DataModel::Decode(reader, alarmsActive);
        }
        else if (__context_tag == to_underlying(Fields::kAlarmsSuppressed))
        {
            err = DataModel::Decode(reader, alarmsSuppressed);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AlarmsStateChanged.
namespace SensorFault {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSensorFault), sensorFault));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSensorFault))
        {
            err = DataModel::Decode(reader, sensorFault);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SensorFault.
} // namespace Events

} // namespace BooleanStateConfiguration
namespace ValveConfigurationAndControl {

namespace Commands {
namespace Open {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOpenDuration), openDuration);
    encoder.Encode(to_underlying(Fields::kTargetLevel), targetLevel);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kOpenDuration))
        {
            err = DataModel::Decode(reader, openDuration);
        }
        else if (__context_tag == to_underlying(Fields::kTargetLevel))
        {
            err = DataModel::Decode(reader, targetLevel);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Open.
namespace Close {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Close.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::OpenDuration::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, openDuration);
    case Attributes::DefaultOpenDuration::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, defaultOpenDuration);
    case Attributes::AutoCloseTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, autoCloseTime);
    case Attributes::RemainingDuration::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, remainingDuration);
    case Attributes::CurrentState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentState);
    case Attributes::TargetState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, targetState);
    case Attributes::CurrentLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentLevel);
    case Attributes::TargetLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, targetLevel);
    case Attributes::DefaultOpenLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, defaultOpenLevel);
    case Attributes::ValveFault::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, valveFault);
    case Attributes::LevelStep::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, levelStep);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace ValveStateChanged {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kValveState), valveState));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kValveLevel), valveLevel));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kValveState))
        {
            err = DataModel::Decode(reader, valveState);
        }
        else if (__context_tag == to_underlying(Fields::kValveLevel))
        {
            err = DataModel::Decode(reader, valveLevel);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ValveStateChanged.
namespace ValveFault {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kValveFault), valveFault));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kValveFault))
        {
            err = DataModel::Decode(reader, valveFault);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ValveFault.
} // namespace Events

} // namespace ValveConfigurationAndControl
namespace ElectricalPowerMeasurement {
namespace Structs {

namespace HarmonicMeasurementStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOrder), order);
    encoder.Encode(to_underlying(Fields::kMeasurement), measurement);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kOrder))
        {
            err = DataModel::Decode(reader, order);
        }
        else if (__context_tag == to_underlying(Fields::kMeasurement))
        {
            err = DataModel::Decode(reader, measurement);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace HarmonicMeasurementStruct

namespace MeasurementRangeStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMeasurementType), measurementType);
    encoder.Encode(to_underlying(Fields::kMin), min);
    encoder.Encode(to_underlying(Fields::kMax), max);
    encoder.Encode(to_underlying(Fields::kStartTimestamp), startTimestamp);
    encoder.Encode(to_underlying(Fields::kEndTimestamp), endTimestamp);
    encoder.Encode(to_underlying(Fields::kMinTimestamp), minTimestamp);
    encoder.Encode(to_underlying(Fields::kMaxTimestamp), maxTimestamp);
    encoder.Encode(to_underlying(Fields::kStartSystime), startSystime);
    encoder.Encode(to_underlying(Fields::kEndSystime), endSystime);
    encoder.Encode(to_underlying(Fields::kMinSystime), minSystime);
    encoder.Encode(to_underlying(Fields::kMaxSystime), maxSystime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMeasurementType))
        {
            err = DataModel::Decode(reader, measurementType);
        }
        else if (__context_tag == to_underlying(Fields::kMin))
        {
            err = DataModel::Decode(reader, min);
        }
        else if (__context_tag == to_underlying(Fields::kMax))
        {
            err = DataModel::Decode(reader, max);
        }
        else if (__context_tag == to_underlying(Fields::kStartTimestamp))
        {
            err = DataModel::Decode(reader, startTimestamp);
        }
        else if (__context_tag == to_underlying(Fields::kEndTimestamp))
        {
            err = DataModel::Decode(reader, endTimestamp);
        }
        else if (__context_tag == to_underlying(Fields::kMinTimestamp))
        {
            err = DataModel::Decode(reader, minTimestamp);
        }
        else if (__context_tag == to_underlying(Fields::kMaxTimestamp))
        {
            err = DataModel::Decode(reader, maxTimestamp);
        }
        else if (__context_tag == to_underlying(Fields::kStartSystime))
        {
            err = DataModel::Decode(reader, startSystime);
        }
        else if (__context_tag == to_underlying(Fields::kEndSystime))
        {
            err = DataModel::Decode(reader, endSystime);
        }
        else if (__context_tag == to_underlying(Fields::kMinSystime))
        {
            err = DataModel::Decode(reader, minSystime);
        }
        else if (__context_tag == to_underlying(Fields::kMaxSystime))
        {
            err = DataModel::Decode(reader, maxSystime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace MeasurementRangeStruct
} // namespace Structs

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::PowerMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, powerMode);
    case Attributes::NumberOfMeasurementTypes::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfMeasurementTypes);
    case Attributes::Accuracy::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, accuracy);
    case Attributes::Ranges::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ranges);
    case Attributes::Voltage::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, voltage);
    case Attributes::ActiveCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeCurrent);
    case Attributes::ReactiveCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, reactiveCurrent);
    case Attributes::ApparentCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, apparentCurrent);
    case Attributes::ActivePower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activePower);
    case Attributes::ReactivePower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, reactivePower);
    case Attributes::ApparentPower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, apparentPower);
    case Attributes::RMSVoltage::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, RMSVoltage);
    case Attributes::RMSCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, RMSCurrent);
    case Attributes::RMSPower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, RMSPower);
    case Attributes::Frequency::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, frequency);
    case Attributes::HarmonicCurrents::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, harmonicCurrents);
    case Attributes::HarmonicPhases::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, harmonicPhases);
    case Attributes::PowerFactor::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, powerFactor);
    case Attributes::NeutralCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, neutralCurrent);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace MeasurementPeriodRanges {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kRanges), ranges));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kRanges))
        {
            err = DataModel::Decode(reader, ranges);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MeasurementPeriodRanges.
} // namespace Events

} // namespace ElectricalPowerMeasurement
namespace ElectricalEnergyMeasurement {
namespace Structs {

namespace CumulativeEnergyResetStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kImportedResetTimestamp), importedResetTimestamp);
    encoder.Encode(to_underlying(Fields::kExportedResetTimestamp), exportedResetTimestamp);
    encoder.Encode(to_underlying(Fields::kImportedResetSystime), importedResetSystime);
    encoder.Encode(to_underlying(Fields::kExportedResetSystime), exportedResetSystime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kImportedResetTimestamp))
        {
            err = DataModel::Decode(reader, importedResetTimestamp);
        }
        else if (__context_tag == to_underlying(Fields::kExportedResetTimestamp))
        {
            err = DataModel::Decode(reader, exportedResetTimestamp);
        }
        else if (__context_tag == to_underlying(Fields::kImportedResetSystime))
        {
            err = DataModel::Decode(reader, importedResetSystime);
        }
        else if (__context_tag == to_underlying(Fields::kExportedResetSystime))
        {
            err = DataModel::Decode(reader, exportedResetSystime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace CumulativeEnergyResetStruct

namespace EnergyMeasurementStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kEnergy), energy);
    encoder.Encode(to_underlying(Fields::kStartTimestamp), startTimestamp);
    encoder.Encode(to_underlying(Fields::kEndTimestamp), endTimestamp);
    encoder.Encode(to_underlying(Fields::kStartSystime), startSystime);
    encoder.Encode(to_underlying(Fields::kEndSystime), endSystime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kEnergy))
        {
            err = DataModel::Decode(reader, energy);
        }
        else if (__context_tag == to_underlying(Fields::kStartTimestamp))
        {
            err = DataModel::Decode(reader, startTimestamp);
        }
        else if (__context_tag == to_underlying(Fields::kEndTimestamp))
        {
            err = DataModel::Decode(reader, endTimestamp);
        }
        else if (__context_tag == to_underlying(Fields::kStartSystime))
        {
            err = DataModel::Decode(reader, startSystime);
        }
        else if (__context_tag == to_underlying(Fields::kEndSystime))
        {
            err = DataModel::Decode(reader, endSystime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace EnergyMeasurementStruct
} // namespace Structs

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Accuracy::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, accuracy);
    case Attributes::CumulativeEnergyImported::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, cumulativeEnergyImported);
    case Attributes::CumulativeEnergyExported::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, cumulativeEnergyExported);
    case Attributes::PeriodicEnergyImported::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, periodicEnergyImported);
    case Attributes::PeriodicEnergyExported::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, periodicEnergyExported);
    case Attributes::CumulativeEnergyReset::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, cumulativeEnergyReset);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace CumulativeEnergyMeasured {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kEnergyImported), energyImported));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kEnergyExported), energyExported));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kEnergyImported))
        {
            err = DataModel::Decode(reader, energyImported);
        }
        else if (__context_tag == to_underlying(Fields::kEnergyExported))
        {
            err = DataModel::Decode(reader, energyExported);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace CumulativeEnergyMeasured.
namespace PeriodicEnergyMeasured {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kEnergyImported), energyImported));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kEnergyExported), energyExported));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kEnergyImported))
        {
            err = DataModel::Decode(reader, energyImported);
        }
        else if (__context_tag == to_underlying(Fields::kEnergyExported))
        {
            err = DataModel::Decode(reader, energyExported);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace PeriodicEnergyMeasured.
} // namespace Events

} // namespace ElectricalEnergyMeasurement
namespace DemandResponseLoadControl {
namespace Structs {

namespace HeatingSourceControlStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kHeatingSource), heatingSource);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kHeatingSource))
        {
            err = DataModel::Decode(reader, heatingSource);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace HeatingSourceControlStruct

namespace PowerSavingsControlStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPowerSavings), powerSavings);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPowerSavings))
        {
            err = DataModel::Decode(reader, powerSavings);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace PowerSavingsControlStruct

namespace DutyCycleControlStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kDutyCycle), dutyCycle);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDutyCycle))
        {
            err = DataModel::Decode(reader, dutyCycle);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace DutyCycleControlStruct

namespace AverageLoadControlStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLoadAdjustment), loadAdjustment);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLoadAdjustment))
        {
            err = DataModel::Decode(reader, loadAdjustment);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace AverageLoadControlStruct

namespace TemperatureControlStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCoolingTempOffset), coolingTempOffset);
    encoder.Encode(to_underlying(Fields::kHeatingtTempOffset), heatingtTempOffset);
    encoder.Encode(to_underlying(Fields::kCoolingTempSetpoint), coolingTempSetpoint);
    encoder.Encode(to_underlying(Fields::kHeatingTempSetpoint), heatingTempSetpoint);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCoolingTempOffset))
        {
            err = DataModel::Decode(reader, coolingTempOffset);
        }
        else if (__context_tag == to_underlying(Fields::kHeatingtTempOffset))
        {
            err = DataModel::Decode(reader, heatingtTempOffset);
        }
        else if (__context_tag == to_underlying(Fields::kCoolingTempSetpoint))
        {
            err = DataModel::Decode(reader, coolingTempSetpoint);
        }
        else if (__context_tag == to_underlying(Fields::kHeatingTempSetpoint))
        {
            err = DataModel::Decode(reader, heatingTempSetpoint);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace TemperatureControlStruct

namespace LoadControlEventTransitionStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kDuration), duration);
    encoder.Encode(to_underlying(Fields::kControl), control);
    encoder.Encode(to_underlying(Fields::kTemperatureControl), temperatureControl);
    encoder.Encode(to_underlying(Fields::kAverageLoadControl), averageLoadControl);
    encoder.Encode(to_underlying(Fields::kDutyCycleControl), dutyCycleControl);
    encoder.Encode(to_underlying(Fields::kPowerSavingsControl), powerSavingsControl);
    encoder.Encode(to_underlying(Fields::kHeatingSourceControl), heatingSourceControl);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDuration))
        {
            err = DataModel::Decode(reader, duration);
        }
        else if (__context_tag == to_underlying(Fields::kControl))
        {
            err = DataModel::Decode(reader, control);
        }
        else if (__context_tag == to_underlying(Fields::kTemperatureControl))
        {
            err = DataModel::Decode(reader, temperatureControl);
        }
        else if (__context_tag == to_underlying(Fields::kAverageLoadControl))
        {
            err = DataModel::Decode(reader, averageLoadControl);
        }
        else if (__context_tag == to_underlying(Fields::kDutyCycleControl))
        {
            err = DataModel::Decode(reader, dutyCycleControl);
        }
        else if (__context_tag == to_underlying(Fields::kPowerSavingsControl))
        {
            err = DataModel::Decode(reader, powerSavingsControl);
        }
        else if (__context_tag == to_underlying(Fields::kHeatingSourceControl))
        {
            err = DataModel::Decode(reader, heatingSourceControl);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace LoadControlEventTransitionStruct

namespace LoadControlEventStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kEventID), eventID);
    encoder.Encode(to_underlying(Fields::kProgramID), programID);
    encoder.Encode(to_underlying(Fields::kControl), control);
    encoder.Encode(to_underlying(Fields::kDeviceClass), deviceClass);
    encoder.Encode(to_underlying(Fields::kEnrollmentGroup), enrollmentGroup);
    encoder.Encode(to_underlying(Fields::kCriticality), criticality);
    encoder.Encode(to_underlying(Fields::kStartTime), startTime);
    encoder.Encode(to_underlying(Fields::kTransitions), transitions);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kEventID))
        {
            err = DataModel::Decode(reader, eventID);
        }
        else if (__context_tag == to_underlying(Fields::kProgramID))
        {
            err = DataModel::Decode(reader, programID);
        }
        else if (__context_tag == to_underlying(Fields::kControl))
        {
            err = DataModel::Decode(reader, control);
        }
        else if (__context_tag == to_underlying(Fields::kDeviceClass))
        {
            err = DataModel::Decode(reader, deviceClass);
        }
        else if (__context_tag == to_underlying(Fields::kEnrollmentGroup))
        {
            err = DataModel::Decode(reader, enrollmentGroup);
        }
        else if (__context_tag == to_underlying(Fields::kCriticality))
        {
            err = DataModel::Decode(reader, criticality);
        }
        else if (__context_tag == to_underlying(Fields::kStartTime))
        {
            err = DataModel::Decode(reader, startTime);
        }
        else if (__context_tag == to_underlying(Fields::kTransitions))
        {
            err = DataModel::Decode(reader, transitions);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace LoadControlEventStruct

namespace LoadControlProgramStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kProgramID), programID);
    encoder.Encode(to_underlying(Fields::kName), name);
    encoder.Encode(to_underlying(Fields::kEnrollmentGroup), enrollmentGroup);
    encoder.Encode(to_underlying(Fields::kRandomStartMinutes), randomStartMinutes);
    encoder.Encode(to_underlying(Fields::kRandomDurationMinutes), randomDurationMinutes);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kProgramID))
        {
            err = DataModel::Decode(reader, programID);
        }
        else if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else if (__context_tag == to_underlying(Fields::kEnrollmentGroup))
        {
            err = DataModel::Decode(reader, enrollmentGroup);
        }
        else if (__context_tag == to_underlying(Fields::kRandomStartMinutes))
        {
            err = DataModel::Decode(reader, randomStartMinutes);
        }
        else if (__context_tag == to_underlying(Fields::kRandomDurationMinutes))
        {
            err = DataModel::Decode(reader, randomDurationMinutes);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace LoadControlProgramStruct
} // namespace Structs

namespace Commands {
namespace RegisterLoadControlProgramRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLoadControlProgram), loadControlProgram);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLoadControlProgram))
        {
            err = DataModel::Decode(reader, loadControlProgram);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RegisterLoadControlProgramRequest.
namespace UnregisterLoadControlProgramRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLoadControlProgramID), loadControlProgramID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLoadControlProgramID))
        {
            err = DataModel::Decode(reader, loadControlProgramID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace UnregisterLoadControlProgramRequest.
namespace AddLoadControlEventRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kEvent), event);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kEvent))
        {
            err = DataModel::Decode(reader, event);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AddLoadControlEventRequest.
namespace RemoveLoadControlEventRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kEventID), eventID);
    encoder.Encode(to_underlying(Fields::kCancelControl), cancelControl);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kEventID))
        {
            err = DataModel::Decode(reader, eventID);
        }
        else if (__context_tag == to_underlying(Fields::kCancelControl))
        {
            err = DataModel::Decode(reader, cancelControl);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RemoveLoadControlEventRequest.
namespace ClearLoadControlEventsRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ClearLoadControlEventsRequest.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::LoadControlPrograms::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, loadControlPrograms);
    case Attributes::NumberOfLoadControlPrograms::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfLoadControlPrograms);
    case Attributes::Events::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, events);
    case Attributes::ActiveEvents::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeEvents);
    case Attributes::NumberOfEventsPerProgram::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfEventsPerProgram);
    case Attributes::NumberOfTransitions::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfTransitions);
    case Attributes::DefaultRandomStart::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, defaultRandomStart);
    case Attributes::DefaultRandomDuration::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, defaultRandomDuration);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace LoadControlEventStatusChange {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kEventID), eventID));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kTransitionIndex), transitionIndex));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kStatus), status));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCriticality), criticality));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kControl), control));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kTemperatureControl), temperatureControl));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kAverageLoadControl), averageLoadControl));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kDutyCycleControl), dutyCycleControl));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPowerSavingsControl), powerSavingsControl));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kHeatingSourceControl), heatingSourceControl));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kEventID))
        {
            err = DataModel::Decode(reader, eventID);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionIndex))
        {
            err = DataModel::Decode(reader, transitionIndex);
        }
        else if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kCriticality))
        {
            err = DataModel::Decode(reader, criticality);
        }
        else if (__context_tag == to_underlying(Fields::kControl))
        {
            err = DataModel::Decode(reader, control);
        }
        else if (__context_tag == to_underlying(Fields::kTemperatureControl))
        {
            err = DataModel::Decode(reader, temperatureControl);
        }
        else if (__context_tag == to_underlying(Fields::kAverageLoadControl))
        {
            err = DataModel::Decode(reader, averageLoadControl);
        }
        else if (__context_tag == to_underlying(Fields::kDutyCycleControl))
        {
            err = DataModel::Decode(reader, dutyCycleControl);
        }
        else if (__context_tag == to_underlying(Fields::kPowerSavingsControl))
        {
            err = DataModel::Decode(reader, powerSavingsControl);
        }
        else if (__context_tag == to_underlying(Fields::kHeatingSourceControl))
        {
            err = DataModel::Decode(reader, heatingSourceControl);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace LoadControlEventStatusChange.
} // namespace Events

} // namespace DemandResponseLoadControl
namespace Messages {
namespace Structs {

namespace MessageResponseOptionStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMessageResponseID), messageResponseID);
    encoder.Encode(to_underlying(Fields::kLabel), label);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMessageResponseID))
        {
            err = DataModel::Decode(reader, messageResponseID);
        }
        else if (__context_tag == to_underlying(Fields::kLabel))
        {
            err = DataModel::Decode(reader, label);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace MessageResponseOptionStruct

namespace MessageStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMessageID), messageID);
    encoder.Encode(to_underlying(Fields::kPriority), priority);
    encoder.Encode(to_underlying(Fields::kMessageControl), messageControl);
    encoder.Encode(to_underlying(Fields::kStartTime), startTime);
    encoder.Encode(to_underlying(Fields::kDuration), duration);
    encoder.Encode(to_underlying(Fields::kMessageText), messageText);
    encoder.Encode(to_underlying(Fields::kResponses), responses);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMessageID))
        {
            err = DataModel::Decode(reader, messageID);
        }
        else if (__context_tag == to_underlying(Fields::kPriority))
        {
            err = DataModel::Decode(reader, priority);
        }
        else if (__context_tag == to_underlying(Fields::kMessageControl))
        {
            err = DataModel::Decode(reader, messageControl);
        }
        else if (__context_tag == to_underlying(Fields::kStartTime))
        {
            err = DataModel::Decode(reader, startTime);
        }
        else if (__context_tag == to_underlying(Fields::kDuration))
        {
            err = DataModel::Decode(reader, duration);
        }
        else if (__context_tag == to_underlying(Fields::kMessageText))
        {
            err = DataModel::Decode(reader, messageText);
        }
        else if (__context_tag == to_underlying(Fields::kResponses))
        {
            err = DataModel::Decode(reader, responses);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace MessageStruct
} // namespace Structs

namespace Commands {
namespace PresentMessagesRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMessageID), messageID);
    encoder.Encode(to_underlying(Fields::kPriority), priority);
    encoder.Encode(to_underlying(Fields::kMessageControl), messageControl);
    encoder.Encode(to_underlying(Fields::kStartTime), startTime);
    encoder.Encode(to_underlying(Fields::kDuration), duration);
    encoder.Encode(to_underlying(Fields::kMessageText), messageText);
    encoder.Encode(to_underlying(Fields::kResponses), responses);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMessageID))
        {
            err = DataModel::Decode(reader, messageID);
        }
        else if (__context_tag == to_underlying(Fields::kPriority))
        {
            err = DataModel::Decode(reader, priority);
        }
        else if (__context_tag == to_underlying(Fields::kMessageControl))
        {
            err = DataModel::Decode(reader, messageControl);
        }
        else if (__context_tag == to_underlying(Fields::kStartTime))
        {
            err = DataModel::Decode(reader, startTime);
        }
        else if (__context_tag == to_underlying(Fields::kDuration))
        {
            err = DataModel::Decode(reader, duration);
        }
        else if (__context_tag == to_underlying(Fields::kMessageText))
        {
            err = DataModel::Decode(reader, messageText);
        }
        else if (__context_tag == to_underlying(Fields::kResponses))
        {
            err = DataModel::Decode(reader, responses);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace PresentMessagesRequest.
namespace CancelMessagesRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMessageIDs), messageIDs);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMessageIDs))
        {
            err = DataModel::Decode(reader, messageIDs);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace CancelMessagesRequest.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Messages::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, messages);
    case Attributes::ActiveMessageIDs::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeMessageIDs);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace MessageQueued {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kMessageID), messageID));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMessageID))
        {
            err = DataModel::Decode(reader, messageID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MessageQueued.
namespace MessagePresented {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kMessageID), messageID));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMessageID))
        {
            err = DataModel::Decode(reader, messageID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MessagePresented.
namespace MessageComplete {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kMessageID), messageID));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kResponseID), responseID));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kReply), reply));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kFutureMessagesPreference), futureMessagesPreference));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMessageID))
        {
            err = DataModel::Decode(reader, messageID);
        }
        else if (__context_tag == to_underlying(Fields::kResponseID))
        {
            err = DataModel::Decode(reader, responseID);
        }
        else if (__context_tag == to_underlying(Fields::kReply))
        {
            err = DataModel::Decode(reader, reply);
        }
        else if (__context_tag == to_underlying(Fields::kFutureMessagesPreference))
        {
            err = DataModel::Decode(reader, futureMessagesPreference);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MessageComplete.
} // namespace Events

} // namespace Messages
namespace DeviceEnergyManagement {
namespace Structs {

namespace CostStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCostType), costType);
    encoder.Encode(to_underlying(Fields::kValue), value);
    encoder.Encode(to_underlying(Fields::kDecimalPoints), decimalPoints);
    encoder.Encode(to_underlying(Fields::kCurrency), currency);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCostType))
        {
            err = DataModel::Decode(reader, costType);
        }
        else if (__context_tag == to_underlying(Fields::kValue))
        {
            err = DataModel::Decode(reader, value);
        }
        else if (__context_tag == to_underlying(Fields::kDecimalPoints))
        {
            err = DataModel::Decode(reader, decimalPoints);
        }
        else if (__context_tag == to_underlying(Fields::kCurrency))
        {
            err = DataModel::Decode(reader, currency);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace CostStruct

namespace SlotStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMinDuration), minDuration);
    encoder.Encode(to_underlying(Fields::kMaxDuration), maxDuration);
    encoder.Encode(to_underlying(Fields::kDefaultDuration), defaultDuration);
    encoder.Encode(to_underlying(Fields::kElapsedSlotTime), elapsedSlotTime);
    encoder.Encode(to_underlying(Fields::kRemainingSlotTime), remainingSlotTime);
    encoder.Encode(to_underlying(Fields::kSlotIsPauseable), slotIsPauseable);
    encoder.Encode(to_underlying(Fields::kMinPauseDuration), minPauseDuration);
    encoder.Encode(to_underlying(Fields::kMaxPauseDuration), maxPauseDuration);
    encoder.Encode(to_underlying(Fields::kManufacturerESAState), manufacturerESAState);
    encoder.Encode(to_underlying(Fields::kNominalPower), nominalPower);
    encoder.Encode(to_underlying(Fields::kMinPower), minPower);
    encoder.Encode(to_underlying(Fields::kMaxPower), maxPower);
    encoder.Encode(to_underlying(Fields::kNominalEnergy), nominalEnergy);
    encoder.Encode(to_underlying(Fields::kCosts), costs);
    encoder.Encode(to_underlying(Fields::kMinPowerAdjustment), minPowerAdjustment);
    encoder.Encode(to_underlying(Fields::kMaxPowerAdjustment), maxPowerAdjustment);
    encoder.Encode(to_underlying(Fields::kMinDurationAdjustment), minDurationAdjustment);
    encoder.Encode(to_underlying(Fields::kMaxDurationAdjustment), maxDurationAdjustment);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMinDuration))
        {
            err = DataModel::Decode(reader, minDuration);
        }
        else if (__context_tag == to_underlying(Fields::kMaxDuration))
        {
            err = DataModel::Decode(reader, maxDuration);
        }
        else if (__context_tag == to_underlying(Fields::kDefaultDuration))
        {
            err = DataModel::Decode(reader, defaultDuration);
        }
        else if (__context_tag == to_underlying(Fields::kElapsedSlotTime))
        {
            err = DataModel::Decode(reader, elapsedSlotTime);
        }
        else if (__context_tag == to_underlying(Fields::kRemainingSlotTime))
        {
            err = DataModel::Decode(reader, remainingSlotTime);
        }
        else if (__context_tag == to_underlying(Fields::kSlotIsPauseable))
        {
            err = DataModel::Decode(reader, slotIsPauseable);
        }
        else if (__context_tag == to_underlying(Fields::kMinPauseDuration))
        {
            err = DataModel::Decode(reader, minPauseDuration);
        }
        else if (__context_tag == to_underlying(Fields::kMaxPauseDuration))
        {
            err = DataModel::Decode(reader, maxPauseDuration);
        }
        else if (__context_tag == to_underlying(Fields::kManufacturerESAState))
        {
            err = DataModel::Decode(reader, manufacturerESAState);
        }
        else if (__context_tag == to_underlying(Fields::kNominalPower))
        {
            err = DataModel::Decode(reader, nominalPower);
        }
        else if (__context_tag == to_underlying(Fields::kMinPower))
        {
            err = DataModel::Decode(reader, minPower);
        }
        else if (__context_tag == to_underlying(Fields::kMaxPower))
        {
            err = DataModel::Decode(reader, maxPower);
        }
        else if (__context_tag == to_underlying(Fields::kNominalEnergy))
        {
            err = DataModel::Decode(reader, nominalEnergy);
        }
        else if (__context_tag == to_underlying(Fields::kCosts))
        {
            err = DataModel::Decode(reader, costs);
        }
        else if (__context_tag == to_underlying(Fields::kMinPowerAdjustment))
        {
            err = DataModel::Decode(reader, minPowerAdjustment);
        }
        else if (__context_tag == to_underlying(Fields::kMaxPowerAdjustment))
        {
            err = DataModel::Decode(reader, maxPowerAdjustment);
        }
        else if (__context_tag == to_underlying(Fields::kMinDurationAdjustment))
        {
            err = DataModel::Decode(reader, minDurationAdjustment);
        }
        else if (__context_tag == to_underlying(Fields::kMaxDurationAdjustment))
        {
            err = DataModel::Decode(reader, maxDurationAdjustment);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace SlotStruct

namespace ForecastStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kForecastId), forecastId);
    encoder.Encode(to_underlying(Fields::kActiveSlotNumber), activeSlotNumber);
    encoder.Encode(to_underlying(Fields::kStartTime), startTime);
    encoder.Encode(to_underlying(Fields::kEndTime), endTime);
    encoder.Encode(to_underlying(Fields::kEarliestStartTime), earliestStartTime);
    encoder.Encode(to_underlying(Fields::kLatestEndTime), latestEndTime);
    encoder.Encode(to_underlying(Fields::kIsPauseable), isPauseable);
    encoder.Encode(to_underlying(Fields::kSlots), slots);
    encoder.Encode(to_underlying(Fields::kForecastUpdateReason), forecastUpdateReason);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kForecastId))
        {
            err = DataModel::Decode(reader, forecastId);
        }
        else if (__context_tag == to_underlying(Fields::kActiveSlotNumber))
        {
            err = DataModel::Decode(reader, activeSlotNumber);
        }
        else if (__context_tag == to_underlying(Fields::kStartTime))
        {
            err = DataModel::Decode(reader, startTime);
        }
        else if (__context_tag == to_underlying(Fields::kEndTime))
        {
            err = DataModel::Decode(reader, endTime);
        }
        else if (__context_tag == to_underlying(Fields::kEarliestStartTime))
        {
            err = DataModel::Decode(reader, earliestStartTime);
        }
        else if (__context_tag == to_underlying(Fields::kLatestEndTime))
        {
            err = DataModel::Decode(reader, latestEndTime);
        }
        else if (__context_tag == to_underlying(Fields::kIsPauseable))
        {
            err = DataModel::Decode(reader, isPauseable);
        }
        else if (__context_tag == to_underlying(Fields::kSlots))
        {
            err = DataModel::Decode(reader, slots);
        }
        else if (__context_tag == to_underlying(Fields::kForecastUpdateReason))
        {
            err = DataModel::Decode(reader, forecastUpdateReason);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ForecastStruct

namespace ConstraintsStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStartTime), startTime);
    encoder.Encode(to_underlying(Fields::kDuration), duration);
    encoder.Encode(to_underlying(Fields::kNominalPower), nominalPower);
    encoder.Encode(to_underlying(Fields::kMaximumEnergy), maximumEnergy);
    encoder.Encode(to_underlying(Fields::kLoadControl), loadControl);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStartTime))
        {
            err = DataModel::Decode(reader, startTime);
        }
        else if (__context_tag == to_underlying(Fields::kDuration))
        {
            err = DataModel::Decode(reader, duration);
        }
        else if (__context_tag == to_underlying(Fields::kNominalPower))
        {
            err = DataModel::Decode(reader, nominalPower);
        }
        else if (__context_tag == to_underlying(Fields::kMaximumEnergy))
        {
            err = DataModel::Decode(reader, maximumEnergy);
        }
        else if (__context_tag == to_underlying(Fields::kLoadControl))
        {
            err = DataModel::Decode(reader, loadControl);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ConstraintsStruct

namespace PowerAdjustStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMinPower), minPower);
    encoder.Encode(to_underlying(Fields::kMaxPower), maxPower);
    encoder.Encode(to_underlying(Fields::kMinDuration), minDuration);
    encoder.Encode(to_underlying(Fields::kMaxDuration), maxDuration);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMinPower))
        {
            err = DataModel::Decode(reader, minPower);
        }
        else if (__context_tag == to_underlying(Fields::kMaxPower))
        {
            err = DataModel::Decode(reader, maxPower);
        }
        else if (__context_tag == to_underlying(Fields::kMinDuration))
        {
            err = DataModel::Decode(reader, minDuration);
        }
        else if (__context_tag == to_underlying(Fields::kMaxDuration))
        {
            err = DataModel::Decode(reader, maxDuration);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace PowerAdjustStruct

namespace SlotAdjustmentStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kSlotIndex), slotIndex);
    encoder.Encode(to_underlying(Fields::kNominalPower), nominalPower);
    encoder.Encode(to_underlying(Fields::kDuration), duration);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSlotIndex))
        {
            err = DataModel::Decode(reader, slotIndex);
        }
        else if (__context_tag == to_underlying(Fields::kNominalPower))
        {
            err = DataModel::Decode(reader, nominalPower);
        }
        else if (__context_tag == to_underlying(Fields::kDuration))
        {
            err = DataModel::Decode(reader, duration);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace SlotAdjustmentStruct
} // namespace Structs

namespace Commands {
namespace PowerAdjustRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPower), power);
    encoder.Encode(to_underlying(Fields::kDuration), duration);
    encoder.Encode(to_underlying(Fields::kCause), cause);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPower))
        {
            err = DataModel::Decode(reader, power);
        }
        else if (__context_tag == to_underlying(Fields::kDuration))
        {
            err = DataModel::Decode(reader, duration);
        }
        else if (__context_tag == to_underlying(Fields::kCause))
        {
            err = DataModel::Decode(reader, cause);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace PowerAdjustRequest.
namespace CancelPowerAdjustRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace CancelPowerAdjustRequest.
namespace StartTimeAdjustRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kRequestedStartTime), requestedStartTime);
    encoder.Encode(to_underlying(Fields::kCause), cause);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kRequestedStartTime))
        {
            err = DataModel::Decode(reader, requestedStartTime);
        }
        else if (__context_tag == to_underlying(Fields::kCause))
        {
            err = DataModel::Decode(reader, cause);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StartTimeAdjustRequest.
namespace PauseRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kDuration), duration);
    encoder.Encode(to_underlying(Fields::kCause), cause);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDuration))
        {
            err = DataModel::Decode(reader, duration);
        }
        else if (__context_tag == to_underlying(Fields::kCause))
        {
            err = DataModel::Decode(reader, cause);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace PauseRequest.
namespace ResumeRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ResumeRequest.
namespace ModifyForecastRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kForecastId), forecastId);
    encoder.Encode(to_underlying(Fields::kSlotAdjustments), slotAdjustments);
    encoder.Encode(to_underlying(Fields::kCause), cause);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kForecastId))
        {
            err = DataModel::Decode(reader, forecastId);
        }
        else if (__context_tag == to_underlying(Fields::kSlotAdjustments))
        {
            err = DataModel::Decode(reader, slotAdjustments);
        }
        else if (__context_tag == to_underlying(Fields::kCause))
        {
            err = DataModel::Decode(reader, cause);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ModifyForecastRequest.
namespace RequestConstraintBasedForecast {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kConstraints), constraints);
    encoder.Encode(to_underlying(Fields::kCause), cause);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kConstraints))
        {
            err = DataModel::Decode(reader, constraints);
        }
        else if (__context_tag == to_underlying(Fields::kCause))
        {
            err = DataModel::Decode(reader, cause);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RequestConstraintBasedForecast.
namespace CancelRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace CancelRequest.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::ESAType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ESAType);
    case Attributes::ESACanGenerate::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ESACanGenerate);
    case Attributes::ESAState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ESAState);
    case Attributes::AbsMinPower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, absMinPower);
    case Attributes::AbsMaxPower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, absMaxPower);
    case Attributes::PowerAdjustmentCapability::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, powerAdjustmentCapability);
    case Attributes::Forecast::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, forecast);
    case Attributes::OptOutState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, optOutState);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace PowerAdjustStart {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace PowerAdjustStart.
namespace PowerAdjustEnd {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCause), cause));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kDuration), duration));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kEnergyUse), energyUse));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCause))
        {
            err = DataModel::Decode(reader, cause);
        }
        else if (__context_tag == to_underlying(Fields::kDuration))
        {
            err = DataModel::Decode(reader, duration);
        }
        else if (__context_tag == to_underlying(Fields::kEnergyUse))
        {
            err = DataModel::Decode(reader, energyUse);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace PowerAdjustEnd.
namespace Paused {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Paused.
namespace Resumed {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCause), cause));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCause))
        {
            err = DataModel::Decode(reader, cause);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Resumed.
} // namespace Events

} // namespace DeviceEnergyManagement
namespace EnergyEvse {
namespace Structs {

namespace ChargingTargetStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTargetTimeMinutesPastMidnight), targetTimeMinutesPastMidnight);
    encoder.Encode(to_underlying(Fields::kTargetSoC), targetSoC);
    encoder.Encode(to_underlying(Fields::kAddedEnergy), addedEnergy);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTargetTimeMinutesPastMidnight))
        {
            err = DataModel::Decode(reader, targetTimeMinutesPastMidnight);
        }
        else if (__context_tag == to_underlying(Fields::kTargetSoC))
        {
            err = DataModel::Decode(reader, targetSoC);
        }
        else if (__context_tag == to_underlying(Fields::kAddedEnergy))
        {
            err = DataModel::Decode(reader, addedEnergy);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ChargingTargetStruct

namespace ChargingTargetScheduleStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kDayOfWeekForSequence), dayOfWeekForSequence);
    encoder.Encode(to_underlying(Fields::kChargingTargets), chargingTargets);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDayOfWeekForSequence))
        {
            err = DataModel::Decode(reader, dayOfWeekForSequence);
        }
        else if (__context_tag == to_underlying(Fields::kChargingTargets))
        {
            err = DataModel::Decode(reader, chargingTargets);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ChargingTargetScheduleStruct
} // namespace Structs

namespace Commands {
namespace GetTargetsResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kChargingTargetSchedules), chargingTargetSchedules);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kChargingTargetSchedules))
        {
            err = DataModel::Decode(reader, chargingTargetSchedules);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetTargetsResponse.
namespace Disable {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Disable.
namespace EnableCharging {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kChargingEnabledUntil), chargingEnabledUntil);
    encoder.Encode(to_underlying(Fields::kMinimumChargeCurrent), minimumChargeCurrent);
    encoder.Encode(to_underlying(Fields::kMaximumChargeCurrent), maximumChargeCurrent);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kChargingEnabledUntil))
        {
            err = DataModel::Decode(reader, chargingEnabledUntil);
        }
        else if (__context_tag == to_underlying(Fields::kMinimumChargeCurrent))
        {
            err = DataModel::Decode(reader, minimumChargeCurrent);
        }
        else if (__context_tag == to_underlying(Fields::kMaximumChargeCurrent))
        {
            err = DataModel::Decode(reader, maximumChargeCurrent);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace EnableCharging.
namespace EnableDischarging {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kDischargingEnabledUntil), dischargingEnabledUntil);
    encoder.Encode(to_underlying(Fields::kMaximumDischargeCurrent), maximumDischargeCurrent);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDischargingEnabledUntil))
        {
            err = DataModel::Decode(reader, dischargingEnabledUntil);
        }
        else if (__context_tag == to_underlying(Fields::kMaximumDischargeCurrent))
        {
            err = DataModel::Decode(reader, maximumDischargeCurrent);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace EnableDischarging.
namespace StartDiagnostics {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace StartDiagnostics.
namespace SetTargets {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kChargingTargetSchedules), chargingTargetSchedules);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kChargingTargetSchedules))
        {
            err = DataModel::Decode(reader, chargingTargetSchedules);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetTargets.
namespace GetTargets {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace GetTargets.
namespace ClearTargets {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ClearTargets.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::State::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, state);
    case Attributes::SupplyState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supplyState);
    case Attributes::FaultState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, faultState);
    case Attributes::ChargingEnabledUntil::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, chargingEnabledUntil);
    case Attributes::DischargingEnabledUntil::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dischargingEnabledUntil);
    case Attributes::CircuitCapacity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, circuitCapacity);
    case Attributes::MinimumChargeCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minimumChargeCurrent);
    case Attributes::MaximumChargeCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maximumChargeCurrent);
    case Attributes::MaximumDischargeCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maximumDischargeCurrent);
    case Attributes::UserMaximumChargeCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, userMaximumChargeCurrent);
    case Attributes::RandomizationDelayWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, randomizationDelayWindow);
    case Attributes::NextChargeStartTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nextChargeStartTime);
    case Attributes::NextChargeTargetTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nextChargeTargetTime);
    case Attributes::NextChargeRequiredEnergy::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nextChargeRequiredEnergy);
    case Attributes::NextChargeTargetSoC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nextChargeTargetSoC);
    case Attributes::ApproximateEVEfficiency::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, approximateEVEfficiency);
    case Attributes::StateOfCharge::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, stateOfCharge);
    case Attributes::BatteryCapacity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, batteryCapacity);
    case Attributes::VehicleID::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, vehicleID);
    case Attributes::SessionID::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, sessionID);
    case Attributes::SessionDuration::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, sessionDuration);
    case Attributes::SessionEnergyCharged::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, sessionEnergyCharged);
    case Attributes::SessionEnergyDischarged::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, sessionEnergyDischarged);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace EVConnected {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSessionID), sessionID));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSessionID))
        {
            err = DataModel::Decode(reader, sessionID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace EVConnected.
namespace EVNotDetected {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSessionID), sessionID));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kState), state));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSessionDuration), sessionDuration));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSessionEnergyCharged), sessionEnergyCharged));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSessionEnergyDischarged), sessionEnergyDischarged));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSessionID))
        {
            err = DataModel::Decode(reader, sessionID);
        }
        else if (__context_tag == to_underlying(Fields::kState))
        {
            err = DataModel::Decode(reader, state);
        }
        else if (__context_tag == to_underlying(Fields::kSessionDuration))
        {
            err = DataModel::Decode(reader, sessionDuration);
        }
        else if (__context_tag == to_underlying(Fields::kSessionEnergyCharged))
        {
            err = DataModel::Decode(reader, sessionEnergyCharged);
        }
        else if (__context_tag == to_underlying(Fields::kSessionEnergyDischarged))
        {
            err = DataModel::Decode(reader, sessionEnergyDischarged);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace EVNotDetected.
namespace EnergyTransferStarted {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSessionID), sessionID));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kState), state));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kMaximumCurrent), maximumCurrent));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSessionID))
        {
            err = DataModel::Decode(reader, sessionID);
        }
        else if (__context_tag == to_underlying(Fields::kState))
        {
            err = DataModel::Decode(reader, state);
        }
        else if (__context_tag == to_underlying(Fields::kMaximumCurrent))
        {
            err = DataModel::Decode(reader, maximumCurrent);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace EnergyTransferStarted.
namespace EnergyTransferStopped {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSessionID), sessionID));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kState), state));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kReason), reason));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kEnergyTransferred), energyTransferred));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSessionID))
        {
            err = DataModel::Decode(reader, sessionID);
        }
        else if (__context_tag == to_underlying(Fields::kState))
        {
            err = DataModel::Decode(reader, state);
        }
        else if (__context_tag == to_underlying(Fields::kReason))
        {
            err = DataModel::Decode(reader, reason);
        }
        else if (__context_tag == to_underlying(Fields::kEnergyTransferred))
        {
            err = DataModel::Decode(reader, energyTransferred);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace EnergyTransferStopped.
namespace Fault {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSessionID), sessionID));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kState), state));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kFaultStatePreviousState), faultStatePreviousState));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kFaultStateCurrentState), faultStateCurrentState));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSessionID))
        {
            err = DataModel::Decode(reader, sessionID);
        }
        else if (__context_tag == to_underlying(Fields::kState))
        {
            err = DataModel::Decode(reader, state);
        }
        else if (__context_tag == to_underlying(Fields::kFaultStatePreviousState))
        {
            err = DataModel::Decode(reader, faultStatePreviousState);
        }
        else if (__context_tag == to_underlying(Fields::kFaultStateCurrentState))
        {
            err = DataModel::Decode(reader, faultStateCurrentState);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Fault.
namespace Rfid {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kUid), uid));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kUid))
        {
            err = DataModel::Decode(reader, uid);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Rfid.
} // namespace Events

} // namespace EnergyEvse
namespace EnergyPreference {
namespace Structs {

namespace BalanceStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStep), step);
    encoder.Encode(to_underlying(Fields::kLabel), label);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStep))
        {
            err = DataModel::Decode(reader, step);
        }
        else if (__context_tag == to_underlying(Fields::kLabel))
        {
            err = DataModel::Decode(reader, label);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace BalanceStruct
} // namespace Structs

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::EnergyBalances::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, energyBalances);
    case Attributes::CurrentEnergyBalance::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentEnergyBalance);
    case Attributes::EnergyPriorities::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, energyPriorities);
    case Attributes::LowPowerModeSensitivities::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lowPowerModeSensitivities);
    case Attributes::CurrentLowPowerModeSensitivity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentLowPowerModeSensitivity);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace EnergyPreference
namespace PowerTopology {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::AvailableEndpoints::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, availableEndpoints);
    case Attributes::ActiveEndpoints::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeEndpoints);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace PowerTopology
namespace EnergyEvseMode {
namespace Structs {} // namespace Structs

namespace Commands {
namespace ChangeToMode {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNewMode), newMode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNewMode))
        {
            err = DataModel::Decode(reader, newMode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToMode.
namespace ChangeToModeResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kStatusText), statusText);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kStatusText))
        {
            err = DataModel::Decode(reader, statusText);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToModeResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::SupportedModes::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedModes);
    case Attributes::CurrentMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentMode);
    case Attributes::StartUpMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, startUpMode);
    case Attributes::OnMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, onMode);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace EnergyEvseMode
namespace DeviceEnergyManagementMode {
namespace Structs {} // namespace Structs

namespace Commands {
namespace ChangeToMode {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNewMode), newMode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNewMode))
        {
            err = DataModel::Decode(reader, newMode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToMode.
namespace ChangeToModeResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kStatusText), statusText);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kStatusText))
        {
            err = DataModel::Decode(reader, statusText);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeToModeResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::SupportedModes::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedModes);
    case Attributes::CurrentMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentMode);
    case Attributes::StartUpMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, startUpMode);
    case Attributes::OnMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, onMode);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace DeviceEnergyManagementMode
namespace DoorLock {
namespace Structs {

namespace CredentialStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCredentialType), credentialType);
    encoder.Encode(to_underlying(Fields::kCredentialIndex), credentialIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCredentialType))
        {
            err = DataModel::Decode(reader, credentialType);
        }
        else if (__context_tag == to_underlying(Fields::kCredentialIndex))
        {
            err = DataModel::Decode(reader, credentialIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace CredentialStruct
} // namespace Structs

namespace Commands {
namespace LockDoor {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPINCode), PINCode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPINCode))
        {
            err = DataModel::Decode(reader, PINCode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace LockDoor.
namespace UnlockDoor {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPINCode), PINCode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPINCode))
        {
            err = DataModel::Decode(reader, PINCode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace UnlockDoor.
namespace UnlockWithTimeout {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTimeout), timeout);
    encoder.Encode(to_underlying(Fields::kPINCode), PINCode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTimeout))
        {
            err = DataModel::Decode(reader, timeout);
        }
        else if (__context_tag == to_underlying(Fields::kPINCode))
        {
            err = DataModel::Decode(reader, PINCode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace UnlockWithTimeout.
namespace SetWeekDaySchedule {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kWeekDayIndex), weekDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kDaysMask), daysMask);
    encoder.Encode(to_underlying(Fields::kStartHour), startHour);
    encoder.Encode(to_underlying(Fields::kStartMinute), startMinute);
    encoder.Encode(to_underlying(Fields::kEndHour), endHour);
    encoder.Encode(to_underlying(Fields::kEndMinute), endMinute);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kWeekDayIndex))
        {
            err = DataModel::Decode(reader, weekDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kDaysMask))
        {
            err = DataModel::Decode(reader, daysMask);
        }
        else if (__context_tag == to_underlying(Fields::kStartHour))
        {
            err = DataModel::Decode(reader, startHour);
        }
        else if (__context_tag == to_underlying(Fields::kStartMinute))
        {
            err = DataModel::Decode(reader, startMinute);
        }
        else if (__context_tag == to_underlying(Fields::kEndHour))
        {
            err = DataModel::Decode(reader, endHour);
        }
        else if (__context_tag == to_underlying(Fields::kEndMinute))
        {
            err = DataModel::Decode(reader, endMinute);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetWeekDaySchedule.
namespace GetWeekDaySchedule {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kWeekDayIndex), weekDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kWeekDayIndex))
        {
            err = DataModel::Decode(reader, weekDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetWeekDaySchedule.
namespace GetWeekDayScheduleResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kWeekDayIndex), weekDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kDaysMask), daysMask);
    encoder.Encode(to_underlying(Fields::kStartHour), startHour);
    encoder.Encode(to_underlying(Fields::kStartMinute), startMinute);
    encoder.Encode(to_underlying(Fields::kEndHour), endHour);
    encoder.Encode(to_underlying(Fields::kEndMinute), endMinute);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kWeekDayIndex))
        {
            err = DataModel::Decode(reader, weekDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kDaysMask))
        {
            err = DataModel::Decode(reader, daysMask);
        }
        else if (__context_tag == to_underlying(Fields::kStartHour))
        {
            err = DataModel::Decode(reader, startHour);
        }
        else if (__context_tag == to_underlying(Fields::kStartMinute))
        {
            err = DataModel::Decode(reader, startMinute);
        }
        else if (__context_tag == to_underlying(Fields::kEndHour))
        {
            err = DataModel::Decode(reader, endHour);
        }
        else if (__context_tag == to_underlying(Fields::kEndMinute))
        {
            err = DataModel::Decode(reader, endMinute);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetWeekDayScheduleResponse.
namespace ClearWeekDaySchedule {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kWeekDayIndex), weekDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kWeekDayIndex))
        {
            err = DataModel::Decode(reader, weekDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ClearWeekDaySchedule.
namespace SetYearDaySchedule {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kYearDayIndex), yearDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kLocalStartTime), localStartTime);
    encoder.Encode(to_underlying(Fields::kLocalEndTime), localEndTime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kYearDayIndex))
        {
            err = DataModel::Decode(reader, yearDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kLocalStartTime))
        {
            err = DataModel::Decode(reader, localStartTime);
        }
        else if (__context_tag == to_underlying(Fields::kLocalEndTime))
        {
            err = DataModel::Decode(reader, localEndTime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetYearDaySchedule.
namespace GetYearDaySchedule {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kYearDayIndex), yearDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kYearDayIndex))
        {
            err = DataModel::Decode(reader, yearDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetYearDaySchedule.
namespace GetYearDayScheduleResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kYearDayIndex), yearDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kLocalStartTime), localStartTime);
    encoder.Encode(to_underlying(Fields::kLocalEndTime), localEndTime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kYearDayIndex))
        {
            err = DataModel::Decode(reader, yearDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kLocalStartTime))
        {
            err = DataModel::Decode(reader, localStartTime);
        }
        else if (__context_tag == to_underlying(Fields::kLocalEndTime))
        {
            err = DataModel::Decode(reader, localEndTime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetYearDayScheduleResponse.
namespace ClearYearDaySchedule {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kYearDayIndex), yearDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kYearDayIndex))
        {
            err = DataModel::Decode(reader, yearDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ClearYearDaySchedule.
namespace SetHolidaySchedule {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kHolidayIndex), holidayIndex);
    encoder.Encode(to_underlying(Fields::kLocalStartTime), localStartTime);
    encoder.Encode(to_underlying(Fields::kLocalEndTime), localEndTime);
    encoder.Encode(to_underlying(Fields::kOperatingMode), operatingMode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kHolidayIndex))
        {
            err = DataModel::Decode(reader, holidayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kLocalStartTime))
        {
            err = DataModel::Decode(reader, localStartTime);
        }
        else if (__context_tag == to_underlying(Fields::kLocalEndTime))
        {
            err = DataModel::Decode(reader, localEndTime);
        }
        else if (__context_tag == to_underlying(Fields::kOperatingMode))
        {
            err = DataModel::Decode(reader, operatingMode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetHolidaySchedule.
namespace GetHolidaySchedule {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kHolidayIndex), holidayIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kHolidayIndex))
        {
            err = DataModel::Decode(reader, holidayIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetHolidaySchedule.
namespace GetHolidayScheduleResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kHolidayIndex), holidayIndex);
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kLocalStartTime), localStartTime);
    encoder.Encode(to_underlying(Fields::kLocalEndTime), localEndTime);
    encoder.Encode(to_underlying(Fields::kOperatingMode), operatingMode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kHolidayIndex))
        {
            err = DataModel::Decode(reader, holidayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kLocalStartTime))
        {
            err = DataModel::Decode(reader, localStartTime);
        }
        else if (__context_tag == to_underlying(Fields::kLocalEndTime))
        {
            err = DataModel::Decode(reader, localEndTime);
        }
        else if (__context_tag == to_underlying(Fields::kOperatingMode))
        {
            err = DataModel::Decode(reader, operatingMode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetHolidayScheduleResponse.
namespace ClearHolidaySchedule {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kHolidayIndex), holidayIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kHolidayIndex))
        {
            err = DataModel::Decode(reader, holidayIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ClearHolidaySchedule.
namespace SetUser {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOperationType), operationType);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kUserName), userName);
    encoder.Encode(to_underlying(Fields::kUserUniqueID), userUniqueID);
    encoder.Encode(to_underlying(Fields::kUserStatus), userStatus);
    encoder.Encode(to_underlying(Fields::kUserType), userType);
    encoder.Encode(to_underlying(Fields::kCredentialRule), credentialRule);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kOperationType))
        {
            err = DataModel::Decode(reader, operationType);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserName))
        {
            err = DataModel::Decode(reader, userName);
        }
        else if (__context_tag == to_underlying(Fields::kUserUniqueID))
        {
            err = DataModel::Decode(reader, userUniqueID);
        }
        else if (__context_tag == to_underlying(Fields::kUserStatus))
        {
            err = DataModel::Decode(reader, userStatus);
        }
        else if (__context_tag == to_underlying(Fields::kUserType))
        {
            err = DataModel::Decode(reader, userType);
        }
        else if (__context_tag == to_underlying(Fields::kCredentialRule))
        {
            err = DataModel::Decode(reader, credentialRule);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetUser.
namespace GetUser {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetUser.
namespace GetUserResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kUserName), userName);
    encoder.Encode(to_underlying(Fields::kUserUniqueID), userUniqueID);
    encoder.Encode(to_underlying(Fields::kUserStatus), userStatus);
    encoder.Encode(to_underlying(Fields::kUserType), userType);
    encoder.Encode(to_underlying(Fields::kCredentialRule), credentialRule);
    encoder.Encode(to_underlying(Fields::kCredentials), credentials);
    encoder.Encode(to_underlying(Fields::kCreatorFabricIndex), creatorFabricIndex);
    encoder.Encode(to_underlying(Fields::kLastModifiedFabricIndex), lastModifiedFabricIndex);
    encoder.Encode(to_underlying(Fields::kNextUserIndex), nextUserIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserName))
        {
            err = DataModel::Decode(reader, userName);
        }
        else if (__context_tag == to_underlying(Fields::kUserUniqueID))
        {
            err = DataModel::Decode(reader, userUniqueID);
        }
        else if (__context_tag == to_underlying(Fields::kUserStatus))
        {
            err = DataModel::Decode(reader, userStatus);
        }
        else if (__context_tag == to_underlying(Fields::kUserType))
        {
            err = DataModel::Decode(reader, userType);
        }
        else if (__context_tag == to_underlying(Fields::kCredentialRule))
        {
            err = DataModel::Decode(reader, credentialRule);
        }
        else if (__context_tag == to_underlying(Fields::kCredentials))
        {
            err = DataModel::Decode(reader, credentials);
        }
        else if (__context_tag == to_underlying(Fields::kCreatorFabricIndex))
        {
            err = DataModel::Decode(reader, creatorFabricIndex);
        }
        else if (__context_tag == to_underlying(Fields::kLastModifiedFabricIndex))
        {
            err = DataModel::Decode(reader, lastModifiedFabricIndex);
        }
        else if (__context_tag == to_underlying(Fields::kNextUserIndex))
        {
            err = DataModel::Decode(reader, nextUserIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetUserResponse.
namespace ClearUser {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ClearUser.
namespace SetCredential {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOperationType), operationType);
    encoder.Encode(to_underlying(Fields::kCredential), credential);
    encoder.Encode(to_underlying(Fields::kCredentialData), credentialData);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kUserStatus), userStatus);
    encoder.Encode(to_underlying(Fields::kUserType), userType);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kOperationType))
        {
            err = DataModel::Decode(reader, operationType);
        }
        else if (__context_tag == to_underlying(Fields::kCredential))
        {
            err = DataModel::Decode(reader, credential);
        }
        else if (__context_tag == to_underlying(Fields::kCredentialData))
        {
            err = DataModel::Decode(reader, credentialData);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserStatus))
        {
            err = DataModel::Decode(reader, userStatus);
        }
        else if (__context_tag == to_underlying(Fields::kUserType))
        {
            err = DataModel::Decode(reader, userType);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetCredential.
namespace SetCredentialResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kNextCredentialIndex), nextCredentialIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kNextCredentialIndex))
        {
            err = DataModel::Decode(reader, nextCredentialIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetCredentialResponse.
namespace GetCredentialStatus {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCredential), credential);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCredential))
        {
            err = DataModel::Decode(reader, credential);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetCredentialStatus.
namespace GetCredentialStatusResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCredentialExists), credentialExists);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kCreatorFabricIndex), creatorFabricIndex);
    encoder.Encode(to_underlying(Fields::kLastModifiedFabricIndex), lastModifiedFabricIndex);
    encoder.Encode(to_underlying(Fields::kNextCredentialIndex), nextCredentialIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCredentialExists))
        {
            err = DataModel::Decode(reader, credentialExists);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kCreatorFabricIndex))
        {
            err = DataModel::Decode(reader, creatorFabricIndex);
        }
        else if (__context_tag == to_underlying(Fields::kLastModifiedFabricIndex))
        {
            err = DataModel::Decode(reader, lastModifiedFabricIndex);
        }
        else if (__context_tag == to_underlying(Fields::kNextCredentialIndex))
        {
            err = DataModel::Decode(reader, nextCredentialIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetCredentialStatusResponse.
namespace ClearCredential {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCredential), credential);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCredential))
        {
            err = DataModel::Decode(reader, credential);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ClearCredential.
namespace UnboltDoor {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPINCode), PINCode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPINCode))
        {
            err = DataModel::Decode(reader, PINCode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace UnboltDoor.
namespace SetAliroReaderConfig {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kSigningKey), signingKey);
    encoder.Encode(to_underlying(Fields::kVerificationKey), verificationKey);
    encoder.Encode(to_underlying(Fields::kGroupIdentifier), groupIdentifier);
    encoder.Encode(to_underlying(Fields::kGroupResolvingKey), groupResolvingKey);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSigningKey))
        {
            err = DataModel::Decode(reader, signingKey);
        }
        else if (__context_tag == to_underlying(Fields::kVerificationKey))
        {
            err = DataModel::Decode(reader, verificationKey);
        }
        else if (__context_tag == to_underlying(Fields::kGroupIdentifier))
        {
            err = DataModel::Decode(reader, groupIdentifier);
        }
        else if (__context_tag == to_underlying(Fields::kGroupResolvingKey))
        {
            err = DataModel::Decode(reader, groupResolvingKey);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetAliroReaderConfig.
namespace ClearAliroReaderConfig {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ClearAliroReaderConfig.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::LockState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lockState);
    case Attributes::LockType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lockType);
    case Attributes::ActuatorEnabled::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, actuatorEnabled);
    case Attributes::DoorState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, doorState);
    case Attributes::DoorOpenEvents::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, doorOpenEvents);
    case Attributes::DoorClosedEvents::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, doorClosedEvents);
    case Attributes::OpenPeriod::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, openPeriod);
    case Attributes::NumberOfTotalUsersSupported::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfTotalUsersSupported);
    case Attributes::NumberOfPINUsersSupported::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfPINUsersSupported);
    case Attributes::NumberOfRFIDUsersSupported::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfRFIDUsersSupported);
    case Attributes::NumberOfWeekDaySchedulesSupportedPerUser::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfWeekDaySchedulesSupportedPerUser);
    case Attributes::NumberOfYearDaySchedulesSupportedPerUser::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfYearDaySchedulesSupportedPerUser);
    case Attributes::NumberOfHolidaySchedulesSupported::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfHolidaySchedulesSupported);
    case Attributes::MaxPINCodeLength::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxPINCodeLength);
    case Attributes::MinPINCodeLength::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minPINCodeLength);
    case Attributes::MaxRFIDCodeLength::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxRFIDCodeLength);
    case Attributes::MinRFIDCodeLength::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minRFIDCodeLength);
    case Attributes::CredentialRulesSupport::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, credentialRulesSupport);
    case Attributes::NumberOfCredentialsSupportedPerUser::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfCredentialsSupportedPerUser);
    case Attributes::Language::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, language);
    case Attributes::LEDSettings::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, LEDSettings);
    case Attributes::AutoRelockTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, autoRelockTime);
    case Attributes::SoundVolume::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, soundVolume);
    case Attributes::OperatingMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, operatingMode);
    case Attributes::SupportedOperatingModes::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedOperatingModes);
    case Attributes::DefaultConfigurationRegister::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, defaultConfigurationRegister);
    case Attributes::EnableLocalProgramming::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, enableLocalProgramming);
    case Attributes::EnableOneTouchLocking::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, enableOneTouchLocking);
    case Attributes::EnableInsideStatusLED::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, enableInsideStatusLED);
    case Attributes::EnablePrivacyModeButton::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, enablePrivacyModeButton);
    case Attributes::LocalProgrammingFeatures::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, localProgrammingFeatures);
    case Attributes::WrongCodeEntryLimit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, wrongCodeEntryLimit);
    case Attributes::UserCodeTemporaryDisableTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, userCodeTemporaryDisableTime);
    case Attributes::SendPINOverTheAir::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, sendPINOverTheAir);
    case Attributes::RequirePINforRemoteOperation::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, requirePINforRemoteOperation);
    case Attributes::ExpiringUserTimeout::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, expiringUserTimeout);
    case Attributes::AliroReaderVerificationKey::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, aliroReaderVerificationKey);
    case Attributes::AliroReaderGroupIdentifier::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, aliroReaderGroupIdentifier);
    case Attributes::AliroReaderGroupSubIdentifier::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, aliroReaderGroupSubIdentifier);
    case Attributes::AliroExpeditedTransactionSupportedProtocolVersions::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, aliroExpeditedTransactionSupportedProtocolVersions);
    case Attributes::AliroGroupResolvingKey::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, aliroGroupResolvingKey);
    case Attributes::AliroSupportedBLEUWBProtocolVersions::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, aliroSupportedBLEUWBProtocolVersions);
    case Attributes::AliroBLEAdvertisingVersion::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, aliroBLEAdvertisingVersion);
    case Attributes::NumberOfAliroCredentialIssuerKeysSupported::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfAliroCredentialIssuerKeysSupported);
    case Attributes::NumberOfAliroEndpointKeysSupported::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfAliroEndpointKeysSupported);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace DoorLockAlarm {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kAlarmCode), alarmCode));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAlarmCode))
        {
            err = DataModel::Decode(reader, alarmCode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace DoorLockAlarm.
namespace DoorStateChange {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kDoorState), doorState));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDoorState))
        {
            err = DataModel::Decode(reader, doorState);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace DoorStateChange.
namespace LockOperation {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kLockOperationType), lockOperationType));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kOperationSource), operationSource));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kUserIndex), userIndex));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kFabricIndex), fabricIndex));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSourceNode), sourceNode));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCredentials), credentials));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLockOperationType))
        {
            err = DataModel::Decode(reader, lockOperationType);
        }
        else if (__context_tag == to_underlying(Fields::kOperationSource))
        {
            err = DataModel::Decode(reader, operationSource);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else if (__context_tag == to_underlying(Fields::kSourceNode))
        {
            err = DataModel::Decode(reader, sourceNode);
        }
        else if (__context_tag == to_underlying(Fields::kCredentials))
        {
            err = DataModel::Decode(reader, credentials);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace LockOperation.
namespace LockOperationError {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kLockOperationType), lockOperationType));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kOperationSource), operationSource));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kOperationError), operationError));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kUserIndex), userIndex));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kFabricIndex), fabricIndex));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSourceNode), sourceNode));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCredentials), credentials));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLockOperationType))
        {
            err = DataModel::Decode(reader, lockOperationType);
        }
        else if (__context_tag == to_underlying(Fields::kOperationSource))
        {
            err = DataModel::Decode(reader, operationSource);
        }
        else if (__context_tag == to_underlying(Fields::kOperationError))
        {
            err = DataModel::Decode(reader, operationError);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else if (__context_tag == to_underlying(Fields::kSourceNode))
        {
            err = DataModel::Decode(reader, sourceNode);
        }
        else if (__context_tag == to_underlying(Fields::kCredentials))
        {
            err = DataModel::Decode(reader, credentials);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace LockOperationError.
namespace LockUserChange {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kLockDataType), lockDataType));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kDataOperationType), dataOperationType));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kOperationSource), operationSource));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kUserIndex), userIndex));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kFabricIndex), fabricIndex));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSourceNode), sourceNode));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kDataIndex), dataIndex));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLockDataType))
        {
            err = DataModel::Decode(reader, lockDataType);
        }
        else if (__context_tag == to_underlying(Fields::kDataOperationType))
        {
            err = DataModel::Decode(reader, dataOperationType);
        }
        else if (__context_tag == to_underlying(Fields::kOperationSource))
        {
            err = DataModel::Decode(reader, operationSource);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else if (__context_tag == to_underlying(Fields::kSourceNode))
        {
            err = DataModel::Decode(reader, sourceNode);
        }
        else if (__context_tag == to_underlying(Fields::kDataIndex))
        {
            err = DataModel::Decode(reader, dataIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace LockUserChange.
} // namespace Events

} // namespace DoorLock
namespace WindowCovering {

namespace Commands {
namespace UpOrOpen {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace UpOrOpen.
namespace DownOrClose {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace DownOrClose.
namespace StopMotion {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace StopMotion.
namespace GoToLiftValue {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLiftValue), liftValue);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLiftValue))
        {
            err = DataModel::Decode(reader, liftValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GoToLiftValue.
namespace GoToLiftPercentage {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLiftPercent100thsValue), liftPercent100thsValue);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLiftPercent100thsValue))
        {
            err = DataModel::Decode(reader, liftPercent100thsValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GoToLiftPercentage.
namespace GoToTiltValue {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTiltValue), tiltValue);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTiltValue))
        {
            err = DataModel::Decode(reader, tiltValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GoToTiltValue.
namespace GoToTiltPercentage {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTiltPercent100thsValue), tiltPercent100thsValue);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTiltPercent100thsValue))
        {
            err = DataModel::Decode(reader, tiltPercent100thsValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GoToTiltPercentage.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Type::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, type);
    case Attributes::PhysicalClosedLimitLift::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, physicalClosedLimitLift);
    case Attributes::PhysicalClosedLimitTilt::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, physicalClosedLimitTilt);
    case Attributes::CurrentPositionLift::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentPositionLift);
    case Attributes::CurrentPositionTilt::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentPositionTilt);
    case Attributes::NumberOfActuationsLift::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfActuationsLift);
    case Attributes::NumberOfActuationsTilt::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfActuationsTilt);
    case Attributes::ConfigStatus::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, configStatus);
    case Attributes::CurrentPositionLiftPercentage::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentPositionLiftPercentage);
    case Attributes::CurrentPositionTiltPercentage::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentPositionTiltPercentage);
    case Attributes::OperationalStatus::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, operationalStatus);
    case Attributes::TargetPositionLiftPercent100ths::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, targetPositionLiftPercent100ths);
    case Attributes::TargetPositionTiltPercent100ths::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, targetPositionTiltPercent100ths);
    case Attributes::EndProductType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, endProductType);
    case Attributes::CurrentPositionLiftPercent100ths::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentPositionLiftPercent100ths);
    case Attributes::CurrentPositionTiltPercent100ths::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentPositionTiltPercent100ths);
    case Attributes::InstalledOpenLimitLift::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, installedOpenLimitLift);
    case Attributes::InstalledClosedLimitLift::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, installedClosedLimitLift);
    case Attributes::InstalledOpenLimitTilt::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, installedOpenLimitTilt);
    case Attributes::InstalledClosedLimitTilt::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, installedClosedLimitTilt);
    case Attributes::Mode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, mode);
    case Attributes::SafetyStatus::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, safetyStatus);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace WindowCovering
namespace BarrierControl {

namespace Commands {
namespace BarrierControlGoToPercent {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPercentOpen), percentOpen);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPercentOpen))
        {
            err = DataModel::Decode(reader, percentOpen);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace BarrierControlGoToPercent.
namespace BarrierControlStop {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace BarrierControlStop.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::BarrierMovingState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, barrierMovingState);
    case Attributes::BarrierSafetyStatus::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, barrierSafetyStatus);
    case Attributes::BarrierCapabilities::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, barrierCapabilities);
    case Attributes::BarrierOpenEvents::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, barrierOpenEvents);
    case Attributes::BarrierCloseEvents::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, barrierCloseEvents);
    case Attributes::BarrierCommandOpenEvents::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, barrierCommandOpenEvents);
    case Attributes::BarrierCommandCloseEvents::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, barrierCommandCloseEvents);
    case Attributes::BarrierOpenPeriod::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, barrierOpenPeriod);
    case Attributes::BarrierClosePeriod::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, barrierClosePeriod);
    case Attributes::BarrierPosition::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, barrierPosition);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace BarrierControl
namespace PumpConfigurationAndControl {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MaxPressure::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxPressure);
    case Attributes::MaxSpeed::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxSpeed);
    case Attributes::MaxFlow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxFlow);
    case Attributes::MinConstPressure::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minConstPressure);
    case Attributes::MaxConstPressure::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxConstPressure);
    case Attributes::MinCompPressure::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minCompPressure);
    case Attributes::MaxCompPressure::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxCompPressure);
    case Attributes::MinConstSpeed::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minConstSpeed);
    case Attributes::MaxConstSpeed::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxConstSpeed);
    case Attributes::MinConstFlow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minConstFlow);
    case Attributes::MaxConstFlow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxConstFlow);
    case Attributes::MinConstTemp::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minConstTemp);
    case Attributes::MaxConstTemp::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxConstTemp);
    case Attributes::PumpStatus::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, pumpStatus);
    case Attributes::EffectiveOperationMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, effectiveOperationMode);
    case Attributes::EffectiveControlMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, effectiveControlMode);
    case Attributes::Capacity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, capacity);
    case Attributes::Speed::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, speed);
    case Attributes::LifetimeRunningHours::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lifetimeRunningHours);
    case Attributes::Power::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, power);
    case Attributes::LifetimeEnergyConsumed::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lifetimeEnergyConsumed);
    case Attributes::OperationMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, operationMode);
    case Attributes::ControlMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, controlMode);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace SupplyVoltageLow {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace SupplyVoltageLow.
namespace SupplyVoltageHigh {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace SupplyVoltageHigh.
namespace PowerMissingPhase {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace PowerMissingPhase.
namespace SystemPressureLow {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace SystemPressureLow.
namespace SystemPressureHigh {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace SystemPressureHigh.
namespace DryRunning {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace DryRunning.
namespace MotorTemperatureHigh {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace MotorTemperatureHigh.
namespace PumpMotorFatalFailure {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace PumpMotorFatalFailure.
namespace ElectronicTemperatureHigh {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ElectronicTemperatureHigh.
namespace PumpBlocked {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace PumpBlocked.
namespace SensorFailure {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace SensorFailure.
namespace ElectronicNonFatalFailure {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ElectronicNonFatalFailure.
namespace ElectronicFatalFailure {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ElectronicFatalFailure.
namespace GeneralFault {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace GeneralFault.
namespace Leakage {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Leakage.
namespace AirDetection {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace AirDetection.
namespace TurbineOperation {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace TurbineOperation.
} // namespace Events

} // namespace PumpConfigurationAndControl
namespace Thermostat {
namespace Structs {

namespace ScheduleTransitionStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kDayOfWeek), dayOfWeek);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kPresetHandle), presetHandle);
    encoder.Encode(to_underlying(Fields::kSystemMode), systemMode);
    encoder.Encode(to_underlying(Fields::kCoolingSetpoint), coolingSetpoint);
    encoder.Encode(to_underlying(Fields::kHeatingSetpoint), heatingSetpoint);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDayOfWeek))
        {
            err = DataModel::Decode(reader, dayOfWeek);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kPresetHandle))
        {
            err = DataModel::Decode(reader, presetHandle);
        }
        else if (__context_tag == to_underlying(Fields::kSystemMode))
        {
            err = DataModel::Decode(reader, systemMode);
        }
        else if (__context_tag == to_underlying(Fields::kCoolingSetpoint))
        {
            err = DataModel::Decode(reader, coolingSetpoint);
        }
        else if (__context_tag == to_underlying(Fields::kHeatingSetpoint))
        {
            err = DataModel::Decode(reader, heatingSetpoint);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ScheduleTransitionStruct

namespace ScheduleStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kScheduleHandle), scheduleHandle);
    encoder.Encode(to_underlying(Fields::kSystemMode), systemMode);
    encoder.Encode(to_underlying(Fields::kName), name);
    encoder.Encode(to_underlying(Fields::kPresetHandle), presetHandle);
    encoder.Encode(to_underlying(Fields::kTransitions), transitions);
    encoder.Encode(to_underlying(Fields::kBuiltIn), builtIn);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kScheduleHandle))
        {
            err = DataModel::Decode(reader, scheduleHandle);
        }
        else if (__context_tag == to_underlying(Fields::kSystemMode))
        {
            err = DataModel::Decode(reader, systemMode);
        }
        else if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else if (__context_tag == to_underlying(Fields::kPresetHandle))
        {
            err = DataModel::Decode(reader, presetHandle);
        }
        else if (__context_tag == to_underlying(Fields::kTransitions))
        {
            err = DataModel::Decode(reader, transitions);
        }
        else if (__context_tag == to_underlying(Fields::kBuiltIn))
        {
            err = DataModel::Decode(reader, builtIn);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ScheduleStruct

namespace PresetStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPresetHandle), presetHandle);
    encoder.Encode(to_underlying(Fields::kPresetScenario), presetScenario);
    encoder.Encode(to_underlying(Fields::kName), name);
    encoder.Encode(to_underlying(Fields::kCoolingSetpoint), coolingSetpoint);
    encoder.Encode(to_underlying(Fields::kHeatingSetpoint), heatingSetpoint);
    encoder.Encode(to_underlying(Fields::kBuiltIn), builtIn);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPresetHandle))
        {
            err = DataModel::Decode(reader, presetHandle);
        }
        else if (__context_tag == to_underlying(Fields::kPresetScenario))
        {
            err = DataModel::Decode(reader, presetScenario);
        }
        else if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else if (__context_tag == to_underlying(Fields::kCoolingSetpoint))
        {
            err = DataModel::Decode(reader, coolingSetpoint);
        }
        else if (__context_tag == to_underlying(Fields::kHeatingSetpoint))
        {
            err = DataModel::Decode(reader, heatingSetpoint);
        }
        else if (__context_tag == to_underlying(Fields::kBuiltIn))
        {
            err = DataModel::Decode(reader, builtIn);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace PresetStruct

namespace PresetTypeStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPresetScenario), presetScenario);
    encoder.Encode(to_underlying(Fields::kNumberOfPresets), numberOfPresets);
    encoder.Encode(to_underlying(Fields::kPresetTypeFeatures), presetTypeFeatures);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPresetScenario))
        {
            err = DataModel::Decode(reader, presetScenario);
        }
        else if (__context_tag == to_underlying(Fields::kNumberOfPresets))
        {
            err = DataModel::Decode(reader, numberOfPresets);
        }
        else if (__context_tag == to_underlying(Fields::kPresetTypeFeatures))
        {
            err = DataModel::Decode(reader, presetTypeFeatures);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace PresetTypeStruct

namespace QueuedPresetStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPresetHandle), presetHandle);
    encoder.Encode(to_underlying(Fields::kTransitionTimestamp), transitionTimestamp);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPresetHandle))
        {
            err = DataModel::Decode(reader, presetHandle);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTimestamp))
        {
            err = DataModel::Decode(reader, transitionTimestamp);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace QueuedPresetStruct

namespace ScheduleTypeStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kSystemMode), systemMode);
    encoder.Encode(to_underlying(Fields::kNumberOfSchedules), numberOfSchedules);
    encoder.Encode(to_underlying(Fields::kScheduleTypeFeatures), scheduleTypeFeatures);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSystemMode))
        {
            err = DataModel::Decode(reader, systemMode);
        }
        else if (__context_tag == to_underlying(Fields::kNumberOfSchedules))
        {
            err = DataModel::Decode(reader, numberOfSchedules);
        }
        else if (__context_tag == to_underlying(Fields::kScheduleTypeFeatures))
        {
            err = DataModel::Decode(reader, scheduleTypeFeatures);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ScheduleTypeStruct

namespace WeeklyScheduleTransitionStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kHeatSetpoint), heatSetpoint);
    encoder.Encode(to_underlying(Fields::kCoolSetpoint), coolSetpoint);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kHeatSetpoint))
        {
            err = DataModel::Decode(reader, heatSetpoint);
        }
        else if (__context_tag == to_underlying(Fields::kCoolSetpoint))
        {
            err = DataModel::Decode(reader, coolSetpoint);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace WeeklyScheduleTransitionStruct
} // namespace Structs

namespace Commands {
namespace SetpointRaiseLower {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMode), mode);
    encoder.Encode(to_underlying(Fields::kAmount), amount);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMode))
        {
            err = DataModel::Decode(reader, mode);
        }
        else if (__context_tag == to_underlying(Fields::kAmount))
        {
            err = DataModel::Decode(reader, amount);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetpointRaiseLower.
namespace GetWeeklyScheduleResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNumberOfTransitionsForSequence), numberOfTransitionsForSequence);
    encoder.Encode(to_underlying(Fields::kDayOfWeekForSequence), dayOfWeekForSequence);
    encoder.Encode(to_underlying(Fields::kModeForSequence), modeForSequence);
    encoder.Encode(to_underlying(Fields::kTransitions), transitions);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNumberOfTransitionsForSequence))
        {
            err = DataModel::Decode(reader, numberOfTransitionsForSequence);
        }
        else if (__context_tag == to_underlying(Fields::kDayOfWeekForSequence))
        {
            err = DataModel::Decode(reader, dayOfWeekForSequence);
        }
        else if (__context_tag == to_underlying(Fields::kModeForSequence))
        {
            err = DataModel::Decode(reader, modeForSequence);
        }
        else if (__context_tag == to_underlying(Fields::kTransitions))
        {
            err = DataModel::Decode(reader, transitions);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetWeeklyScheduleResponse.
namespace SetWeeklySchedule {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNumberOfTransitionsForSequence), numberOfTransitionsForSequence);
    encoder.Encode(to_underlying(Fields::kDayOfWeekForSequence), dayOfWeekForSequence);
    encoder.Encode(to_underlying(Fields::kModeForSequence), modeForSequence);
    encoder.Encode(to_underlying(Fields::kTransitions), transitions);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNumberOfTransitionsForSequence))
        {
            err = DataModel::Decode(reader, numberOfTransitionsForSequence);
        }
        else if (__context_tag == to_underlying(Fields::kDayOfWeekForSequence))
        {
            err = DataModel::Decode(reader, dayOfWeekForSequence);
        }
        else if (__context_tag == to_underlying(Fields::kModeForSequence))
        {
            err = DataModel::Decode(reader, modeForSequence);
        }
        else if (__context_tag == to_underlying(Fields::kTransitions))
        {
            err = DataModel::Decode(reader, transitions);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetWeeklySchedule.
namespace GetWeeklySchedule {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kDaysToReturn), daysToReturn);
    encoder.Encode(to_underlying(Fields::kModeToReturn), modeToReturn);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDaysToReturn))
        {
            err = DataModel::Decode(reader, daysToReturn);
        }
        else if (__context_tag == to_underlying(Fields::kModeToReturn))
        {
            err = DataModel::Decode(reader, modeToReturn);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetWeeklySchedule.
namespace ClearWeeklySchedule {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ClearWeeklySchedule.
namespace SetActiveScheduleRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kScheduleHandle), scheduleHandle);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kScheduleHandle))
        {
            err = DataModel::Decode(reader, scheduleHandle);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetActiveScheduleRequest.
namespace SetActivePresetRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPresetHandle), presetHandle);
    encoder.Encode(to_underlying(Fields::kDelayMinutes), delayMinutes);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPresetHandle))
        {
            err = DataModel::Decode(reader, presetHandle);
        }
        else if (__context_tag == to_underlying(Fields::kDelayMinutes))
        {
            err = DataModel::Decode(reader, delayMinutes);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetActivePresetRequest.
namespace StartPresetsSchedulesEditRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTimeoutSeconds), timeoutSeconds);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTimeoutSeconds))
        {
            err = DataModel::Decode(reader, timeoutSeconds);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StartPresetsSchedulesEditRequest.
namespace CancelPresetsSchedulesEditRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace CancelPresetsSchedulesEditRequest.
namespace CommitPresetsSchedulesRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace CommitPresetsSchedulesRequest.
namespace CancelSetActivePresetRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace CancelSetActivePresetRequest.
namespace SetTemperatureSetpointHoldPolicy {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTemperatureSetpointHoldPolicy), temperatureSetpointHoldPolicy);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTemperatureSetpointHoldPolicy))
        {
            err = DataModel::Decode(reader, temperatureSetpointHoldPolicy);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetTemperatureSetpointHoldPolicy.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::LocalTemperature::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, localTemperature);
    case Attributes::OutdoorTemperature::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, outdoorTemperature);
    case Attributes::Occupancy::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, occupancy);
    case Attributes::AbsMinHeatSetpointLimit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, absMinHeatSetpointLimit);
    case Attributes::AbsMaxHeatSetpointLimit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, absMaxHeatSetpointLimit);
    case Attributes::AbsMinCoolSetpointLimit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, absMinCoolSetpointLimit);
    case Attributes::AbsMaxCoolSetpointLimit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, absMaxCoolSetpointLimit);
    case Attributes::PICoolingDemand::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, PICoolingDemand);
    case Attributes::PIHeatingDemand::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, PIHeatingDemand);
    case Attributes::HVACSystemTypeConfiguration::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, HVACSystemTypeConfiguration);
    case Attributes::LocalTemperatureCalibration::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, localTemperatureCalibration);
    case Attributes::OccupiedCoolingSetpoint::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, occupiedCoolingSetpoint);
    case Attributes::OccupiedHeatingSetpoint::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, occupiedHeatingSetpoint);
    case Attributes::UnoccupiedCoolingSetpoint::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, unoccupiedCoolingSetpoint);
    case Attributes::UnoccupiedHeatingSetpoint::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, unoccupiedHeatingSetpoint);
    case Attributes::MinHeatSetpointLimit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minHeatSetpointLimit);
    case Attributes::MaxHeatSetpointLimit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxHeatSetpointLimit);
    case Attributes::MinCoolSetpointLimit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minCoolSetpointLimit);
    case Attributes::MaxCoolSetpointLimit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxCoolSetpointLimit);
    case Attributes::MinSetpointDeadBand::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minSetpointDeadBand);
    case Attributes::RemoteSensing::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, remoteSensing);
    case Attributes::ControlSequenceOfOperation::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, controlSequenceOfOperation);
    case Attributes::SystemMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, systemMode);
    case Attributes::ThermostatRunningMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, thermostatRunningMode);
    case Attributes::StartOfWeek::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, startOfWeek);
    case Attributes::NumberOfWeeklyTransitions::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfWeeklyTransitions);
    case Attributes::NumberOfDailyTransitions::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfDailyTransitions);
    case Attributes::TemperatureSetpointHold::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, temperatureSetpointHold);
    case Attributes::TemperatureSetpointHoldDuration::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, temperatureSetpointHoldDuration);
    case Attributes::ThermostatProgrammingOperationMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, thermostatProgrammingOperationMode);
    case Attributes::ThermostatRunningState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, thermostatRunningState);
    case Attributes::SetpointChangeSource::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, setpointChangeSource);
    case Attributes::SetpointChangeAmount::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, setpointChangeAmount);
    case Attributes::SetpointChangeSourceTimestamp::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, setpointChangeSourceTimestamp);
    case Attributes::OccupiedSetback::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, occupiedSetback);
    case Attributes::OccupiedSetbackMin::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, occupiedSetbackMin);
    case Attributes::OccupiedSetbackMax::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, occupiedSetbackMax);
    case Attributes::UnoccupiedSetback::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, unoccupiedSetback);
    case Attributes::UnoccupiedSetbackMin::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, unoccupiedSetbackMin);
    case Attributes::UnoccupiedSetbackMax::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, unoccupiedSetbackMax);
    case Attributes::EmergencyHeatDelta::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, emergencyHeatDelta);
    case Attributes::ACType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ACType);
    case Attributes::ACCapacity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ACCapacity);
    case Attributes::ACRefrigerantType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ACRefrigerantType);
    case Attributes::ACCompressorType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ACCompressorType);
    case Attributes::ACErrorCode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ACErrorCode);
    case Attributes::ACLouverPosition::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ACLouverPosition);
    case Attributes::ACCoilTemperature::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ACCoilTemperature);
    case Attributes::ACCapacityformat::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ACCapacityformat);
    case Attributes::PresetTypes::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, presetTypes);
    case Attributes::ScheduleTypes::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, scheduleTypes);
    case Attributes::NumberOfPresets::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfPresets);
    case Attributes::NumberOfSchedules::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfSchedules);
    case Attributes::NumberOfScheduleTransitions::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfScheduleTransitions);
    case Attributes::NumberOfScheduleTransitionPerDay::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfScheduleTransitionPerDay);
    case Attributes::ActivePresetHandle::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activePresetHandle);
    case Attributes::ActiveScheduleHandle::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeScheduleHandle);
    case Attributes::Presets::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, presets);
    case Attributes::Schedules::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, schedules);
    case Attributes::PresetsSchedulesEditable::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, presetsSchedulesEditable);
    case Attributes::TemperatureSetpointHoldPolicy::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, temperatureSetpointHoldPolicy);
    case Attributes::SetpointHoldExpiryTimestamp::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, setpointHoldExpiryTimestamp);
    case Attributes::QueuedPreset::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, queuedPreset);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace Thermostat
namespace FanControl {

namespace Commands {
namespace Step {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kDirection), direction);
    encoder.Encode(to_underlying(Fields::kWrap), wrap);
    encoder.Encode(to_underlying(Fields::kLowestOff), lowestOff);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDirection))
        {
            err = DataModel::Decode(reader, direction);
        }
        else if (__context_tag == to_underlying(Fields::kWrap))
        {
            err = DataModel::Decode(reader, wrap);
        }
        else if (__context_tag == to_underlying(Fields::kLowestOff))
        {
            err = DataModel::Decode(reader, lowestOff);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Step.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::FanMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, fanMode);
    case Attributes::FanModeSequence::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, fanModeSequence);
    case Attributes::PercentSetting::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, percentSetting);
    case Attributes::PercentCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, percentCurrent);
    case Attributes::SpeedMax::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, speedMax);
    case Attributes::SpeedSetting::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, speedSetting);
    case Attributes::SpeedCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, speedCurrent);
    case Attributes::RockSupport::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rockSupport);
    case Attributes::RockSetting::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rockSetting);
    case Attributes::WindSupport::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, windSupport);
    case Attributes::WindSetting::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, windSetting);
    case Attributes::AirflowDirection::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, airflowDirection);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace FanControl
namespace ThermostatUserInterfaceConfiguration {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::TemperatureDisplayMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, temperatureDisplayMode);
    case Attributes::KeypadLockout::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, keypadLockout);
    case Attributes::ScheduleProgrammingVisibility::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, scheduleProgrammingVisibility);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace ThermostatUserInterfaceConfiguration
namespace ColorControl {

namespace Commands {
namespace MoveToHue {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kHue), hue);
    encoder.Encode(to_underlying(Fields::kDirection), direction);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kHue))
        {
            err = DataModel::Decode(reader, hue);
        }
        else if (__context_tag == to_underlying(Fields::kDirection))
        {
            err = DataModel::Decode(reader, direction);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MoveToHue.
namespace MoveHue {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMoveMode), moveMode);
    encoder.Encode(to_underlying(Fields::kRate), rate);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMoveMode))
        {
            err = DataModel::Decode(reader, moveMode);
        }
        else if (__context_tag == to_underlying(Fields::kRate))
        {
            err = DataModel::Decode(reader, rate);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MoveHue.
namespace StepHue {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStepMode), stepMode);
    encoder.Encode(to_underlying(Fields::kStepSize), stepSize);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStepMode))
        {
            err = DataModel::Decode(reader, stepMode);
        }
        else if (__context_tag == to_underlying(Fields::kStepSize))
        {
            err = DataModel::Decode(reader, stepSize);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StepHue.
namespace MoveToSaturation {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kSaturation), saturation);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSaturation))
        {
            err = DataModel::Decode(reader, saturation);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MoveToSaturation.
namespace MoveSaturation {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMoveMode), moveMode);
    encoder.Encode(to_underlying(Fields::kRate), rate);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMoveMode))
        {
            err = DataModel::Decode(reader, moveMode);
        }
        else if (__context_tag == to_underlying(Fields::kRate))
        {
            err = DataModel::Decode(reader, rate);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MoveSaturation.
namespace StepSaturation {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStepMode), stepMode);
    encoder.Encode(to_underlying(Fields::kStepSize), stepSize);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStepMode))
        {
            err = DataModel::Decode(reader, stepMode);
        }
        else if (__context_tag == to_underlying(Fields::kStepSize))
        {
            err = DataModel::Decode(reader, stepSize);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StepSaturation.
namespace MoveToHueAndSaturation {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kHue), hue);
    encoder.Encode(to_underlying(Fields::kSaturation), saturation);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kHue))
        {
            err = DataModel::Decode(reader, hue);
        }
        else if (__context_tag == to_underlying(Fields::kSaturation))
        {
            err = DataModel::Decode(reader, saturation);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MoveToHueAndSaturation.
namespace MoveToColor {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kColorX), colorX);
    encoder.Encode(to_underlying(Fields::kColorY), colorY);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kColorX))
        {
            err = DataModel::Decode(reader, colorX);
        }
        else if (__context_tag == to_underlying(Fields::kColorY))
        {
            err = DataModel::Decode(reader, colorY);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MoveToColor.
namespace MoveColor {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kRateX), rateX);
    encoder.Encode(to_underlying(Fields::kRateY), rateY);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kRateX))
        {
            err = DataModel::Decode(reader, rateX);
        }
        else if (__context_tag == to_underlying(Fields::kRateY))
        {
            err = DataModel::Decode(reader, rateY);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MoveColor.
namespace StepColor {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStepX), stepX);
    encoder.Encode(to_underlying(Fields::kStepY), stepY);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStepX))
        {
            err = DataModel::Decode(reader, stepX);
        }
        else if (__context_tag == to_underlying(Fields::kStepY))
        {
            err = DataModel::Decode(reader, stepY);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StepColor.
namespace MoveToColorTemperature {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kColorTemperatureMireds), colorTemperatureMireds);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kColorTemperatureMireds))
        {
            err = DataModel::Decode(reader, colorTemperatureMireds);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MoveToColorTemperature.
namespace EnhancedMoveToHue {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kEnhancedHue), enhancedHue);
    encoder.Encode(to_underlying(Fields::kDirection), direction);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kEnhancedHue))
        {
            err = DataModel::Decode(reader, enhancedHue);
        }
        else if (__context_tag == to_underlying(Fields::kDirection))
        {
            err = DataModel::Decode(reader, direction);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace EnhancedMoveToHue.
namespace EnhancedMoveHue {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMoveMode), moveMode);
    encoder.Encode(to_underlying(Fields::kRate), rate);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMoveMode))
        {
            err = DataModel::Decode(reader, moveMode);
        }
        else if (__context_tag == to_underlying(Fields::kRate))
        {
            err = DataModel::Decode(reader, rate);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace EnhancedMoveHue.
namespace EnhancedStepHue {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStepMode), stepMode);
    encoder.Encode(to_underlying(Fields::kStepSize), stepSize);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStepMode))
        {
            err = DataModel::Decode(reader, stepMode);
        }
        else if (__context_tag == to_underlying(Fields::kStepSize))
        {
            err = DataModel::Decode(reader, stepSize);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace EnhancedStepHue.
namespace EnhancedMoveToHueAndSaturation {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kEnhancedHue), enhancedHue);
    encoder.Encode(to_underlying(Fields::kSaturation), saturation);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kEnhancedHue))
        {
            err = DataModel::Decode(reader, enhancedHue);
        }
        else if (__context_tag == to_underlying(Fields::kSaturation))
        {
            err = DataModel::Decode(reader, saturation);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace EnhancedMoveToHueAndSaturation.
namespace ColorLoopSet {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kUpdateFlags), updateFlags);
    encoder.Encode(to_underlying(Fields::kAction), action);
    encoder.Encode(to_underlying(Fields::kDirection), direction);
    encoder.Encode(to_underlying(Fields::kTime), time);
    encoder.Encode(to_underlying(Fields::kStartHue), startHue);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kUpdateFlags))
        {
            err = DataModel::Decode(reader, updateFlags);
        }
        else if (__context_tag == to_underlying(Fields::kAction))
        {
            err = DataModel::Decode(reader, action);
        }
        else if (__context_tag == to_underlying(Fields::kDirection))
        {
            err = DataModel::Decode(reader, direction);
        }
        else if (__context_tag == to_underlying(Fields::kTime))
        {
            err = DataModel::Decode(reader, time);
        }
        else if (__context_tag == to_underlying(Fields::kStartHue))
        {
            err = DataModel::Decode(reader, startHue);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ColorLoopSet.
namespace StopMoveStep {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StopMoveStep.
namespace MoveColorTemperature {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMoveMode), moveMode);
    encoder.Encode(to_underlying(Fields::kRate), rate);
    encoder.Encode(to_underlying(Fields::kColorTemperatureMinimumMireds), colorTemperatureMinimumMireds);
    encoder.Encode(to_underlying(Fields::kColorTemperatureMaximumMireds), colorTemperatureMaximumMireds);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMoveMode))
        {
            err = DataModel::Decode(reader, moveMode);
        }
        else if (__context_tag == to_underlying(Fields::kRate))
        {
            err = DataModel::Decode(reader, rate);
        }
        else if (__context_tag == to_underlying(Fields::kColorTemperatureMinimumMireds))
        {
            err = DataModel::Decode(reader, colorTemperatureMinimumMireds);
        }
        else if (__context_tag == to_underlying(Fields::kColorTemperatureMaximumMireds))
        {
            err = DataModel::Decode(reader, colorTemperatureMaximumMireds);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace MoveColorTemperature.
namespace StepColorTemperature {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStepMode), stepMode);
    encoder.Encode(to_underlying(Fields::kStepSize), stepSize);
    encoder.Encode(to_underlying(Fields::kTransitionTime), transitionTime);
    encoder.Encode(to_underlying(Fields::kColorTemperatureMinimumMireds), colorTemperatureMinimumMireds);
    encoder.Encode(to_underlying(Fields::kColorTemperatureMaximumMireds), colorTemperatureMaximumMireds);
    encoder.Encode(to_underlying(Fields::kOptionsMask), optionsMask);
    encoder.Encode(to_underlying(Fields::kOptionsOverride), optionsOverride);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStepMode))
        {
            err = DataModel::Decode(reader, stepMode);
        }
        else if (__context_tag == to_underlying(Fields::kStepSize))
        {
            err = DataModel::Decode(reader, stepSize);
        }
        else if (__context_tag == to_underlying(Fields::kTransitionTime))
        {
            err = DataModel::Decode(reader, transitionTime);
        }
        else if (__context_tag == to_underlying(Fields::kColorTemperatureMinimumMireds))
        {
            err = DataModel::Decode(reader, colorTemperatureMinimumMireds);
        }
        else if (__context_tag == to_underlying(Fields::kColorTemperatureMaximumMireds))
        {
            err = DataModel::Decode(reader, colorTemperatureMaximumMireds);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsMask))
        {
            err = DataModel::Decode(reader, optionsMask);
        }
        else if (__context_tag == to_underlying(Fields::kOptionsOverride))
        {
            err = DataModel::Decode(reader, optionsOverride);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StepColorTemperature.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::CurrentHue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentHue);
    case Attributes::CurrentSaturation::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentSaturation);
    case Attributes::RemainingTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, remainingTime);
    case Attributes::CurrentX::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentX);
    case Attributes::CurrentY::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentY);
    case Attributes::DriftCompensation::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, driftCompensation);
    case Attributes::CompensationText::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, compensationText);
    case Attributes::ColorTemperatureMireds::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorTemperatureMireds);
    case Attributes::ColorMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorMode);
    case Attributes::Options::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, options);
    case Attributes::NumberOfPrimaries::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, numberOfPrimaries);
    case Attributes::Primary1X::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary1X);
    case Attributes::Primary1Y::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary1Y);
    case Attributes::Primary1Intensity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary1Intensity);
    case Attributes::Primary2X::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary2X);
    case Attributes::Primary2Y::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary2Y);
    case Attributes::Primary2Intensity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary2Intensity);
    case Attributes::Primary3X::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary3X);
    case Attributes::Primary3Y::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary3Y);
    case Attributes::Primary3Intensity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary3Intensity);
    case Attributes::Primary4X::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary4X);
    case Attributes::Primary4Y::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary4Y);
    case Attributes::Primary4Intensity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary4Intensity);
    case Attributes::Primary5X::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary5X);
    case Attributes::Primary5Y::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary5Y);
    case Attributes::Primary5Intensity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary5Intensity);
    case Attributes::Primary6X::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary6X);
    case Attributes::Primary6Y::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary6Y);
    case Attributes::Primary6Intensity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, primary6Intensity);
    case Attributes::WhitePointX::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, whitePointX);
    case Attributes::WhitePointY::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, whitePointY);
    case Attributes::ColorPointRX::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorPointRX);
    case Attributes::ColorPointRY::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorPointRY);
    case Attributes::ColorPointRIntensity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorPointRIntensity);
    case Attributes::ColorPointGX::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorPointGX);
    case Attributes::ColorPointGY::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorPointGY);
    case Attributes::ColorPointGIntensity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorPointGIntensity);
    case Attributes::ColorPointBX::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorPointBX);
    case Attributes::ColorPointBY::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorPointBY);
    case Attributes::ColorPointBIntensity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorPointBIntensity);
    case Attributes::EnhancedCurrentHue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, enhancedCurrentHue);
    case Attributes::EnhancedColorMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, enhancedColorMode);
    case Attributes::ColorLoopActive::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorLoopActive);
    case Attributes::ColorLoopDirection::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorLoopDirection);
    case Attributes::ColorLoopTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorLoopTime);
    case Attributes::ColorLoopStartEnhancedHue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorLoopStartEnhancedHue);
    case Attributes::ColorLoopStoredEnhancedHue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorLoopStoredEnhancedHue);
    case Attributes::ColorCapabilities::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorCapabilities);
    case Attributes::ColorTempPhysicalMinMireds::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorTempPhysicalMinMireds);
    case Attributes::ColorTempPhysicalMaxMireds::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, colorTempPhysicalMaxMireds);
    case Attributes::CoupleColorTempToLevelMinMireds::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, coupleColorTempToLevelMinMireds);
    case Attributes::StartUpColorTemperatureMireds::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, startUpColorTemperatureMireds);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace ColorControl
namespace BallastConfiguration {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::PhysicalMinLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, physicalMinLevel);
    case Attributes::PhysicalMaxLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, physicalMaxLevel);
    case Attributes::BallastStatus::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ballastStatus);
    case Attributes::MinLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minLevel);
    case Attributes::MaxLevel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxLevel);
    case Attributes::IntrinsicBallastFactor::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, intrinsicBallastFactor);
    case Attributes::BallastFactorAdjustment::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ballastFactorAdjustment);
    case Attributes::LampQuantity::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lampQuantity);
    case Attributes::LampType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lampType);
    case Attributes::LampManufacturer::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lampManufacturer);
    case Attributes::LampRatedHours::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lampRatedHours);
    case Attributes::LampBurnHours::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lampBurnHours);
    case Attributes::LampAlarmMode::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lampAlarmMode);
    case Attributes::LampBurnHoursTripPoint::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lampBurnHoursTripPoint);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace BallastConfiguration
namespace IlluminanceMeasurement {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredValue);
    case Attributes::MinMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minMeasuredValue);
    case Attributes::MaxMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxMeasuredValue);
    case Attributes::Tolerance::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, tolerance);
    case Attributes::LightSensorType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lightSensorType);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace IlluminanceMeasurement
namespace TemperatureMeasurement {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredValue);
    case Attributes::MinMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minMeasuredValue);
    case Attributes::MaxMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxMeasuredValue);
    case Attributes::Tolerance::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, tolerance);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace TemperatureMeasurement
namespace PressureMeasurement {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredValue);
    case Attributes::MinMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minMeasuredValue);
    case Attributes::MaxMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxMeasuredValue);
    case Attributes::Tolerance::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, tolerance);
    case Attributes::ScaledValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, scaledValue);
    case Attributes::MinScaledValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minScaledValue);
    case Attributes::MaxScaledValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxScaledValue);
    case Attributes::ScaledTolerance::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, scaledTolerance);
    case Attributes::Scale::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, scale);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace PressureMeasurement
namespace FlowMeasurement {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredValue);
    case Attributes::MinMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minMeasuredValue);
    case Attributes::MaxMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxMeasuredValue);
    case Attributes::Tolerance::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, tolerance);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace FlowMeasurement
namespace RelativeHumidityMeasurement {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredValue);
    case Attributes::MinMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minMeasuredValue);
    case Attributes::MaxMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxMeasuredValue);
    case Attributes::Tolerance::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, tolerance);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace RelativeHumidityMeasurement
namespace OccupancySensing {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Occupancy::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, occupancy);
    case Attributes::OccupancySensorType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, occupancySensorType);
    case Attributes::OccupancySensorTypeBitmap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, occupancySensorTypeBitmap);
    case Attributes::PIROccupiedToUnoccupiedDelay::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, PIROccupiedToUnoccupiedDelay);
    case Attributes::PIRUnoccupiedToOccupiedDelay::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, PIRUnoccupiedToOccupiedDelay);
    case Attributes::PIRUnoccupiedToOccupiedThreshold::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, PIRUnoccupiedToOccupiedThreshold);
    case Attributes::UltrasonicOccupiedToUnoccupiedDelay::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ultrasonicOccupiedToUnoccupiedDelay);
    case Attributes::UltrasonicUnoccupiedToOccupiedDelay::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ultrasonicUnoccupiedToOccupiedDelay);
    case Attributes::UltrasonicUnoccupiedToOccupiedThreshold::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ultrasonicUnoccupiedToOccupiedThreshold);
    case Attributes::PhysicalContactOccupiedToUnoccupiedDelay::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, physicalContactOccupiedToUnoccupiedDelay);
    case Attributes::PhysicalContactUnoccupiedToOccupiedDelay::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, physicalContactUnoccupiedToOccupiedDelay);
    case Attributes::PhysicalContactUnoccupiedToOccupiedThreshold::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, physicalContactUnoccupiedToOccupiedThreshold);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace OccupancySensing
namespace CarbonMonoxideConcentrationMeasurement {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredValue);
    case Attributes::MinMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minMeasuredValue);
    case Attributes::MaxMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxMeasuredValue);
    case Attributes::PeakMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValue);
    case Attributes::PeakMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValueWindow);
    case Attributes::AverageMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValue);
    case Attributes::AverageMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValueWindow);
    case Attributes::Uncertainty::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, uncertainty);
    case Attributes::MeasurementUnit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementUnit);
    case Attributes::MeasurementMedium::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementMedium);
    case Attributes::LevelValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, levelValue);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace CarbonMonoxideConcentrationMeasurement
namespace CarbonDioxideConcentrationMeasurement {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredValue);
    case Attributes::MinMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minMeasuredValue);
    case Attributes::MaxMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxMeasuredValue);
    case Attributes::PeakMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValue);
    case Attributes::PeakMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValueWindow);
    case Attributes::AverageMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValue);
    case Attributes::AverageMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValueWindow);
    case Attributes::Uncertainty::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, uncertainty);
    case Attributes::MeasurementUnit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementUnit);
    case Attributes::MeasurementMedium::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementMedium);
    case Attributes::LevelValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, levelValue);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace CarbonDioxideConcentrationMeasurement
namespace NitrogenDioxideConcentrationMeasurement {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredValue);
    case Attributes::MinMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minMeasuredValue);
    case Attributes::MaxMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxMeasuredValue);
    case Attributes::PeakMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValue);
    case Attributes::PeakMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValueWindow);
    case Attributes::AverageMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValue);
    case Attributes::AverageMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValueWindow);
    case Attributes::Uncertainty::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, uncertainty);
    case Attributes::MeasurementUnit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementUnit);
    case Attributes::MeasurementMedium::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementMedium);
    case Attributes::LevelValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, levelValue);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace NitrogenDioxideConcentrationMeasurement
namespace OzoneConcentrationMeasurement {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredValue);
    case Attributes::MinMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minMeasuredValue);
    case Attributes::MaxMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxMeasuredValue);
    case Attributes::PeakMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValue);
    case Attributes::PeakMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValueWindow);
    case Attributes::AverageMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValue);
    case Attributes::AverageMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValueWindow);
    case Attributes::Uncertainty::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, uncertainty);
    case Attributes::MeasurementUnit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementUnit);
    case Attributes::MeasurementMedium::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementMedium);
    case Attributes::LevelValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, levelValue);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace OzoneConcentrationMeasurement
namespace Pm25ConcentrationMeasurement {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredValue);
    case Attributes::MinMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minMeasuredValue);
    case Attributes::MaxMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxMeasuredValue);
    case Attributes::PeakMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValue);
    case Attributes::PeakMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValueWindow);
    case Attributes::AverageMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValue);
    case Attributes::AverageMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValueWindow);
    case Attributes::Uncertainty::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, uncertainty);
    case Attributes::MeasurementUnit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementUnit);
    case Attributes::MeasurementMedium::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementMedium);
    case Attributes::LevelValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, levelValue);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace Pm25ConcentrationMeasurement
namespace FormaldehydeConcentrationMeasurement {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredValue);
    case Attributes::MinMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minMeasuredValue);
    case Attributes::MaxMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxMeasuredValue);
    case Attributes::PeakMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValue);
    case Attributes::PeakMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValueWindow);
    case Attributes::AverageMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValue);
    case Attributes::AverageMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValueWindow);
    case Attributes::Uncertainty::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, uncertainty);
    case Attributes::MeasurementUnit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementUnit);
    case Attributes::MeasurementMedium::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementMedium);
    case Attributes::LevelValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, levelValue);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace FormaldehydeConcentrationMeasurement
namespace Pm1ConcentrationMeasurement {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredValue);
    case Attributes::MinMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minMeasuredValue);
    case Attributes::MaxMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxMeasuredValue);
    case Attributes::PeakMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValue);
    case Attributes::PeakMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValueWindow);
    case Attributes::AverageMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValue);
    case Attributes::AverageMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValueWindow);
    case Attributes::Uncertainty::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, uncertainty);
    case Attributes::MeasurementUnit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementUnit);
    case Attributes::MeasurementMedium::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementMedium);
    case Attributes::LevelValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, levelValue);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace Pm1ConcentrationMeasurement
namespace Pm10ConcentrationMeasurement {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredValue);
    case Attributes::MinMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minMeasuredValue);
    case Attributes::MaxMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxMeasuredValue);
    case Attributes::PeakMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValue);
    case Attributes::PeakMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValueWindow);
    case Attributes::AverageMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValue);
    case Attributes::AverageMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValueWindow);
    case Attributes::Uncertainty::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, uncertainty);
    case Attributes::MeasurementUnit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementUnit);
    case Attributes::MeasurementMedium::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementMedium);
    case Attributes::LevelValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, levelValue);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace Pm10ConcentrationMeasurement
namespace TotalVolatileOrganicCompoundsConcentrationMeasurement {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredValue);
    case Attributes::MinMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minMeasuredValue);
    case Attributes::MaxMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxMeasuredValue);
    case Attributes::PeakMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValue);
    case Attributes::PeakMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValueWindow);
    case Attributes::AverageMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValue);
    case Attributes::AverageMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValueWindow);
    case Attributes::Uncertainty::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, uncertainty);
    case Attributes::MeasurementUnit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementUnit);
    case Attributes::MeasurementMedium::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementMedium);
    case Attributes::LevelValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, levelValue);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace TotalVolatileOrganicCompoundsConcentrationMeasurement
namespace RadonConcentrationMeasurement {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredValue);
    case Attributes::MinMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, minMeasuredValue);
    case Attributes::MaxMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, maxMeasuredValue);
    case Attributes::PeakMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValue);
    case Attributes::PeakMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, peakMeasuredValueWindow);
    case Attributes::AverageMeasuredValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValue);
    case Attributes::AverageMeasuredValueWindow::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageMeasuredValueWindow);
    case Attributes::Uncertainty::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, uncertainty);
    case Attributes::MeasurementUnit::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementUnit);
    case Attributes::MeasurementMedium::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementMedium);
    case Attributes::LevelValue::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, levelValue);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace RadonConcentrationMeasurement
namespace WiFiNetworkManagement {

namespace Commands {
namespace NetworkPassphraseRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace NetworkPassphraseRequest.
namespace NetworkPassphraseResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPassphrase), passphrase);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPassphrase))
        {
            err = DataModel::Decode(reader, passphrase);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace NetworkPassphraseResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Ssid::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, ssid);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace WiFiNetworkManagement
namespace WakeOnLan {

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MACAddress::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, MACAddress);
    case Attributes::LinkLocalAddress::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, linkLocalAddress);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace WakeOnLan
namespace Channel {
namespace Structs {

namespace ProgramCastStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kName), name);
    encoder.Encode(to_underlying(Fields::kRole), role);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else if (__context_tag == to_underlying(Fields::kRole))
        {
            err = DataModel::Decode(reader, role);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ProgramCastStruct

namespace ProgramCategoryStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCategory), category);
    encoder.Encode(to_underlying(Fields::kSubCategory), subCategory);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCategory))
        {
            err = DataModel::Decode(reader, category);
        }
        else if (__context_tag == to_underlying(Fields::kSubCategory))
        {
            err = DataModel::Decode(reader, subCategory);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ProgramCategoryStruct

namespace SeriesInfoStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kSeason), season);
    encoder.Encode(to_underlying(Fields::kEpisode), episode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSeason))
        {
            err = DataModel::Decode(reader, season);
        }
        else if (__context_tag == to_underlying(Fields::kEpisode))
        {
            err = DataModel::Decode(reader, episode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace SeriesInfoStruct

namespace ChannelInfoStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMajorNumber), majorNumber);
    encoder.Encode(to_underlying(Fields::kMinorNumber), minorNumber);
    encoder.Encode(to_underlying(Fields::kName), name);
    encoder.Encode(to_underlying(Fields::kCallSign), callSign);
    encoder.Encode(to_underlying(Fields::kAffiliateCallSign), affiliateCallSign);
    encoder.Encode(to_underlying(Fields::kIdentifier), identifier);
    encoder.Encode(to_underlying(Fields::kType), type);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMajorNumber))
        {
            err = DataModel::Decode(reader, majorNumber);
        }
        else if (__context_tag == to_underlying(Fields::kMinorNumber))
        {
            err = DataModel::Decode(reader, minorNumber);
        }
        else if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else if (__context_tag == to_underlying(Fields::kCallSign))
        {
            err = DataModel::Decode(reader, callSign);
        }
        else if (__context_tag == to_underlying(Fields::kAffiliateCallSign))
        {
            err = DataModel::Decode(reader, affiliateCallSign);
        }
        else if (__context_tag == to_underlying(Fields::kIdentifier))
        {
            err = DataModel::Decode(reader, identifier);
        }
        else if (__context_tag == to_underlying(Fields::kType))
        {
            err = DataModel::Decode(reader, type);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ChannelInfoStruct

namespace ProgramStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kIdentifier), identifier);
    encoder.Encode(to_underlying(Fields::kChannel), channel);
    encoder.Encode(to_underlying(Fields::kStartTime), startTime);
    encoder.Encode(to_underlying(Fields::kEndTime), endTime);
    encoder.Encode(to_underlying(Fields::kTitle), title);
    encoder.Encode(to_underlying(Fields::kSubtitle), subtitle);
    encoder.Encode(to_underlying(Fields::kDescription), description);
    encoder.Encode(to_underlying(Fields::kAudioLanguages), audioLanguages);
    encoder.Encode(to_underlying(Fields::kRatings), ratings);
    encoder.Encode(to_underlying(Fields::kThumbnailUrl), thumbnailUrl);
    encoder.Encode(to_underlying(Fields::kPosterArtUrl), posterArtUrl);
    encoder.Encode(to_underlying(Fields::kDvbiUrl), dvbiUrl);
    encoder.Encode(to_underlying(Fields::kReleaseDate), releaseDate);
    encoder.Encode(to_underlying(Fields::kParentalGuidanceText), parentalGuidanceText);
    encoder.Encode(to_underlying(Fields::kRecordingFlag), recordingFlag);
    encoder.Encode(to_underlying(Fields::kSeriesInfo), seriesInfo);
    encoder.Encode(to_underlying(Fields::kCategoryList), categoryList);
    encoder.Encode(to_underlying(Fields::kCastList), castList);
    encoder.Encode(to_underlying(Fields::kExternalIDList), externalIDList);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kIdentifier))
        {
            err = DataModel::Decode(reader, identifier);
        }
        else if (__context_tag == to_underlying(Fields::kChannel))
        {
            err = DataModel::Decode(reader, channel);
        }
        else if (__context_tag == to_underlying(Fields::kStartTime))
        {
            err = DataModel::Decode(reader, startTime);
        }
        else if (__context_tag == to_underlying(Fields::kEndTime))
        {
            err = DataModel::Decode(reader, endTime);
        }
        else if (__context_tag == to_underlying(Fields::kTitle))
        {
            err = DataModel::Decode(reader, title);
        }
        else if (__context_tag == to_underlying(Fields::kSubtitle))
        {
            err = DataModel::Decode(reader, subtitle);
        }
        else if (__context_tag == to_underlying(Fields::kDescription))
        {
            err = DataModel::Decode(reader, description);
        }
        else if (__context_tag == to_underlying(Fields::kAudioLanguages))
        {
            err = DataModel::Decode(reader, audioLanguages);
        }
        else if (__context_tag == to_underlying(Fields::kRatings))
        {
            err = DataModel::Decode(reader, ratings);
        }
        else if (__context_tag == to_underlying(Fields::kThumbnailUrl))
        {
            err = DataModel::Decode(reader, thumbnailUrl);
        }
        else if (__context_tag == to_underlying(Fields::kPosterArtUrl))
        {
            err = DataModel::Decode(reader, posterArtUrl);
        }
        else if (__context_tag == to_underlying(Fields::kDvbiUrl))
        {
            err = DataModel::Decode(reader, dvbiUrl);
        }
        else if (__context_tag == to_underlying(Fields::kReleaseDate))
        {
            err = DataModel::Decode(reader, releaseDate);
        }
        else if (__context_tag == to_underlying(Fields::kParentalGuidanceText))
        {
            err = DataModel::Decode(reader, parentalGuidanceText);
        }
        else if (__context_tag == to_underlying(Fields::kRecordingFlag))
        {
            err = DataModel::Decode(reader, recordingFlag);
        }
        else if (__context_tag == to_underlying(Fields::kSeriesInfo))
        {
            err = DataModel::Decode(reader, seriesInfo);
        }
        else if (__context_tag == to_underlying(Fields::kCategoryList))
        {
            err = DataModel::Decode(reader, categoryList);
        }
        else if (__context_tag == to_underlying(Fields::kCastList))
        {
            err = DataModel::Decode(reader, castList);
        }
        else if (__context_tag == to_underlying(Fields::kExternalIDList))
        {
            err = DataModel::Decode(reader, externalIDList);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ProgramStruct

namespace PageTokenStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLimit), limit);
    encoder.Encode(to_underlying(Fields::kAfter), after);
    encoder.Encode(to_underlying(Fields::kBefore), before);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLimit))
        {
            err = DataModel::Decode(reader, limit);
        }
        else if (__context_tag == to_underlying(Fields::kAfter))
        {
            err = DataModel::Decode(reader, after);
        }
        else if (__context_tag == to_underlying(Fields::kBefore))
        {
            err = DataModel::Decode(reader, before);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace PageTokenStruct

namespace ChannelPagingStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPreviousToken), previousToken);
    encoder.Encode(to_underlying(Fields::kNextToken), nextToken);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPreviousToken))
        {
            err = DataModel::Decode(reader, previousToken);
        }
        else if (__context_tag == to_underlying(Fields::kNextToken))
        {
            err = DataModel::Decode(reader, nextToken);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ChannelPagingStruct

namespace AdditionalInfoStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kName), name);
    encoder.Encode(to_underlying(Fields::kValue), value);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else if (__context_tag == to_underlying(Fields::kValue))
        {
            err = DataModel::Decode(reader, value);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace AdditionalInfoStruct

namespace LineupInfoStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOperatorName), operatorName);
    encoder.Encode(to_underlying(Fields::kLineupName), lineupName);
    encoder.Encode(to_underlying(Fields::kPostalCode), postalCode);
    encoder.Encode(to_underlying(Fields::kLineupInfoType), lineupInfoType);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kOperatorName))
        {
            err = DataModel::Decode(reader, operatorName);
        }
        else if (__context_tag == to_underlying(Fields::kLineupName))
        {
            err = DataModel::Decode(reader, lineupName);
        }
        else if (__context_tag == to_underlying(Fields::kPostalCode))
        {
            err = DataModel::Decode(reader, postalCode);
        }
        else if (__context_tag == to_underlying(Fields::kLineupInfoType))
        {
            err = DataModel::Decode(reader, lineupInfoType);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace LineupInfoStruct
} // namespace Structs

namespace Commands {
namespace ChangeChannel {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMatch), match);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMatch))
        {
            err = DataModel::Decode(reader, match);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeChannel.
namespace ChangeChannelResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kData), data);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeChannelResponse.
namespace ChangeChannelByNumber {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMajorNumber), majorNumber);
    encoder.Encode(to_underlying(Fields::kMinorNumber), minorNumber);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMajorNumber))
        {
            err = DataModel::Decode(reader, majorNumber);
        }
        else if (__context_tag == to_underlying(Fields::kMinorNumber))
        {
            err = DataModel::Decode(reader, minorNumber);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ChangeChannelByNumber.
namespace SkipChannel {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCount), count);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCount))
        {
            err = DataModel::Decode(reader, count);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SkipChannel.
namespace GetProgramGuide {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStartTime), startTime);
    encoder.Encode(to_underlying(Fields::kEndTime), endTime);
    encoder.Encode(to_underlying(Fields::kChannelList), channelList);
    encoder.Encode(to_underlying(Fields::kPageToken), pageToken);
    encoder.Encode(to_underlying(Fields::kRecordingFlag), recordingFlag);
    encoder.Encode(to_underlying(Fields::kExternalIDList), externalIDList);
    encoder.Encode(to_underlying(Fields::kData), data);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStartTime))
        {
            err = DataModel::Decode(reader, startTime);
        }
        else if (__context_tag == to_underlying(Fields::kEndTime))
        {
            err = DataModel::Decode(reader, endTime);
        }
        else if (__context_tag == to_underlying(Fields::kChannelList))
        {
            err = DataModel::Decode(reader, channelList);
        }
        else if (__context_tag == to_underlying(Fields::kPageToken))
        {
            err = DataModel::Decode(reader, pageToken);
        }
        else if (__context_tag == to_underlying(Fields::kRecordingFlag))
        {
            err = DataModel::Decode(reader, recordingFlag);
        }
        else if (__context_tag == to_underlying(Fields::kExternalIDList))
        {
            err = DataModel::Decode(reader, externalIDList);
        }
        else if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetProgramGuide.
namespace ProgramGuideResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPaging), paging);
    encoder.Encode(to_underlying(Fields::kProgramList), programList);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPaging))
        {
            err = DataModel::Decode(reader, paging);
        }
        else if (__context_tag == to_underlying(Fields::kProgramList))
        {
            err = DataModel::Decode(reader, programList);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ProgramGuideResponse.
namespace RecordProgram {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kProgramIdentifier), programIdentifier);
    encoder.Encode(to_underlying(Fields::kShouldRecordSeries), shouldRecordSeries);
    encoder.Encode(to_underlying(Fields::kExternalIDList), externalIDList);
    encoder.Encode(to_underlying(Fields::kData), data);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kProgramIdentifier))
        {
            err = DataModel::Decode(reader, programIdentifier);
        }
        else if (__context_tag == to_underlying(Fields::kShouldRecordSeries))
        {
            err = DataModel::Decode(reader, shouldRecordSeries);
        }
        else if (__context_tag == to_underlying(Fields::kExternalIDList))
        {
            err = DataModel::Decode(reader, externalIDList);
        }
        else if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RecordProgram.
namespace CancelRecordProgram {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kProgramIdentifier), programIdentifier);
    encoder.Encode(to_underlying(Fields::kShouldRecordSeries), shouldRecordSeries);
    encoder.Encode(to_underlying(Fields::kExternalIDList), externalIDList);
    encoder.Encode(to_underlying(Fields::kData), data);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kProgramIdentifier))
        {
            err = DataModel::Decode(reader, programIdentifier);
        }
        else if (__context_tag == to_underlying(Fields::kShouldRecordSeries))
        {
            err = DataModel::Decode(reader, shouldRecordSeries);
        }
        else if (__context_tag == to_underlying(Fields::kExternalIDList))
        {
            err = DataModel::Decode(reader, externalIDList);
        }
        else if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace CancelRecordProgram.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::ChannelList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, channelList);
    case Attributes::Lineup::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lineup);
    case Attributes::CurrentChannel::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentChannel);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace Channel
namespace TargetNavigator {
namespace Structs {

namespace TargetInfoStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kIdentifier), identifier);
    encoder.Encode(to_underlying(Fields::kName), name);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kIdentifier))
        {
            err = DataModel::Decode(reader, identifier);
        }
        else if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace TargetInfoStruct
} // namespace Structs

namespace Commands {
namespace NavigateTarget {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTarget), target);
    encoder.Encode(to_underlying(Fields::kData), data);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTarget))
        {
            err = DataModel::Decode(reader, target);
        }
        else if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace NavigateTarget.
namespace NavigateTargetResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kData), data);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace NavigateTargetResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::TargetList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, targetList);
    case Attributes::CurrentTarget::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentTarget);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace TargetUpdated {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kTargetList), targetList));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCurrentTarget), currentTarget));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kData), data));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTargetList))
        {
            err = DataModel::Decode(reader, targetList);
        }
        else if (__context_tag == to_underlying(Fields::kCurrentTarget))
        {
            err = DataModel::Decode(reader, currentTarget);
        }
        else if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TargetUpdated.
} // namespace Events

} // namespace TargetNavigator
namespace MediaPlayback {
namespace Structs {

namespace TrackAttributesStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLanguageCode), languageCode);
    encoder.Encode(to_underlying(Fields::kDisplayName), displayName);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLanguageCode))
        {
            err = DataModel::Decode(reader, languageCode);
        }
        else if (__context_tag == to_underlying(Fields::kDisplayName))
        {
            err = DataModel::Decode(reader, displayName);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace TrackAttributesStruct

namespace TrackStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kId), id);
    encoder.Encode(to_underlying(Fields::kTrackAttributes), trackAttributes);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kId))
        {
            err = DataModel::Decode(reader, id);
        }
        else if (__context_tag == to_underlying(Fields::kTrackAttributes))
        {
            err = DataModel::Decode(reader, trackAttributes);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace TrackStruct

namespace PlaybackPositionStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kUpdatedAt), updatedAt);
    encoder.Encode(to_underlying(Fields::kPosition), position);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kUpdatedAt))
        {
            err = DataModel::Decode(reader, updatedAt);
        }
        else if (__context_tag == to_underlying(Fields::kPosition))
        {
            err = DataModel::Decode(reader, position);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace PlaybackPositionStruct
} // namespace Structs

namespace Commands {
namespace Play {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Play.
namespace Pause {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Pause.
namespace Stop {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Stop.
namespace StartOver {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace StartOver.
namespace Previous {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Previous.
namespace Next {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Next.
namespace Rewind {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kAudioAdvanceUnmuted), audioAdvanceUnmuted);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAudioAdvanceUnmuted))
        {
            err = DataModel::Decode(reader, audioAdvanceUnmuted);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Rewind.
namespace FastForward {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kAudioAdvanceUnmuted), audioAdvanceUnmuted);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAudioAdvanceUnmuted))
        {
            err = DataModel::Decode(reader, audioAdvanceUnmuted);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace FastForward.
namespace SkipForward {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kDeltaPositionMilliseconds), deltaPositionMilliseconds);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDeltaPositionMilliseconds))
        {
            err = DataModel::Decode(reader, deltaPositionMilliseconds);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SkipForward.
namespace SkipBackward {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kDeltaPositionMilliseconds), deltaPositionMilliseconds);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kDeltaPositionMilliseconds))
        {
            err = DataModel::Decode(reader, deltaPositionMilliseconds);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SkipBackward.
namespace PlaybackResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kData), data);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace PlaybackResponse.
namespace Seek {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPosition), position);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPosition))
        {
            err = DataModel::Decode(reader, position);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Seek.
namespace ActivateAudioTrack {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTrackID), trackID);
    encoder.Encode(to_underlying(Fields::kAudioOutputIndex), audioOutputIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTrackID))
        {
            err = DataModel::Decode(reader, trackID);
        }
        else if (__context_tag == to_underlying(Fields::kAudioOutputIndex))
        {
            err = DataModel::Decode(reader, audioOutputIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ActivateAudioTrack.
namespace ActivateTextTrack {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTrackID), trackID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTrackID))
        {
            err = DataModel::Decode(reader, trackID);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ActivateTextTrack.
namespace DeactivateTextTrack {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace DeactivateTextTrack.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::CurrentState::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentState);
    case Attributes::StartTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, startTime);
    case Attributes::Duration::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, duration);
    case Attributes::SampledPosition::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, sampledPosition);
    case Attributes::PlaybackSpeed::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, playbackSpeed);
    case Attributes::SeekRangeEnd::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, seekRangeEnd);
    case Attributes::SeekRangeStart::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, seekRangeStart);
    case Attributes::ActiveAudioTrack::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeAudioTrack);
    case Attributes::AvailableAudioTracks::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, availableAudioTracks);
    case Attributes::ActiveTextTrack::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeTextTrack);
    case Attributes::AvailableTextTracks::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, availableTextTracks);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace StateChanged {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCurrentState), currentState));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kStartTime), startTime));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kDuration), duration));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSampledPosition), sampledPosition));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kPlaybackSpeed), playbackSpeed));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSeekRangeEnd), seekRangeEnd));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kSeekRangeStart), seekRangeStart));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kData), data));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kAudioAdvanceUnmuted), audioAdvanceUnmuted));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCurrentState))
        {
            err = DataModel::Decode(reader, currentState);
        }
        else if (__context_tag == to_underlying(Fields::kStartTime))
        {
            err = DataModel::Decode(reader, startTime);
        }
        else if (__context_tag == to_underlying(Fields::kDuration))
        {
            err = DataModel::Decode(reader, duration);
        }
        else if (__context_tag == to_underlying(Fields::kSampledPosition))
        {
            err = DataModel::Decode(reader, sampledPosition);
        }
        else if (__context_tag == to_underlying(Fields::kPlaybackSpeed))
        {
            err = DataModel::Decode(reader, playbackSpeed);
        }
        else if (__context_tag == to_underlying(Fields::kSeekRangeEnd))
        {
            err = DataModel::Decode(reader, seekRangeEnd);
        }
        else if (__context_tag == to_underlying(Fields::kSeekRangeStart))
        {
            err = DataModel::Decode(reader, seekRangeStart);
        }
        else if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else if (__context_tag == to_underlying(Fields::kAudioAdvanceUnmuted))
        {
            err = DataModel::Decode(reader, audioAdvanceUnmuted);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StateChanged.
} // namespace Events

} // namespace MediaPlayback
namespace MediaInput {
namespace Structs {

namespace InputInfoStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kIndex), index);
    encoder.Encode(to_underlying(Fields::kInputType), inputType);
    encoder.Encode(to_underlying(Fields::kName), name);
    encoder.Encode(to_underlying(Fields::kDescription), description);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kIndex))
        {
            err = DataModel::Decode(reader, index);
        }
        else if (__context_tag == to_underlying(Fields::kInputType))
        {
            err = DataModel::Decode(reader, inputType);
        }
        else if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else if (__context_tag == to_underlying(Fields::kDescription))
        {
            err = DataModel::Decode(reader, description);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace InputInfoStruct
} // namespace Structs

namespace Commands {
namespace SelectInput {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kIndex), index);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kIndex))
        {
            err = DataModel::Decode(reader, index);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SelectInput.
namespace ShowInputStatus {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ShowInputStatus.
namespace HideInputStatus {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace HideInputStatus.
namespace RenameInput {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kIndex), index);
    encoder.Encode(to_underlying(Fields::kName), name);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kIndex))
        {
            err = DataModel::Decode(reader, index);
        }
        else if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RenameInput.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::InputList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, inputList);
    case Attributes::CurrentInput::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentInput);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace MediaInput
namespace LowPower {

namespace Commands {
namespace Sleep {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Sleep.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace LowPower
namespace KeypadInput {

namespace Commands {
namespace SendKey {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kKeyCode), keyCode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kKeyCode))
        {
            err = DataModel::Decode(reader, keyCode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SendKey.
namespace SendKeyResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SendKeyResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace KeypadInput
namespace ContentLauncher {
namespace Structs {

namespace DimensionStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kWidth), width);
    encoder.Encode(to_underlying(Fields::kHeight), height);
    encoder.Encode(to_underlying(Fields::kMetric), metric);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kWidth))
        {
            err = DataModel::Decode(reader, width);
        }
        else if (__context_tag == to_underlying(Fields::kHeight))
        {
            err = DataModel::Decode(reader, height);
        }
        else if (__context_tag == to_underlying(Fields::kMetric))
        {
            err = DataModel::Decode(reader, metric);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace DimensionStruct

namespace TrackPreferenceStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLanguageCode), languageCode);
    encoder.Encode(to_underlying(Fields::kCharacteristics), characteristics);
    encoder.Encode(to_underlying(Fields::kAudioOutputIndex), audioOutputIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kLanguageCode))
        {
            err = DataModel::Decode(reader, languageCode);
        }
        else if (__context_tag == to_underlying(Fields::kCharacteristics))
        {
            err = DataModel::Decode(reader, characteristics);
        }
        else if (__context_tag == to_underlying(Fields::kAudioOutputIndex))
        {
            err = DataModel::Decode(reader, audioOutputIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace TrackPreferenceStruct

namespace PlaybackPreferencesStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPlaybackPosition), playbackPosition);
    encoder.Encode(to_underlying(Fields::kTextTrack), textTrack);
    encoder.Encode(to_underlying(Fields::kAudioTracks), audioTracks);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPlaybackPosition))
        {
            err = DataModel::Decode(reader, playbackPosition);
        }
        else if (__context_tag == to_underlying(Fields::kTextTrack))
        {
            err = DataModel::Decode(reader, textTrack);
        }
        else if (__context_tag == to_underlying(Fields::kAudioTracks))
        {
            err = DataModel::Decode(reader, audioTracks);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace PlaybackPreferencesStruct

namespace AdditionalInfoStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kName), name);
    encoder.Encode(to_underlying(Fields::kValue), value);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else if (__context_tag == to_underlying(Fields::kValue))
        {
            err = DataModel::Decode(reader, value);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace AdditionalInfoStruct

namespace ParameterStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kType), type);
    encoder.Encode(to_underlying(Fields::kValue), value);
    encoder.Encode(to_underlying(Fields::kExternalIDList), externalIDList);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kType))
        {
            err = DataModel::Decode(reader, type);
        }
        else if (__context_tag == to_underlying(Fields::kValue))
        {
            err = DataModel::Decode(reader, value);
        }
        else if (__context_tag == to_underlying(Fields::kExternalIDList))
        {
            err = DataModel::Decode(reader, externalIDList);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ParameterStruct

namespace ContentSearchStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kParameterList), parameterList);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kParameterList))
        {
            err = DataModel::Decode(reader, parameterList);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ContentSearchStruct

namespace StyleInformationStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kImageURL), imageURL);
    encoder.Encode(to_underlying(Fields::kColor), color);
    encoder.Encode(to_underlying(Fields::kSize), size);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kImageURL))
        {
            err = DataModel::Decode(reader, imageURL);
        }
        else if (__context_tag == to_underlying(Fields::kColor))
        {
            err = DataModel::Decode(reader, color);
        }
        else if (__context_tag == to_underlying(Fields::kSize))
        {
            err = DataModel::Decode(reader, size);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace StyleInformationStruct

namespace BrandingInformationStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kProviderName), providerName);
    encoder.Encode(to_underlying(Fields::kBackground), background);
    encoder.Encode(to_underlying(Fields::kLogo), logo);
    encoder.Encode(to_underlying(Fields::kProgressBar), progressBar);
    encoder.Encode(to_underlying(Fields::kSplash), splash);
    encoder.Encode(to_underlying(Fields::kWaterMark), waterMark);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kProviderName))
        {
            err = DataModel::Decode(reader, providerName);
        }
        else if (__context_tag == to_underlying(Fields::kBackground))
        {
            err = DataModel::Decode(reader, background);
        }
        else if (__context_tag == to_underlying(Fields::kLogo))
        {
            err = DataModel::Decode(reader, logo);
        }
        else if (__context_tag == to_underlying(Fields::kProgressBar))
        {
            err = DataModel::Decode(reader, progressBar);
        }
        else if (__context_tag == to_underlying(Fields::kSplash))
        {
            err = DataModel::Decode(reader, splash);
        }
        else if (__context_tag == to_underlying(Fields::kWaterMark))
        {
            err = DataModel::Decode(reader, waterMark);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace BrandingInformationStruct
} // namespace Structs

namespace Commands {
namespace LaunchContent {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kSearch), search);
    encoder.Encode(to_underlying(Fields::kAutoPlay), autoPlay);
    encoder.Encode(to_underlying(Fields::kData), data);
    encoder.Encode(to_underlying(Fields::kPlaybackPreferences), playbackPreferences);
    encoder.Encode(to_underlying(Fields::kUseCurrentContext), useCurrentContext);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSearch))
        {
            err = DataModel::Decode(reader, search);
        }
        else if (__context_tag == to_underlying(Fields::kAutoPlay))
        {
            err = DataModel::Decode(reader, autoPlay);
        }
        else if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else if (__context_tag == to_underlying(Fields::kPlaybackPreferences))
        {
            err = DataModel::Decode(reader, playbackPreferences);
        }
        else if (__context_tag == to_underlying(Fields::kUseCurrentContext))
        {
            err = DataModel::Decode(reader, useCurrentContext);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace LaunchContent.
namespace LaunchURL {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kContentURL), contentURL);
    encoder.Encode(to_underlying(Fields::kDisplayString), displayString);
    encoder.Encode(to_underlying(Fields::kBrandingInformation), brandingInformation);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kContentURL))
        {
            err = DataModel::Decode(reader, contentURL);
        }
        else if (__context_tag == to_underlying(Fields::kDisplayString))
        {
            err = DataModel::Decode(reader, displayString);
        }
        else if (__context_tag == to_underlying(Fields::kBrandingInformation))
        {
            err = DataModel::Decode(reader, brandingInformation);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace LaunchURL.
namespace LauncherResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kData), data);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace LauncherResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::AcceptHeader::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptHeader);
    case Attributes::SupportedStreamingProtocols::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, supportedStreamingProtocols);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace ContentLauncher
namespace AudioOutput {
namespace Structs {

namespace OutputInfoStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kIndex), index);
    encoder.Encode(to_underlying(Fields::kOutputType), outputType);
    encoder.Encode(to_underlying(Fields::kName), name);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kIndex))
        {
            err = DataModel::Decode(reader, index);
        }
        else if (__context_tag == to_underlying(Fields::kOutputType))
        {
            err = DataModel::Decode(reader, outputType);
        }
        else if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace OutputInfoStruct
} // namespace Structs

namespace Commands {
namespace SelectOutput {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kIndex), index);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kIndex))
        {
            err = DataModel::Decode(reader, index);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SelectOutput.
namespace RenameOutput {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kIndex), index);
    encoder.Encode(to_underlying(Fields::kName), name);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kIndex))
        {
            err = DataModel::Decode(reader, index);
        }
        else if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace RenameOutput.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::OutputList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, outputList);
    case Attributes::CurrentOutput::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentOutput);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace AudioOutput
namespace ApplicationLauncher {
namespace Structs {

namespace ApplicationEPStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kApplication), application);
    encoder.Encode(to_underlying(Fields::kEndpoint), endpoint);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kApplication))
        {
            err = DataModel::Decode(reader, application);
        }
        else if (__context_tag == to_underlying(Fields::kEndpoint))
        {
            err = DataModel::Decode(reader, endpoint);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ApplicationEPStruct
} // namespace Structs

namespace Commands {
namespace LaunchApp {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kApplication), application);
    encoder.Encode(to_underlying(Fields::kData), data);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kApplication))
        {
            err = DataModel::Decode(reader, application);
        }
        else if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace LaunchApp.
namespace StopApp {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kApplication), application);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kApplication))
        {
            err = DataModel::Decode(reader, application);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace StopApp.
namespace HideApp {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kApplication), application);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kApplication))
        {
            err = DataModel::Decode(reader, application);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace HideApp.
namespace LauncherResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kData), data);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace LauncherResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::CatalogList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, catalogList);
    case Attributes::CurrentApp::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentApp);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace ApplicationLauncher
namespace ApplicationBasic {
namespace Structs {} // namespace Structs

namespace Commands {} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::VendorName::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, vendorName);
    case Attributes::VendorID::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, vendorID);
    case Attributes::ApplicationName::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, applicationName);
    case Attributes::ProductID::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, productID);
    case Attributes::Application::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, application);
    case Attributes::Status::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, status);
    case Attributes::ApplicationVersion::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, applicationVersion);
    case Attributes::AllowedVendorList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, allowedVendorList);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace ApplicationBasic
namespace AccountLogin {

namespace Commands {
namespace GetSetupPIN {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTempAccountIdentifier), tempAccountIdentifier);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTempAccountIdentifier))
        {
            err = DataModel::Decode(reader, tempAccountIdentifier);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetSetupPIN.
namespace GetSetupPINResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kSetupPIN), setupPIN);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSetupPIN))
        {
            err = DataModel::Decode(reader, setupPIN);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetSetupPINResponse.
namespace Login {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTempAccountIdentifier), tempAccountIdentifier);
    encoder.Encode(to_underlying(Fields::kSetupPIN), setupPIN);
    encoder.Encode(to_underlying(Fields::kNode), node);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kTempAccountIdentifier))
        {
            err = DataModel::Decode(reader, tempAccountIdentifier);
        }
        else if (__context_tag == to_underlying(Fields::kSetupPIN))
        {
            err = DataModel::Decode(reader, setupPIN);
        }
        else if (__context_tag == to_underlying(Fields::kNode))
        {
            err = DataModel::Decode(reader, node);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Login.
namespace Logout {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNode), node);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNode))
        {
            err = DataModel::Decode(reader, node);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace Logout.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace LoggedOut {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kNode), node));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNode))
        {
            err = DataModel::Decode(reader, node);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace LoggedOut.
} // namespace Events

} // namespace AccountLogin
namespace ContentControl {
namespace Structs {

namespace RatingNameStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kRatingName), ratingName);
    encoder.Encode(to_underlying(Fields::kRatingNameDesc), ratingNameDesc);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kRatingName))
        {
            err = DataModel::Decode(reader, ratingName);
        }
        else if (__context_tag == to_underlying(Fields::kRatingNameDesc))
        {
            err = DataModel::Decode(reader, ratingNameDesc);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace RatingNameStruct
} // namespace Structs

namespace Commands {
namespace UpdatePIN {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOldPIN), oldPIN);
    encoder.Encode(to_underlying(Fields::kNewPIN), newPIN);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kOldPIN))
        {
            err = DataModel::Decode(reader, oldPIN);
        }
        else if (__context_tag == to_underlying(Fields::kNewPIN))
        {
            err = DataModel::Decode(reader, newPIN);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace UpdatePIN.
namespace ResetPIN {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace ResetPIN.
namespace ResetPINResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPINCode), PINCode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPINCode))
        {
            err = DataModel::Decode(reader, PINCode);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ResetPINResponse.
namespace Enable {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Enable.
namespace Disable {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Disable.
namespace AddBonusTime {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPINCode), PINCode);
    encoder.Encode(to_underlying(Fields::kBonusTime), bonusTime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kPINCode))
        {
            err = DataModel::Decode(reader, PINCode);
        }
        else if (__context_tag == to_underlying(Fields::kBonusTime))
        {
            err = DataModel::Decode(reader, bonusTime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AddBonusTime.
namespace SetScreenDailyTime {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kScreenTime), screenTime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kScreenTime))
        {
            err = DataModel::Decode(reader, screenTime);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetScreenDailyTime.
namespace BlockUnratedContent {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace BlockUnratedContent.
namespace UnblockUnratedContent {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace UnblockUnratedContent.
namespace SetOnDemandRatingThreshold {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kRating), rating);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kRating))
        {
            err = DataModel::Decode(reader, rating);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetOnDemandRatingThreshold.
namespace SetScheduledContentRatingThreshold {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kRating), rating);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kRating))
        {
            err = DataModel::Decode(reader, rating);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetScheduledContentRatingThreshold.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Enabled::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, enabled);
    case Attributes::OnDemandRatings::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, onDemandRatings);
    case Attributes::OnDemandRatingThreshold::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, onDemandRatingThreshold);
    case Attributes::ScheduledContentRatings::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, scheduledContentRatings);
    case Attributes::ScheduledContentRatingThreshold::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, scheduledContentRatingThreshold);
    case Attributes::ScreenDailyTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, screenDailyTime);
    case Attributes::RemainingScreenTime::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, remainingScreenTime);
    case Attributes::BlockUnrated::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, blockUnrated);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace RemainingScreenTimeExpired {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace RemainingScreenTimeExpired.
} // namespace Events

} // namespace ContentControl
namespace ContentAppObserver {

namespace Commands {
namespace ContentAppMessage {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kData), data);
    encoder.Encode(to_underlying(Fields::kEncodingHint), encodingHint);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else if (__context_tag == to_underlying(Fields::kEncodingHint))
        {
            err = DataModel::Decode(reader, encodingHint);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ContentAppMessage.
namespace ContentAppMessageResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kData), data);
    encoder.Encode(to_underlying(Fields::kEncodingHint), encodingHint);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kData))
        {
            err = DataModel::Decode(reader, data);
        }
        else if (__context_tag == to_underlying(Fields::kEncodingHint))
        {
            err = DataModel::Decode(reader, encodingHint);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ContentAppMessageResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace ContentAppObserver
namespace ElectricalMeasurement {

namespace Commands {
namespace GetProfileInfoResponseCommand {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kProfileCount), profileCount);
    encoder.Encode(to_underlying(Fields::kProfileIntervalPeriod), profileIntervalPeriod);
    encoder.Encode(to_underlying(Fields::kMaxNumberOfIntervals), maxNumberOfIntervals);
    encoder.Encode(to_underlying(Fields::kListOfAttributes), listOfAttributes);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kProfileCount))
        {
            err = DataModel::Decode(reader, profileCount);
        }
        else if (__context_tag == to_underlying(Fields::kProfileIntervalPeriod))
        {
            err = DataModel::Decode(reader, profileIntervalPeriod);
        }
        else if (__context_tag == to_underlying(Fields::kMaxNumberOfIntervals))
        {
            err = DataModel::Decode(reader, maxNumberOfIntervals);
        }
        else if (__context_tag == to_underlying(Fields::kListOfAttributes))
        {
            err = DataModel::Decode(reader, listOfAttributes);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetProfileInfoResponseCommand.
namespace GetProfileInfoCommand {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace GetProfileInfoCommand.
namespace GetMeasurementProfileResponseCommand {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStartTime), startTime);
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kProfileIntervalPeriod), profileIntervalPeriod);
    encoder.Encode(to_underlying(Fields::kNumberOfIntervalsDelivered), numberOfIntervalsDelivered);
    encoder.Encode(to_underlying(Fields::kAttributeId), attributeId);
    encoder.Encode(to_underlying(Fields::kIntervals), intervals);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kStartTime))
        {
            err = DataModel::Decode(reader, startTime);
        }
        else if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kProfileIntervalPeriod))
        {
            err = DataModel::Decode(reader, profileIntervalPeriod);
        }
        else if (__context_tag == to_underlying(Fields::kNumberOfIntervalsDelivered))
        {
            err = DataModel::Decode(reader, numberOfIntervalsDelivered);
        }
        else if (__context_tag == to_underlying(Fields::kAttributeId))
        {
            err = DataModel::Decode(reader, attributeId);
        }
        else if (__context_tag == to_underlying(Fields::kIntervals))
        {
            err = DataModel::Decode(reader, intervals);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetMeasurementProfileResponseCommand.
namespace GetMeasurementProfileCommand {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kAttributeId), attributeId);
    encoder.Encode(to_underlying(Fields::kStartTime), startTime);
    encoder.Encode(to_underlying(Fields::kNumberOfIntervals), numberOfIntervals);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kAttributeId))
        {
            err = DataModel::Decode(reader, attributeId);
        }
        else if (__context_tag == to_underlying(Fields::kStartTime))
        {
            err = DataModel::Decode(reader, startTime);
        }
        else if (__context_tag == to_underlying(Fields::kNumberOfIntervals))
        {
            err = DataModel::Decode(reader, numberOfIntervals);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetMeasurementProfileCommand.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::MeasurementType::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measurementType);
    case Attributes::DcVoltage::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dcVoltage);
    case Attributes::DcVoltageMin::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dcVoltageMin);
    case Attributes::DcVoltageMax::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dcVoltageMax);
    case Attributes::DcCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dcCurrent);
    case Attributes::DcCurrentMin::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dcCurrentMin);
    case Attributes::DcCurrentMax::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dcCurrentMax);
    case Attributes::DcPower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dcPower);
    case Attributes::DcPowerMin::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dcPowerMin);
    case Attributes::DcPowerMax::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dcPowerMax);
    case Attributes::DcVoltageMultiplier::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dcVoltageMultiplier);
    case Attributes::DcVoltageDivisor::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dcVoltageDivisor);
    case Attributes::DcCurrentMultiplier::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dcCurrentMultiplier);
    case Attributes::DcCurrentDivisor::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dcCurrentDivisor);
    case Attributes::DcPowerMultiplier::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dcPowerMultiplier);
    case Attributes::DcPowerDivisor::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, dcPowerDivisor);
    case Attributes::AcFrequency::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acFrequency);
    case Attributes::AcFrequencyMin::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acFrequencyMin);
    case Attributes::AcFrequencyMax::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acFrequencyMax);
    case Attributes::NeutralCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, neutralCurrent);
    case Attributes::TotalActivePower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, totalActivePower);
    case Attributes::TotalReactivePower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, totalReactivePower);
    case Attributes::TotalApparentPower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, totalApparentPower);
    case Attributes::Measured1stHarmonicCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measured1stHarmonicCurrent);
    case Attributes::Measured3rdHarmonicCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measured3rdHarmonicCurrent);
    case Attributes::Measured5thHarmonicCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measured5thHarmonicCurrent);
    case Attributes::Measured7thHarmonicCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measured7thHarmonicCurrent);
    case Attributes::Measured9thHarmonicCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measured9thHarmonicCurrent);
    case Attributes::Measured11thHarmonicCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measured11thHarmonicCurrent);
    case Attributes::MeasuredPhase1stHarmonicCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredPhase1stHarmonicCurrent);
    case Attributes::MeasuredPhase3rdHarmonicCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredPhase3rdHarmonicCurrent);
    case Attributes::MeasuredPhase5thHarmonicCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredPhase5thHarmonicCurrent);
    case Attributes::MeasuredPhase7thHarmonicCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredPhase7thHarmonicCurrent);
    case Attributes::MeasuredPhase9thHarmonicCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredPhase9thHarmonicCurrent);
    case Attributes::MeasuredPhase11thHarmonicCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, measuredPhase11thHarmonicCurrent);
    case Attributes::AcFrequencyMultiplier::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acFrequencyMultiplier);
    case Attributes::AcFrequencyDivisor::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acFrequencyDivisor);
    case Attributes::PowerMultiplier::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, powerMultiplier);
    case Attributes::PowerDivisor::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, powerDivisor);
    case Attributes::HarmonicCurrentMultiplier::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, harmonicCurrentMultiplier);
    case Attributes::PhaseHarmonicCurrentMultiplier::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, phaseHarmonicCurrentMultiplier);
    case Attributes::InstantaneousVoltage::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, instantaneousVoltage);
    case Attributes::InstantaneousLineCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, instantaneousLineCurrent);
    case Attributes::InstantaneousActiveCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, instantaneousActiveCurrent);
    case Attributes::InstantaneousReactiveCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, instantaneousReactiveCurrent);
    case Attributes::InstantaneousPower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, instantaneousPower);
    case Attributes::RmsVoltage::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltage);
    case Attributes::RmsVoltageMin::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltageMin);
    case Attributes::RmsVoltageMax::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltageMax);
    case Attributes::RmsCurrent::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsCurrent);
    case Attributes::RmsCurrentMin::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsCurrentMin);
    case Attributes::RmsCurrentMax::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsCurrentMax);
    case Attributes::ActivePower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activePower);
    case Attributes::ActivePowerMin::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activePowerMin);
    case Attributes::ActivePowerMax::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activePowerMax);
    case Attributes::ReactivePower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, reactivePower);
    case Attributes::ApparentPower::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, apparentPower);
    case Attributes::PowerFactor::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, powerFactor);
    case Attributes::AverageRmsVoltageMeasurementPeriod::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageRmsVoltageMeasurementPeriod);
    case Attributes::AverageRmsUnderVoltageCounter::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageRmsUnderVoltageCounter);
    case Attributes::RmsExtremeOverVoltagePeriod::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsExtremeOverVoltagePeriod);
    case Attributes::RmsExtremeUnderVoltagePeriod::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsExtremeUnderVoltagePeriod);
    case Attributes::RmsVoltageSagPeriod::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltageSagPeriod);
    case Attributes::RmsVoltageSwellPeriod::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltageSwellPeriod);
    case Attributes::AcVoltageMultiplier::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acVoltageMultiplier);
    case Attributes::AcVoltageDivisor::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acVoltageDivisor);
    case Attributes::AcCurrentMultiplier::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acCurrentMultiplier);
    case Attributes::AcCurrentDivisor::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acCurrentDivisor);
    case Attributes::AcPowerMultiplier::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acPowerMultiplier);
    case Attributes::AcPowerDivisor::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acPowerDivisor);
    case Attributes::OverloadAlarmsMask::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, overloadAlarmsMask);
    case Attributes::VoltageOverload::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, voltageOverload);
    case Attributes::CurrentOverload::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, currentOverload);
    case Attributes::AcOverloadAlarmsMask::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acOverloadAlarmsMask);
    case Attributes::AcVoltageOverload::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acVoltageOverload);
    case Attributes::AcCurrentOverload::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acCurrentOverload);
    case Attributes::AcActivePowerOverload::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acActivePowerOverload);
    case Attributes::AcReactivePowerOverload::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acReactivePowerOverload);
    case Attributes::AverageRmsOverVoltage::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageRmsOverVoltage);
    case Attributes::AverageRmsUnderVoltage::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageRmsUnderVoltage);
    case Attributes::RmsExtremeOverVoltage::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsExtremeOverVoltage);
    case Attributes::RmsExtremeUnderVoltage::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsExtremeUnderVoltage);
    case Attributes::RmsVoltageSag::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltageSag);
    case Attributes::RmsVoltageSwell::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltageSwell);
    case Attributes::LineCurrentPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lineCurrentPhaseB);
    case Attributes::ActiveCurrentPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeCurrentPhaseB);
    case Attributes::ReactiveCurrentPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, reactiveCurrentPhaseB);
    case Attributes::RmsVoltagePhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltagePhaseB);
    case Attributes::RmsVoltageMinPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltageMinPhaseB);
    case Attributes::RmsVoltageMaxPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltageMaxPhaseB);
    case Attributes::RmsCurrentPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsCurrentPhaseB);
    case Attributes::RmsCurrentMinPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsCurrentMinPhaseB);
    case Attributes::RmsCurrentMaxPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsCurrentMaxPhaseB);
    case Attributes::ActivePowerPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activePowerPhaseB);
    case Attributes::ActivePowerMinPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activePowerMinPhaseB);
    case Attributes::ActivePowerMaxPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activePowerMaxPhaseB);
    case Attributes::ReactivePowerPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, reactivePowerPhaseB);
    case Attributes::ApparentPowerPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, apparentPowerPhaseB);
    case Attributes::PowerFactorPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, powerFactorPhaseB);
    case Attributes::AverageRmsVoltageMeasurementPeriodPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageRmsVoltageMeasurementPeriodPhaseB);
    case Attributes::AverageRmsOverVoltageCounterPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageRmsOverVoltageCounterPhaseB);
    case Attributes::AverageRmsUnderVoltageCounterPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageRmsUnderVoltageCounterPhaseB);
    case Attributes::RmsExtremeOverVoltagePeriodPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsExtremeOverVoltagePeriodPhaseB);
    case Attributes::RmsExtremeUnderVoltagePeriodPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsExtremeUnderVoltagePeriodPhaseB);
    case Attributes::RmsVoltageSagPeriodPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltageSagPeriodPhaseB);
    case Attributes::RmsVoltageSwellPeriodPhaseB::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltageSwellPeriodPhaseB);
    case Attributes::LineCurrentPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, lineCurrentPhaseC);
    case Attributes::ActiveCurrentPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activeCurrentPhaseC);
    case Attributes::ReactiveCurrentPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, reactiveCurrentPhaseC);
    case Attributes::RmsVoltagePhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltagePhaseC);
    case Attributes::RmsVoltageMinPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltageMinPhaseC);
    case Attributes::RmsVoltageMaxPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltageMaxPhaseC);
    case Attributes::RmsCurrentPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsCurrentPhaseC);
    case Attributes::RmsCurrentMinPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsCurrentMinPhaseC);
    case Attributes::RmsCurrentMaxPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsCurrentMaxPhaseC);
    case Attributes::ActivePowerPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activePowerPhaseC);
    case Attributes::ActivePowerMinPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activePowerMinPhaseC);
    case Attributes::ActivePowerMaxPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, activePowerMaxPhaseC);
    case Attributes::ReactivePowerPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, reactivePowerPhaseC);
    case Attributes::ApparentPowerPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, apparentPowerPhaseC);
    case Attributes::PowerFactorPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, powerFactorPhaseC);
    case Attributes::AverageRmsVoltageMeasurementPeriodPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageRmsVoltageMeasurementPeriodPhaseC);
    case Attributes::AverageRmsOverVoltageCounterPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageRmsOverVoltageCounterPhaseC);
    case Attributes::AverageRmsUnderVoltageCounterPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, averageRmsUnderVoltageCounterPhaseC);
    case Attributes::RmsExtremeOverVoltagePeriodPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsExtremeOverVoltagePeriodPhaseC);
    case Attributes::RmsExtremeUnderVoltagePeriodPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsExtremeUnderVoltagePeriodPhaseC);
    case Attributes::RmsVoltageSagPeriodPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltageSagPeriodPhaseC);
    case Attributes::RmsVoltageSwellPeriodPhaseC::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rmsVoltageSwellPeriodPhaseC);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace ElectricalMeasurement
namespace UnitTesting {
namespace Structs {

namespace SimpleStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kA), a);
    encoder.Encode(to_underlying(Fields::kB), b);
    encoder.Encode(to_underlying(Fields::kC), c);
    encoder.Encode(to_underlying(Fields::kD), d);
    encoder.Encode(to_underlying(Fields::kE), e);
    encoder.Encode(to_underlying(Fields::kF), f);
    encoder.Encode(to_underlying(Fields::kG), g);
    encoder.Encode(to_underlying(Fields::kH), h);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kA))
        {
            err = DataModel::Decode(reader, a);
        }
        else if (__context_tag == to_underlying(Fields::kB))
        {
            err = DataModel::Decode(reader, b);
        }
        else if (__context_tag == to_underlying(Fields::kC))
        {
            err = DataModel::Decode(reader, c);
        }
        else if (__context_tag == to_underlying(Fields::kD))
        {
            err = DataModel::Decode(reader, d);
        }
        else if (__context_tag == to_underlying(Fields::kE))
        {
            err = DataModel::Decode(reader, e);
        }
        else if (__context_tag == to_underlying(Fields::kF))
        {
            err = DataModel::Decode(reader, f);
        }
        else if (__context_tag == to_underlying(Fields::kG))
        {
            err = DataModel::Decode(reader, g);
        }
        else if (__context_tag == to_underlying(Fields::kH))
        {
            err = DataModel::Decode(reader, h);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace SimpleStruct

namespace TestFabricScoped {
CHIP_ERROR Type::EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    return DoEncode(aWriter, aTag, NullOptional);
}

CHIP_ERROR Type::EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const
{
    return DoEncode(aWriter, aTag, MakeOptional(aAccessingFabricIndex));
}

CHIP_ERROR Type::DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const
{
    bool includeSensitive = !aAccessingFabricIndex.HasValue() || (aAccessingFabricIndex.Value() == fabricIndex);

    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };

    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kFabricSensitiveInt8u), fabricSensitiveInt8u);
    }
    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kOptionalFabricSensitiveInt8u), optionalFabricSensitiveInt8u);
    }
    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kNullableFabricSensitiveInt8u), nullableFabricSensitiveInt8u);
    }
    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kNullableOptionalFabricSensitiveInt8u), nullableOptionalFabricSensitiveInt8u);
    }
    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kFabricSensitiveCharString), fabricSensitiveCharString);
    }
    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kFabricSensitiveStruct), fabricSensitiveStruct);
    }
    if (includeSensitive)
    {
        encoder.Encode(to_underlying(Fields::kFabricSensitiveInt8uList), fabricSensitiveInt8uList);
    }
    if (aAccessingFabricIndex.HasValue())
    {
        encoder.Encode(to_underlying(Fields::kFabricIndex), fabricIndex);
    }

    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kFabricSensitiveInt8u))
        {
            err = DataModel::Decode(reader, fabricSensitiveInt8u);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalFabricSensitiveInt8u))
        {
            err = DataModel::Decode(reader, optionalFabricSensitiveInt8u);
        }
        else if (__context_tag == to_underlying(Fields::kNullableFabricSensitiveInt8u))
        {
            err = DataModel::Decode(reader, nullableFabricSensitiveInt8u);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalFabricSensitiveInt8u))
        {
            err = DataModel::Decode(reader, nullableOptionalFabricSensitiveInt8u);
        }
        else if (__context_tag == to_underlying(Fields::kFabricSensitiveCharString))
        {
            err = DataModel::Decode(reader, fabricSensitiveCharString);
        }
        else if (__context_tag == to_underlying(Fields::kFabricSensitiveStruct))
        {
            err = DataModel::Decode(reader, fabricSensitiveStruct);
        }
        else if (__context_tag == to_underlying(Fields::kFabricSensitiveInt8uList))
        {
            err = DataModel::Decode(reader, fabricSensitiveInt8uList);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace TestFabricScoped

namespace NullablesAndOptionalsStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNullableInt), nullableInt);
    encoder.Encode(to_underlying(Fields::kOptionalInt), optionalInt);
    encoder.Encode(to_underlying(Fields::kNullableOptionalInt), nullableOptionalInt);
    encoder.Encode(to_underlying(Fields::kNullableString), nullableString);
    encoder.Encode(to_underlying(Fields::kOptionalString), optionalString);
    encoder.Encode(to_underlying(Fields::kNullableOptionalString), nullableOptionalString);
    encoder.Encode(to_underlying(Fields::kNullableStruct), nullableStruct);
    encoder.Encode(to_underlying(Fields::kOptionalStruct), optionalStruct);
    encoder.Encode(to_underlying(Fields::kNullableOptionalStruct), nullableOptionalStruct);
    encoder.Encode(to_underlying(Fields::kNullableList), nullableList);
    encoder.Encode(to_underlying(Fields::kOptionalList), optionalList);
    encoder.Encode(to_underlying(Fields::kNullableOptionalList), nullableOptionalList);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNullableInt))
        {
            err = DataModel::Decode(reader, nullableInt);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalInt))
        {
            err = DataModel::Decode(reader, optionalInt);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalInt))
        {
            err = DataModel::Decode(reader, nullableOptionalInt);
        }
        else if (__context_tag == to_underlying(Fields::kNullableString))
        {
            err = DataModel::Decode(reader, nullableString);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalString))
        {
            err = DataModel::Decode(reader, optionalString);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalString))
        {
            err = DataModel::Decode(reader, nullableOptionalString);
        }
        else if (__context_tag == to_underlying(Fields::kNullableStruct))
        {
            err = DataModel::Decode(reader, nullableStruct);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalStruct))
        {
            err = DataModel::Decode(reader, optionalStruct);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalStruct))
        {
            err = DataModel::Decode(reader, nullableOptionalStruct);
        }
        else if (__context_tag == to_underlying(Fields::kNullableList))
        {
            err = DataModel::Decode(reader, nullableList);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalList))
        {
            err = DataModel::Decode(reader, optionalList);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalList))
        {
            err = DataModel::Decode(reader, nullableOptionalList);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace NullablesAndOptionalsStruct

namespace NestedStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kA), a);
    encoder.Encode(to_underlying(Fields::kB), b);
    encoder.Encode(to_underlying(Fields::kC), c);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kA))
        {
            err = DataModel::Decode(reader, a);
        }
        else if (__context_tag == to_underlying(Fields::kB))
        {
            err = DataModel::Decode(reader, b);
        }
        else if (__context_tag == to_underlying(Fields::kC))
        {
            err = DataModel::Decode(reader, c);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace NestedStruct

namespace NestedStructList {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kA), a);
    encoder.Encode(to_underlying(Fields::kB), b);
    encoder.Encode(to_underlying(Fields::kC), c);
    encoder.Encode(to_underlying(Fields::kD), d);
    encoder.Encode(to_underlying(Fields::kE), e);
    encoder.Encode(to_underlying(Fields::kF), f);
    encoder.Encode(to_underlying(Fields::kG), g);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kA))
        {
            err = DataModel::Decode(reader, a);
        }
        else if (__context_tag == to_underlying(Fields::kB))
        {
            err = DataModel::Decode(reader, b);
        }
        else if (__context_tag == to_underlying(Fields::kC))
        {
            err = DataModel::Decode(reader, c);
        }
        else if (__context_tag == to_underlying(Fields::kD))
        {
            err = DataModel::Decode(reader, d);
        }
        else if (__context_tag == to_underlying(Fields::kE))
        {
            err = DataModel::Decode(reader, e);
        }
        else if (__context_tag == to_underlying(Fields::kF))
        {
            err = DataModel::Decode(reader, f);
        }
        else if (__context_tag == to_underlying(Fields::kG))
        {
            err = DataModel::Decode(reader, g);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace NestedStructList

namespace DoubleNestedStructList {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kA), a);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kA))
        {
            err = DataModel::Decode(reader, a);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace DoubleNestedStructList

namespace TestListStructOctet {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMember1), member1);
    encoder.Encode(to_underlying(Fields::kMember2), member2);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kMember1))
        {
            err = DataModel::Decode(reader, member1);
        }
        else if (__context_tag == to_underlying(Fields::kMember2))
        {
            err = DataModel::Decode(reader, member2);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace TestListStructOctet
} // namespace Structs

namespace Commands {
namespace Test {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Test.
namespace TestSpecificResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kReturnValue), returnValue);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kReturnValue))
        {
            err = DataModel::Decode(reader, returnValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestSpecificResponse.
namespace TestNotHandled {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace TestNotHandled.
namespace TestAddArgumentsResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kReturnValue), returnValue);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kReturnValue))
        {
            err = DataModel::Decode(reader, returnValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestAddArgumentsResponse.
namespace TestSpecific {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace TestSpecific.
namespace TestSimpleArgumentResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kReturnValue), returnValue);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kReturnValue))
        {
            err = DataModel::Decode(reader, returnValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestSimpleArgumentResponse.
namespace TestUnknownCommand {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace TestUnknownCommand.
namespace TestStructArrayArgumentResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    encoder.Encode(to_underlying(Fields::kArg2), arg2);
    encoder.Encode(to_underlying(Fields::kArg3), arg3);
    encoder.Encode(to_underlying(Fields::kArg4), arg4);
    encoder.Encode(to_underlying(Fields::kArg5), arg5);
    encoder.Encode(to_underlying(Fields::kArg6), arg6);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else if (__context_tag == to_underlying(Fields::kArg2))
        {
            err = DataModel::Decode(reader, arg2);
        }
        else if (__context_tag == to_underlying(Fields::kArg3))
        {
            err = DataModel::Decode(reader, arg3);
        }
        else if (__context_tag == to_underlying(Fields::kArg4))
        {
            err = DataModel::Decode(reader, arg4);
        }
        else if (__context_tag == to_underlying(Fields::kArg5))
        {
            err = DataModel::Decode(reader, arg5);
        }
        else if (__context_tag == to_underlying(Fields::kArg6))
        {
            err = DataModel::Decode(reader, arg6);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestStructArrayArgumentResponse.
namespace TestAddArguments {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    encoder.Encode(to_underlying(Fields::kArg2), arg2);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else if (__context_tag == to_underlying(Fields::kArg2))
        {
            err = DataModel::Decode(reader, arg2);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestAddArguments.
namespace TestListInt8UReverseResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestListInt8UReverseResponse.
namespace TestSimpleArgumentRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestSimpleArgumentRequest.
namespace TestEnumsResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    encoder.Encode(to_underlying(Fields::kArg2), arg2);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else if (__context_tag == to_underlying(Fields::kArg2))
        {
            err = DataModel::Decode(reader, arg2);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestEnumsResponse.
namespace TestStructArrayArgumentRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    encoder.Encode(to_underlying(Fields::kArg2), arg2);
    encoder.Encode(to_underlying(Fields::kArg3), arg3);
    encoder.Encode(to_underlying(Fields::kArg4), arg4);
    encoder.Encode(to_underlying(Fields::kArg5), arg5);
    encoder.Encode(to_underlying(Fields::kArg6), arg6);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else if (__context_tag == to_underlying(Fields::kArg2))
        {
            err = DataModel::Decode(reader, arg2);
        }
        else if (__context_tag == to_underlying(Fields::kArg3))
        {
            err = DataModel::Decode(reader, arg3);
        }
        else if (__context_tag == to_underlying(Fields::kArg4))
        {
            err = DataModel::Decode(reader, arg4);
        }
        else if (__context_tag == to_underlying(Fields::kArg5))
        {
            err = DataModel::Decode(reader, arg5);
        }
        else if (__context_tag == to_underlying(Fields::kArg6))
        {
            err = DataModel::Decode(reader, arg6);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestStructArrayArgumentRequest.
namespace TestNullableOptionalResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kWasPresent), wasPresent);
    encoder.Encode(to_underlying(Fields::kWasNull), wasNull);
    encoder.Encode(to_underlying(Fields::kValue), value);
    encoder.Encode(to_underlying(Fields::kOriginalValue), originalValue);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kWasPresent))
        {
            err = DataModel::Decode(reader, wasPresent);
        }
        else if (__context_tag == to_underlying(Fields::kWasNull))
        {
            err = DataModel::Decode(reader, wasNull);
        }
        else if (__context_tag == to_underlying(Fields::kValue))
        {
            err = DataModel::Decode(reader, value);
        }
        else if (__context_tag == to_underlying(Fields::kOriginalValue))
        {
            err = DataModel::Decode(reader, originalValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestNullableOptionalResponse.
namespace TestStructArgumentRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestStructArgumentRequest.
namespace TestComplexNullableOptionalResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNullableIntWasNull), nullableIntWasNull);
    encoder.Encode(to_underlying(Fields::kNullableIntValue), nullableIntValue);
    encoder.Encode(to_underlying(Fields::kOptionalIntWasPresent), optionalIntWasPresent);
    encoder.Encode(to_underlying(Fields::kOptionalIntValue), optionalIntValue);
    encoder.Encode(to_underlying(Fields::kNullableOptionalIntWasPresent), nullableOptionalIntWasPresent);
    encoder.Encode(to_underlying(Fields::kNullableOptionalIntWasNull), nullableOptionalIntWasNull);
    encoder.Encode(to_underlying(Fields::kNullableOptionalIntValue), nullableOptionalIntValue);
    encoder.Encode(to_underlying(Fields::kNullableStringWasNull), nullableStringWasNull);
    encoder.Encode(to_underlying(Fields::kNullableStringValue), nullableStringValue);
    encoder.Encode(to_underlying(Fields::kOptionalStringWasPresent), optionalStringWasPresent);
    encoder.Encode(to_underlying(Fields::kOptionalStringValue), optionalStringValue);
    encoder.Encode(to_underlying(Fields::kNullableOptionalStringWasPresent), nullableOptionalStringWasPresent);
    encoder.Encode(to_underlying(Fields::kNullableOptionalStringWasNull), nullableOptionalStringWasNull);
    encoder.Encode(to_underlying(Fields::kNullableOptionalStringValue), nullableOptionalStringValue);
    encoder.Encode(to_underlying(Fields::kNullableStructWasNull), nullableStructWasNull);
    encoder.Encode(to_underlying(Fields::kNullableStructValue), nullableStructValue);
    encoder.Encode(to_underlying(Fields::kOptionalStructWasPresent), optionalStructWasPresent);
    encoder.Encode(to_underlying(Fields::kOptionalStructValue), optionalStructValue);
    encoder.Encode(to_underlying(Fields::kNullableOptionalStructWasPresent), nullableOptionalStructWasPresent);
    encoder.Encode(to_underlying(Fields::kNullableOptionalStructWasNull), nullableOptionalStructWasNull);
    encoder.Encode(to_underlying(Fields::kNullableOptionalStructValue), nullableOptionalStructValue);
    encoder.Encode(to_underlying(Fields::kNullableListWasNull), nullableListWasNull);
    encoder.Encode(to_underlying(Fields::kNullableListValue), nullableListValue);
    encoder.Encode(to_underlying(Fields::kOptionalListWasPresent), optionalListWasPresent);
    encoder.Encode(to_underlying(Fields::kOptionalListValue), optionalListValue);
    encoder.Encode(to_underlying(Fields::kNullableOptionalListWasPresent), nullableOptionalListWasPresent);
    encoder.Encode(to_underlying(Fields::kNullableOptionalListWasNull), nullableOptionalListWasNull);
    encoder.Encode(to_underlying(Fields::kNullableOptionalListValue), nullableOptionalListValue);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNullableIntWasNull))
        {
            err = DataModel::Decode(reader, nullableIntWasNull);
        }
        else if (__context_tag == to_underlying(Fields::kNullableIntValue))
        {
            err = DataModel::Decode(reader, nullableIntValue);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalIntWasPresent))
        {
            err = DataModel::Decode(reader, optionalIntWasPresent);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalIntValue))
        {
            err = DataModel::Decode(reader, optionalIntValue);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalIntWasPresent))
        {
            err = DataModel::Decode(reader, nullableOptionalIntWasPresent);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalIntWasNull))
        {
            err = DataModel::Decode(reader, nullableOptionalIntWasNull);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalIntValue))
        {
            err = DataModel::Decode(reader, nullableOptionalIntValue);
        }
        else if (__context_tag == to_underlying(Fields::kNullableStringWasNull))
        {
            err = DataModel::Decode(reader, nullableStringWasNull);
        }
        else if (__context_tag == to_underlying(Fields::kNullableStringValue))
        {
            err = DataModel::Decode(reader, nullableStringValue);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalStringWasPresent))
        {
            err = DataModel::Decode(reader, optionalStringWasPresent);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalStringValue))
        {
            err = DataModel::Decode(reader, optionalStringValue);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalStringWasPresent))
        {
            err = DataModel::Decode(reader, nullableOptionalStringWasPresent);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalStringWasNull))
        {
            err = DataModel::Decode(reader, nullableOptionalStringWasNull);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalStringValue))
        {
            err = DataModel::Decode(reader, nullableOptionalStringValue);
        }
        else if (__context_tag == to_underlying(Fields::kNullableStructWasNull))
        {
            err = DataModel::Decode(reader, nullableStructWasNull);
        }
        else if (__context_tag == to_underlying(Fields::kNullableStructValue))
        {
            err = DataModel::Decode(reader, nullableStructValue);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalStructWasPresent))
        {
            err = DataModel::Decode(reader, optionalStructWasPresent);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalStructValue))
        {
            err = DataModel::Decode(reader, optionalStructValue);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalStructWasPresent))
        {
            err = DataModel::Decode(reader, nullableOptionalStructWasPresent);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalStructWasNull))
        {
            err = DataModel::Decode(reader, nullableOptionalStructWasNull);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalStructValue))
        {
            err = DataModel::Decode(reader, nullableOptionalStructValue);
        }
        else if (__context_tag == to_underlying(Fields::kNullableListWasNull))
        {
            err = DataModel::Decode(reader, nullableListWasNull);
        }
        else if (__context_tag == to_underlying(Fields::kNullableListValue))
        {
            err = DataModel::Decode(reader, nullableListValue);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalListWasPresent))
        {
            err = DataModel::Decode(reader, optionalListWasPresent);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalListValue))
        {
            err = DataModel::Decode(reader, optionalListValue);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalListWasPresent))
        {
            err = DataModel::Decode(reader, nullableOptionalListWasPresent);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalListWasNull))
        {
            err = DataModel::Decode(reader, nullableOptionalListWasNull);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalListValue))
        {
            err = DataModel::Decode(reader, nullableOptionalListValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestComplexNullableOptionalResponse.
namespace TestNestedStructArgumentRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestNestedStructArgumentRequest.
namespace BooleanResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kValue), value);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kValue))
        {
            err = DataModel::Decode(reader, value);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace BooleanResponse.
namespace TestListStructArgumentRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestListStructArgumentRequest.
namespace SimpleStructResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SimpleStructResponse.
namespace TestListInt8UArgumentRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestListInt8UArgumentRequest.
namespace TestEmitTestEventResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kValue), value);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kValue))
        {
            err = DataModel::Decode(reader, value);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestEmitTestEventResponse.
namespace TestNestedStructListArgumentRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestNestedStructListArgumentRequest.
namespace TestEmitTestFabricScopedEventResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kValue), value);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kValue))
        {
            err = DataModel::Decode(reader, value);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestEmitTestFabricScopedEventResponse.
namespace TestListNestedStructListArgumentRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestListNestedStructListArgumentRequest.
namespace TestBatchHelperResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kBuffer), buffer);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kBuffer))
        {
            err = DataModel::Decode(reader, buffer);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestBatchHelperResponse.
namespace TestListInt8UReverseRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestListInt8UReverseRequest.
namespace TestEnumsRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    encoder.Encode(to_underlying(Fields::kArg2), arg2);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else if (__context_tag == to_underlying(Fields::kArg2))
        {
            err = DataModel::Decode(reader, arg2);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestEnumsRequest.
namespace TestNullableOptionalRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestNullableOptionalRequest.
namespace TestComplexNullableOptionalRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kNullableInt), nullableInt);
    encoder.Encode(to_underlying(Fields::kOptionalInt), optionalInt);
    encoder.Encode(to_underlying(Fields::kNullableOptionalInt), nullableOptionalInt);
    encoder.Encode(to_underlying(Fields::kNullableString), nullableString);
    encoder.Encode(to_underlying(Fields::kOptionalString), optionalString);
    encoder.Encode(to_underlying(Fields::kNullableOptionalString), nullableOptionalString);
    encoder.Encode(to_underlying(Fields::kNullableStruct), nullableStruct);
    encoder.Encode(to_underlying(Fields::kOptionalStruct), optionalStruct);
    encoder.Encode(to_underlying(Fields::kNullableOptionalStruct), nullableOptionalStruct);
    encoder.Encode(to_underlying(Fields::kNullableList), nullableList);
    encoder.Encode(to_underlying(Fields::kOptionalList), optionalList);
    encoder.Encode(to_underlying(Fields::kNullableOptionalList), nullableOptionalList);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kNullableInt))
        {
            err = DataModel::Decode(reader, nullableInt);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalInt))
        {
            err = DataModel::Decode(reader, optionalInt);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalInt))
        {
            err = DataModel::Decode(reader, nullableOptionalInt);
        }
        else if (__context_tag == to_underlying(Fields::kNullableString))
        {
            err = DataModel::Decode(reader, nullableString);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalString))
        {
            err = DataModel::Decode(reader, optionalString);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalString))
        {
            err = DataModel::Decode(reader, nullableOptionalString);
        }
        else if (__context_tag == to_underlying(Fields::kNullableStruct))
        {
            err = DataModel::Decode(reader, nullableStruct);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalStruct))
        {
            err = DataModel::Decode(reader, optionalStruct);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalStruct))
        {
            err = DataModel::Decode(reader, nullableOptionalStruct);
        }
        else if (__context_tag == to_underlying(Fields::kNullableList))
        {
            err = DataModel::Decode(reader, nullableList);
        }
        else if (__context_tag == to_underlying(Fields::kOptionalList))
        {
            err = DataModel::Decode(reader, optionalList);
        }
        else if (__context_tag == to_underlying(Fields::kNullableOptionalList))
        {
            err = DataModel::Decode(reader, nullableOptionalList);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestComplexNullableOptionalRequest.
namespace SimpleStructEchoRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SimpleStructEchoRequest.
namespace TimedInvokeRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace TimedInvokeRequest.
namespace TestSimpleOptionalArgumentRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestSimpleOptionalArgumentRequest.
namespace TestEmitTestEventRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    encoder.Encode(to_underlying(Fields::kArg2), arg2);
    encoder.Encode(to_underlying(Fields::kArg3), arg3);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else if (__context_tag == to_underlying(Fields::kArg2))
        {
            err = DataModel::Decode(reader, arg2);
        }
        else if (__context_tag == to_underlying(Fields::kArg3))
        {
            err = DataModel::Decode(reader, arg3);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestEmitTestEventRequest.
namespace TestEmitTestFabricScopedEventRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestEmitTestFabricScopedEventRequest.
namespace TestBatchHelperRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kSleepBeforeResponseTimeMs), sleepBeforeResponseTimeMs);
    encoder.Encode(to_underlying(Fields::kSizeOfResponseBuffer), sizeOfResponseBuffer);
    encoder.Encode(to_underlying(Fields::kFillCharacter), fillCharacter);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSleepBeforeResponseTimeMs))
        {
            err = DataModel::Decode(reader, sleepBeforeResponseTimeMs);
        }
        else if (__context_tag == to_underlying(Fields::kSizeOfResponseBuffer))
        {
            err = DataModel::Decode(reader, sizeOfResponseBuffer);
        }
        else if (__context_tag == to_underlying(Fields::kFillCharacter))
        {
            err = DataModel::Decode(reader, fillCharacter);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestBatchHelperRequest.
namespace TestSecondBatchHelperRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kSleepBeforeResponseTimeMs), sleepBeforeResponseTimeMs);
    encoder.Encode(to_underlying(Fields::kSizeOfResponseBuffer), sizeOfResponseBuffer);
    encoder.Encode(to_underlying(Fields::kFillCharacter), fillCharacter);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kSleepBeforeResponseTimeMs))
        {
            err = DataModel::Decode(reader, sleepBeforeResponseTimeMs);
        }
        else if (__context_tag == to_underlying(Fields::kSizeOfResponseBuffer))
        {
            err = DataModel::Decode(reader, sizeOfResponseBuffer);
        }
        else if (__context_tag == to_underlying(Fields::kFillCharacter))
        {
            err = DataModel::Decode(reader, fillCharacter);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestSecondBatchHelperRequest.
namespace TestDifferentVendorMeiRequest {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestDifferentVendorMeiRequest.
namespace TestDifferentVendorMeiResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    encoder.Encode(to_underlying(Fields::kEventNumber), eventNumber);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else if (__context_tag == to_underlying(Fields::kEventNumber))
        {
            err = DataModel::Decode(reader, eventNumber);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestDifferentVendorMeiResponse.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::Boolean::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, boolean);
    case Attributes::Bitmap8::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, bitmap8);
    case Attributes::Bitmap16::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, bitmap16);
    case Attributes::Bitmap32::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, bitmap32);
    case Attributes::Bitmap64::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, bitmap64);
    case Attributes::Int8u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int8u);
    case Attributes::Int16u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int16u);
    case Attributes::Int24u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int24u);
    case Attributes::Int32u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int32u);
    case Attributes::Int40u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int40u);
    case Attributes::Int48u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int48u);
    case Attributes::Int56u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int56u);
    case Attributes::Int64u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int64u);
    case Attributes::Int8s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int8s);
    case Attributes::Int16s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int16s);
    case Attributes::Int24s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int24s);
    case Attributes::Int32s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int32s);
    case Attributes::Int40s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int40s);
    case Attributes::Int48s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int48s);
    case Attributes::Int56s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int56s);
    case Attributes::Int64s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, int64s);
    case Attributes::Enum8::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, enum8);
    case Attributes::Enum16::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, enum16);
    case Attributes::FloatSingle::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, floatSingle);
    case Attributes::FloatDouble::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, floatDouble);
    case Attributes::OctetString::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, octetString);
    case Attributes::ListInt8u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, listInt8u);
    case Attributes::ListOctetString::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, listOctetString);
    case Attributes::ListStructOctetString::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, listStructOctetString);
    case Attributes::LongOctetString::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, longOctetString);
    case Attributes::CharString::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, charString);
    case Attributes::LongCharString::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, longCharString);
    case Attributes::EpochUs::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, epochUs);
    case Attributes::EpochS::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, epochS);
    case Attributes::VendorId::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, vendorId);
    case Attributes::ListNullablesAndOptionalsStruct::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, listNullablesAndOptionalsStruct);
    case Attributes::EnumAttr::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, enumAttr);
    case Attributes::StructAttr::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, structAttr);
    case Attributes::RangeRestrictedInt8u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rangeRestrictedInt8u);
    case Attributes::RangeRestrictedInt8s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rangeRestrictedInt8s);
    case Attributes::RangeRestrictedInt16u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rangeRestrictedInt16u);
    case Attributes::RangeRestrictedInt16s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, rangeRestrictedInt16s);
    case Attributes::ListLongOctetString::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, listLongOctetString);
    case Attributes::ListFabricScoped::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, listFabricScoped);
    case Attributes::TimedWriteBoolean::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, timedWriteBoolean);
    case Attributes::GeneralErrorBoolean::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generalErrorBoolean);
    case Attributes::ClusterErrorBoolean::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterErrorBoolean);
    case Attributes::Unsupported::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, unsupported);
    case Attributes::NullableBoolean::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableBoolean);
    case Attributes::NullableBitmap8::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableBitmap8);
    case Attributes::NullableBitmap16::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableBitmap16);
    case Attributes::NullableBitmap32::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableBitmap32);
    case Attributes::NullableBitmap64::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableBitmap64);
    case Attributes::NullableInt8u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt8u);
    case Attributes::NullableInt16u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt16u);
    case Attributes::NullableInt24u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt24u);
    case Attributes::NullableInt32u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt32u);
    case Attributes::NullableInt40u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt40u);
    case Attributes::NullableInt48u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt48u);
    case Attributes::NullableInt56u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt56u);
    case Attributes::NullableInt64u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt64u);
    case Attributes::NullableInt8s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt8s);
    case Attributes::NullableInt16s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt16s);
    case Attributes::NullableInt24s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt24s);
    case Attributes::NullableInt32s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt32s);
    case Attributes::NullableInt40s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt40s);
    case Attributes::NullableInt48s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt48s);
    case Attributes::NullableInt56s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt56s);
    case Attributes::NullableInt64s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableInt64s);
    case Attributes::NullableEnum8::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableEnum8);
    case Attributes::NullableEnum16::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableEnum16);
    case Attributes::NullableFloatSingle::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableFloatSingle);
    case Attributes::NullableFloatDouble::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableFloatDouble);
    case Attributes::NullableOctetString::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableOctetString);
    case Attributes::NullableCharString::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableCharString);
    case Attributes::NullableEnumAttr::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableEnumAttr);
    case Attributes::NullableStruct::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableStruct);
    case Attributes::NullableRangeRestrictedInt8u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableRangeRestrictedInt8u);
    case Attributes::NullableRangeRestrictedInt8s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableRangeRestrictedInt8s);
    case Attributes::NullableRangeRestrictedInt16u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableRangeRestrictedInt16u);
    case Attributes::NullableRangeRestrictedInt16s::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, nullableRangeRestrictedInt16s);
    case Attributes::WriteOnlyInt8u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, writeOnlyInt8u);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    case Attributes::MeiInt8u::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, meiInt8u);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace TestEvent {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kArg1), arg1));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kArg2), arg2));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kArg3), arg3));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kArg4), arg4));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kArg5), arg5));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kArg6), arg6));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else if (__context_tag == to_underlying(Fields::kArg2))
        {
            err = DataModel::Decode(reader, arg2);
        }
        else if (__context_tag == to_underlying(Fields::kArg3))
        {
            err = DataModel::Decode(reader, arg3);
        }
        else if (__context_tag == to_underlying(Fields::kArg4))
        {
            err = DataModel::Decode(reader, arg4);
        }
        else if (__context_tag == to_underlying(Fields::kArg5))
        {
            err = DataModel::Decode(reader, arg5);
        }
        else if (__context_tag == to_underlying(Fields::kArg6))
        {
            err = DataModel::Decode(reader, arg6);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestEvent.
namespace TestFabricScopedEvent {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kFabricIndex), fabricIndex));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestFabricScopedEvent.
namespace TestDifferentVendorMeiEvent {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kArg1), arg1));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace TestDifferentVendorMeiEvent.
} // namespace Events

} // namespace UnitTesting
namespace FaultInjection {

namespace Commands {
namespace FailAtFault {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kType), type);
    encoder.Encode(to_underlying(Fields::kId), id);
    encoder.Encode(to_underlying(Fields::kNumCallsToSkip), numCallsToSkip);
    encoder.Encode(to_underlying(Fields::kNumCallsToFail), numCallsToFail);
    encoder.Encode(to_underlying(Fields::kTakeMutex), takeMutex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kType))
        {
            err = DataModel::Decode(reader, type);
        }
        else if (__context_tag == to_underlying(Fields::kId))
        {
            err = DataModel::Decode(reader, id);
        }
        else if (__context_tag == to_underlying(Fields::kNumCallsToSkip))
        {
            err = DataModel::Decode(reader, numCallsToSkip);
        }
        else if (__context_tag == to_underlying(Fields::kNumCallsToFail))
        {
            err = DataModel::Decode(reader, numCallsToFail);
        }
        else if (__context_tag == to_underlying(Fields::kTakeMutex))
        {
            err = DataModel::Decode(reader, takeMutex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace FailAtFault.
namespace FailRandomlyAtFault {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kType), type);
    encoder.Encode(to_underlying(Fields::kId), id);
    encoder.Encode(to_underlying(Fields::kPercentage), percentage);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kType))
        {
            err = DataModel::Decode(reader, type);
        }
        else if (__context_tag == to_underlying(Fields::kId))
        {
            err = DataModel::Decode(reader, id);
        }
        else if (__context_tag == to_underlying(Fields::kPercentage))
        {
            err = DataModel::Decode(reader, percentage);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace FailRandomlyAtFault.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {} // namespace Events

} // namespace FaultInjection
namespace SampleMei {

namespace Commands {
namespace Ping {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }
    }
}
} // namespace Ping.
namespace AddArgumentsResponse {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kReturnValue), returnValue);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kReturnValue))
        {
            err = DataModel::Decode(reader, returnValue);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AddArgumentsResponse.
namespace AddArguments {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kArg1), arg1);
    encoder.Encode(to_underlying(Fields::kArg2), arg2);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kArg1))
        {
            err = DataModel::Decode(reader, arg1);
        }
        else if (__context_tag == to_underlying(Fields::kArg2))
        {
            err = DataModel::Decode(reader, arg2);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace AddArguments.
} // namespace Commands

namespace Attributes {
CHIP_ERROR TypeInfo::DecodableType::Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path)
{
    switch (path.mAttributeId)
    {
    case Attributes::FlipFlop::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, flipFlop);
    case Attributes::GeneratedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, generatedCommandList);
    case Attributes::AcceptedCommandList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, acceptedCommandList);
    case Attributes::EventList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, eventList);
    case Attributes::AttributeList::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, attributeList);
    case Attributes::FeatureMap::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, featureMap);
    case Attributes::ClusterRevision::TypeInfo::GetAttributeId():
        return DataModel::Decode(reader, clusterRevision);
    default:
        return CHIP_NO_ERROR;
    }
}
} // namespace Attributes

namespace Events {
namespace PingCountEvent {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(aWriter.StartContainer(aTag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kCount), count));
    ReturnErrorOnFailure(DataModel::Encode(aWriter, TLV::ContextTag(Fields::kFabricIndex), fabricIndex));
    return aWriter.EndContainer(outer);
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        auto __element = __iterator.Next();
        if (std::holds_alternative<CHIP_ERROR>(__element))
        {
            return std::get<CHIP_ERROR>(__element);
        }

        CHIP_ERROR err              = CHIP_NO_ERROR;
        const uint8_t __context_tag = std::get<uint8_t>(__element);

        if (__context_tag == to_underlying(Fields::kCount))
        {
            err = DataModel::Decode(reader, count);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }
        else
        {
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace PingCountEvent.
} // namespace Events

} // namespace SampleMei

} // namespace Clusters

bool CommandNeedsTimedInvoke(ClusterId aCluster, CommandId aCommand)
{
    // Maybe it would be smaller code to codegen a table and walk over it?
    // Not sure.
    switch (aCluster)
    {
    case Clusters::AdministratorCommissioning::Id: {
        switch (aCommand)
        {
        case Clusters::AdministratorCommissioning::Commands::OpenCommissioningWindow::Id:
        case Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id:
        case Clusters::AdministratorCommissioning::Commands::RevokeCommissioning::Id:
            return true;
        default:
            return false;
        }
    }
    case Clusters::EnergyEvse::Id: {
        switch (aCommand)
        {
        case Clusters::EnergyEvse::Commands::Disable::Id:
        case Clusters::EnergyEvse::Commands::EnableCharging::Id:
        case Clusters::EnergyEvse::Commands::EnableDischarging::Id:
        case Clusters::EnergyEvse::Commands::StartDiagnostics::Id:
        case Clusters::EnergyEvse::Commands::SetTargets::Id:
        case Clusters::EnergyEvse::Commands::GetTargets::Id:
        case Clusters::EnergyEvse::Commands::ClearTargets::Id:
            return true;
        default:
            return false;
        }
    }
    case Clusters::DoorLock::Id: {
        switch (aCommand)
        {
        case Clusters::DoorLock::Commands::LockDoor::Id:
        case Clusters::DoorLock::Commands::UnlockDoor::Id:
        case Clusters::DoorLock::Commands::UnlockWithTimeout::Id:
        case Clusters::DoorLock::Commands::SetUser::Id:
        case Clusters::DoorLock::Commands::ClearUser::Id:
        case Clusters::DoorLock::Commands::SetCredential::Id:
        case Clusters::DoorLock::Commands::ClearCredential::Id:
        case Clusters::DoorLock::Commands::UnboltDoor::Id:
        case Clusters::DoorLock::Commands::SetAliroReaderConfig::Id:
        case Clusters::DoorLock::Commands::ClearAliroReaderConfig::Id:
            return true;
        default:
            return false;
        }
    }
    case Clusters::AccountLogin::Id: {
        switch (aCommand)
        {
        case Clusters::AccountLogin::Commands::GetSetupPIN::Id:
        case Clusters::AccountLogin::Commands::Login::Id:
        case Clusters::AccountLogin::Commands::Logout::Id:
            return true;
        default:
            return false;
        }
    }
    case Clusters::UnitTesting::Id: {
        switch (aCommand)
        {
        case Clusters::UnitTesting::Commands::TimedInvokeRequest::Id:
            return true;
        default:
            return false;
        }
    }
    default:
        break;
    }

    return false;
}

bool CommandIsFabricScoped(ClusterId aCluster, CommandId aCommand)
{
    // Maybe it would be smaller code to codegen a table and walk over it?
    // Not sure.
    switch (aCluster)
    {
    case Clusters::Identify::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::Groups::Id: {
        switch (aCommand)
        {
        case Clusters::Groups::Commands::AddGroup::Id:
            return true;
        case Clusters::Groups::Commands::ViewGroup::Id:
            return true;
        case Clusters::Groups::Commands::GetGroupMembership::Id:
            return true;
        case Clusters::Groups::Commands::RemoveGroup::Id:
            return true;
        case Clusters::Groups::Commands::RemoveAllGroups::Id:
            return true;
        case Clusters::Groups::Commands::AddGroupIfIdentifying::Id:
            return true;
        default:
            return false;
        }
    }
    case Clusters::OnOff::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::LevelControl::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::Actions::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::BasicInformation::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::OtaSoftwareUpdateProvider::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::OtaSoftwareUpdateRequestor::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::GeneralCommissioning::Id: {
        switch (aCommand)
        {
        case Clusters::GeneralCommissioning::Commands::CommissioningComplete::Id:
            return true;
        default:
            return false;
        }
    }
    case Clusters::NetworkCommissioning::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::DiagnosticLogs::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::GeneralDiagnostics::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::SoftwareDiagnostics::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::ThreadNetworkDiagnostics::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::WiFiNetworkDiagnostics::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::EthernetNetworkDiagnostics::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::TimeSynchronization::Id: {
        switch (aCommand)
        {
        case Clusters::TimeSynchronization::Commands::SetTrustedTimeSource::Id:
            return true;
        default:
            return false;
        }
    }
    case Clusters::AdministratorCommissioning::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::OperationalCredentials::Id: {
        switch (aCommand)
        {
        case Clusters::OperationalCredentials::Commands::UpdateNOC::Id:
            return true;
        case Clusters::OperationalCredentials::Commands::UpdateFabricLabel::Id:
            return true;
        default:
            return false;
        }
    }
    case Clusters::GroupKeyManagement::Id: {
        switch (aCommand)
        {
        case Clusters::GroupKeyManagement::Commands::KeySetWrite::Id:
            return true;
        case Clusters::GroupKeyManagement::Commands::KeySetRead::Id:
            return true;
        case Clusters::GroupKeyManagement::Commands::KeySetRemove::Id:
            return true;
        case Clusters::GroupKeyManagement::Commands::KeySetReadAllIndices::Id:
            return true;
        default:
            return false;
        }
    }
    case Clusters::IcdManagement::Id: {
        switch (aCommand)
        {
        case Clusters::IcdManagement::Commands::RegisterClient::Id:
            return true;
        case Clusters::IcdManagement::Commands::UnregisterClient::Id:
            return true;
        default:
            return false;
        }
    }
    case Clusters::Timer::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::OvenCavityOperationalState::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::OvenMode::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::ModeSelect::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::LaundryWasherMode::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::RvcRunMode::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::RvcCleanMode::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::TemperatureControl::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::DishwasherMode::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::SmokeCoAlarm::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::DishwasherAlarm::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::MicrowaveOvenControl::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::OperationalState::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::RvcOperationalState::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::ScenesManagement::Id: {
        switch (aCommand)
        {
        case Clusters::ScenesManagement::Commands::AddScene::Id:
            return true;
        case Clusters::ScenesManagement::Commands::ViewScene::Id:
            return true;
        case Clusters::ScenesManagement::Commands::RemoveScene::Id:
            return true;
        case Clusters::ScenesManagement::Commands::RemoveAllScenes::Id:
            return true;
        case Clusters::ScenesManagement::Commands::StoreScene::Id:
            return true;
        case Clusters::ScenesManagement::Commands::RecallScene::Id:
            return true;
        case Clusters::ScenesManagement::Commands::GetSceneMembership::Id:
            return true;
        case Clusters::ScenesManagement::Commands::CopyScene::Id:
            return true;
        default:
            return false;
        }
    }
    case Clusters::HepaFilterMonitoring::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::ActivatedCarbonFilterMonitoring::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::BooleanStateConfiguration::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::ValveConfigurationAndControl::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::DemandResponseLoadControl::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::Messages::Id: {
        switch (aCommand)
        {
        case Clusters::Messages::Commands::PresentMessagesRequest::Id:
            return true;
        case Clusters::Messages::Commands::CancelMessagesRequest::Id:
            return true;
        default:
            return false;
        }
    }
    case Clusters::DeviceEnergyManagement::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::EnergyEvse::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::EnergyEvseMode::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::DeviceEnergyManagementMode::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::DoorLock::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::WindowCovering::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::BarrierControl::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::Thermostat::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::FanControl::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::ColorControl::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::WiFiNetworkManagement::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::Channel::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::TargetNavigator::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::MediaPlayback::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::MediaInput::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::LowPower::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::KeypadInput::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::ContentLauncher::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::AudioOutput::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::ApplicationLauncher::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::AccountLogin::Id: {
        switch (aCommand)
        {
        case Clusters::AccountLogin::Commands::GetSetupPIN::Id:
            return true;
        case Clusters::AccountLogin::Commands::Login::Id:
            return true;
        case Clusters::AccountLogin::Commands::Logout::Id:
            return true;
        default:
            return false;
        }
    }
    case Clusters::ContentControl::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::ContentAppObserver::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::ElectricalMeasurement::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::UnitTesting::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::FaultInjection::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    case Clusters::SampleMei::Id: {
        switch (aCommand)
        {
        default:
            return false;
        }
    }
    }
    return false;
}

} // namespace app
} // namespace chip
