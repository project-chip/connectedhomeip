/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <app-common/zap-generated/cluster-enums.h>

namespace chip {
namespace app {
namespace Clusters {

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Identify::IdentifyEffectIdentifier val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = Identify::IdentifyEffectIdentifier;
    case EnumType::kBlink:
    case EnumType::kBreathe:
    case EnumType::kOkay:
    case EnumType::kChannelChange:
    case EnumType::kFinishEffect:
    case EnumType::kStopEffect:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_IDENTIFY_EFFECT_IDENTIFIER_BLINK:
    case EMBER_ZCL_IDENTIFY_EFFECT_IDENTIFIER_BREATHE:
    case EMBER_ZCL_IDENTIFY_EFFECT_IDENTIFIER_OKAY:
    case EMBER_ZCL_IDENTIFY_EFFECT_IDENTIFIER_CHANNEL_CHANGE:
    case EMBER_ZCL_IDENTIFY_EFFECT_IDENTIFIER_FINISH_EFFECT:
    case EMBER_ZCL_IDENTIFY_EFFECT_IDENTIFIER_STOP_EFFECT:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Identify::IdentifyEffectVariant val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = Identify::IdentifyEffectVariant;
    case EnumType::kDefault:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_IDENTIFY_EFFECT_VARIANT_DEFAULT:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Identify::IdentifyIdentifyType val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = Identify::IdentifyIdentifyType;
    case EnumType::kNone:
    case EnumType::kVisibleLight:
    case EnumType::kVisibleLED:
    case EnumType::kAudibleBeep:
    case EnumType::kDisplay:
    case EnumType::kActuator:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_IDENTIFY_IDENTIFY_TYPE_NONE:
    case EMBER_ZCL_IDENTIFY_IDENTIFY_TYPE_VISIBLE_LIGHT:
    case EMBER_ZCL_IDENTIFY_IDENTIFY_TYPE_VISIBLE_LED:
    case EMBER_ZCL_IDENTIFY_IDENTIFY_TYPE_AUDIBLE_BEEP:
    case EMBER_ZCL_IDENTIFY_IDENTIFY_TYPE_DISPLAY:
    case EMBER_ZCL_IDENTIFY_IDENTIFY_TYPE_ACTUATOR:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Scenes::ScenesCopyMode val)
{
    switch (val)
    {
        using EnumType = Scenes::ScenesCopyMode;
    case EnumType::kCopyAllScenes:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(OnOff::OnOffDelayedAllOffEffectVariant val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = OnOff::OnOffDelayedAllOffEffectVariant;
    case EnumType::kFadeToOffIn0p8Seconds:
    case EnumType::kNoFade:
    case EnumType::k50PercentDimDownIn0p8SecondsThenFadeToOffIn12Seconds:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_ON_OFF_DELAYED_ALL_OFF_EFFECT_VARIANT_FADE_TO_OFF_IN_0P8_SECONDS:
    case EMBER_ZCL_ON_OFF_DELAYED_ALL_OFF_EFFECT_VARIANT_NO_FADE:
    case EMBER_ZCL_ON_OFF_DELAYED_ALL_OFF_EFFECT_VARIANT_50_PERCENT_DIM_DOWN_IN_0P8_SECONDS_THEN_FADE_TO_OFF_IN_12_SECONDS:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(OnOff::OnOffDyingLightEffectVariant val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = OnOff::OnOffDyingLightEffectVariant;
    case EnumType::k20PercenterDimUpIn0p5SecondsThenFadeToOffIn1Second:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_ON_OFF_DYING_LIGHT_EFFECT_VARIANT_20_PERCENTER_DIM_UP_IN_0P5_SECONDS_THEN_FADE_TO_OFF_IN_1_SECOND:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(OnOff::OnOffEffectIdentifier val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = OnOff::OnOffEffectIdentifier;
    case EnumType::kDelayedAllOff:
    case EnumType::kDyingLight:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_ON_OFF_EFFECT_IDENTIFIER_DELAYED_ALL_OFF:
    case EMBER_ZCL_ON_OFF_EFFECT_IDENTIFIER_DYING_LIGHT:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(OnOff::OnOffStartUpOnOff val)
{
    switch (val)
    {
        using EnumType = OnOff::OnOffStartUpOnOff;
    case EnumType::kOff:
    case EnumType::kOn:
    case EnumType::kTogglePreviousOnOff:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(OnOff::OnOffControl val)
{
    switch (val)
    {
        using EnumType = OnOff::OnOffControl;
    case EnumType::kAcceptOnlyWhenOn:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(OnOff::OnOffFeature val)
{
    switch (val)
    {
        using EnumType = OnOff::OnOffFeature;
    case EnumType::kLighting:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(OnOff::SceneFeatures val)
{
    switch (val)
    {
        using EnumType = OnOff::SceneFeatures;
    case EnumType::kSceneNames:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(LevelControl::MoveMode val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = LevelControl::MoveMode;
    case EnumType::kUp:
    case EnumType::kDown:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_MOVE_MODE_UP:
    case EMBER_ZCL_MOVE_MODE_DOWN:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(LevelControl::StepMode val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = LevelControl::StepMode;
    case EnumType::kUp:
    case EnumType::kDown:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_STEP_MODE_UP:
    case EMBER_ZCL_STEP_MODE_DOWN:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(LevelControl::LevelControlFeature val)
{
    switch (val)
    {
        using EnumType = LevelControl::LevelControlFeature;
    case EnumType::kOnOff:
    case EnumType::kLighting:
    case EnumType::kFrequency:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ApplianceControl::ApplianceStatus val)
{
    switch (val)
    {
        using EnumType = ApplianceControl::ApplianceStatus;
    case EnumType::kOff:
    case EnumType::kStandBy:
    case EnumType::kProgrammed:
    case EnumType::kProgrammedWaitingToStart:
    case EnumType::kRunning:
    case EnumType::kPause:
    case EnumType::kEndProgrammed:
    case EnumType::kFailure:
    case EnumType::kProgrammeInterrupted:
    case EnumType::kIdle:
    case EnumType::kRinseHold:
    case EnumType::kService:
    case EnumType::kSuperfreezing:
    case EnumType::kSupercooling:
    case EnumType::kSuperheating:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ApplianceControl::CommandIdentification val)
{
    switch (val)
    {
        using EnumType = ApplianceControl::CommandIdentification;
    case EnumType::kStart:
    case EnumType::kStop:
    case EnumType::kPause:
    case EnumType::kStartSuperfreezing:
    case EnumType::kStopSuperfreezing:
    case EnumType::kStartSupercooling:
    case EnumType::kStopSupercooling:
    case EnumType::kDisableGas:
    case EnumType::kEnableGas:
    case EnumType::kEnableEnergyControl:
    case EnumType::kDisableEnergyControl:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ApplianceControl::WarningEvent val)
{
    switch (val)
    {
        using EnumType = ApplianceControl::WarningEvent;
    case EnumType::kWarning1OverallPowerAboveAvailablePowerLevel:
    case EnumType::kWarning2OverallPowerAbovePowerThresholdLevel:
    case EnumType::kWarning3OverallPowerBackBelowTheAvailablePowerLevel:
    case EnumType::kWarning4OverallPowerBackBelowThePowerThresholdLevel:
    case EnumType::kWarning5OverallPowerWillBePotentiallyAboveAvailablePowerLevelIfTheApplianceStarts:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ApplianceControl::RemoteEnableFlagsAndDeviceStatus2 val)
{
    switch (val)
    {
        using EnumType = ApplianceControl::RemoteEnableFlagsAndDeviceStatus2;
    case EnumType::kRemoteEnableFlags:
    case EnumType::kDeviceStatus2Structure:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(AccessControl::AuthMode val)
{
    switch (val)
    {
        using EnumType = AccessControl::AuthMode;
    case EnumType::kPase:
    case EnumType::kCase:
    case EnumType::kGroup:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(AccessControl::ChangeTypeEnum val)
{
    switch (val)
    {
        using EnumType = AccessControl::ChangeTypeEnum;
    case EnumType::kChanged:
    case EnumType::kAdded:
    case EnumType::kRemoved:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(AccessControl::Privilege val)
{
    switch (val)
    {
        using EnumType = AccessControl::Privilege;
    case EnumType::kView:
    case EnumType::kProxyView:
    case EnumType::kOperate:
    case EnumType::kManage:
    case EnumType::kAdminister:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(BridgedActions::ActionErrorEnum val)
{
    switch (val)
    {
        using EnumType = BridgedActions::ActionErrorEnum;
    case EnumType::kUnknown:
    case EnumType::kInterrupted:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(BridgedActions::ActionStateEnum val)
{
    switch (val)
    {
        using EnumType = BridgedActions::ActionStateEnum;
    case EnumType::kInactive:
    case EnumType::kActive:
    case EnumType::kPaused:
    case EnumType::kDisabled:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(BridgedActions::ActionTypeEnum val)
{
    switch (val)
    {
        using EnumType = BridgedActions::ActionTypeEnum;
    case EnumType::kOther:
    case EnumType::kScene:
    case EnumType::kSequence:
    case EnumType::kAutomation:
    case EnumType::kException:
    case EnumType::kNotification:
    case EnumType::kAlarm:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(BridgedActions::EndpointListTypeEnum val)
{
    switch (val)
    {
        using EnumType = BridgedActions::EndpointListTypeEnum;
    case EnumType::kOther:
    case EnumType::kRoom:
    case EnumType::kZone:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(BridgedActions::CommandBits val)
{
    switch (val)
    {
        using EnumType = BridgedActions::CommandBits;
    case EnumType::kInstantAction:
    case EnumType::kInstantActionWithTransition:
    case EnumType::kStartAction:
    case EnumType::kStartActionWithDuration:
    case EnumType::kStopAction:
    case EnumType::kPauseAction:
    case EnumType::kPauseActionWithDuration:
    case EnumType::kResumeAction:
    case EnumType::kEnableAction:
    case EnumType::kEnableActionWithDuration:
    case EnumType::kDisableAction:
    case EnumType::kDisableActionWithDuration:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(OtaSoftwareUpdateProvider::OTAApplyUpdateAction val)
{
    switch (val)
    {
        using EnumType = OtaSoftwareUpdateProvider::OTAApplyUpdateAction;
    case EnumType::kProceed:
    case EnumType::kAwaitNextAction:
    case EnumType::kDiscontinue:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(OtaSoftwareUpdateProvider::OTADownloadProtocol val)
{
    switch (val)
    {
        using EnumType = OtaSoftwareUpdateProvider::OTADownloadProtocol;
    case EnumType::kBDXSynchronous:
    case EnumType::kBDXAsynchronous:
    case EnumType::kHttps:
    case EnumType::kVendorSpecific:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(OtaSoftwareUpdateProvider::OTAQueryStatus val)
{
    switch (val)
    {
        using EnumType = OtaSoftwareUpdateProvider::OTAQueryStatus;
    case EnumType::kUpdateAvailable:
    case EnumType::kBusy:
    case EnumType::kNotAvailable:
    case EnumType::kDownloadProtocolNotSupported:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(OtaSoftwareUpdateRequestor::OTAAnnouncementReason val)
{
    switch (val)
    {
        using EnumType = OtaSoftwareUpdateRequestor::OTAAnnouncementReason;
    case EnumType::kSimpleAnnouncement:
    case EnumType::kUpdateAvailable:
    case EnumType::kUrgentUpdateAvailable:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(OtaSoftwareUpdateRequestor::OTAChangeReasonEnum val)
{
    switch (val)
    {
        using EnumType = OtaSoftwareUpdateRequestor::OTAChangeReasonEnum;
    case EnumType::kUnknown:
    case EnumType::kSuccess:
    case EnumType::kFailure:
    case EnumType::kTimeOut:
    case EnumType::kDelayByProvider:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(OtaSoftwareUpdateRequestor::OTAUpdateStateEnum val)
{
    switch (val)
    {
        using EnumType = OtaSoftwareUpdateRequestor::OTAUpdateStateEnum;
    case EnumType::kUnknown:
    case EnumType::kIdle:
    case EnumType::kQuerying:
    case EnumType::kDelayedOnQuery:
    case EnumType::kDownloading:
    case EnumType::kApplying:
    case EnumType::kDelayedOnApply:
    case EnumType::kRollingBack:
    case EnumType::kDelayedOnUserConsent:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(TimeFormatLocalization::CalendarType val)
{
    switch (val)
    {
        using EnumType = TimeFormatLocalization::CalendarType;
    case EnumType::kBuddhist:
    case EnumType::kChinese:
    case EnumType::kCoptic:
    case EnumType::kEthiopian:
    case EnumType::kGregorian:
    case EnumType::kHebrew:
    case EnumType::kIndian:
    case EnumType::kIslamic:
    case EnumType::kJapanese:
    case EnumType::kKorean:
    case EnumType::kPersian:
    case EnumType::kTaiwanese:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(TimeFormatLocalization::HourFormat val)
{
    switch (val)
    {
        using EnumType = TimeFormatLocalization::HourFormat;
    case EnumType::k12hr:
    case EnumType::k24hr:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(UnitLocalization::TempUnit val)
{
    switch (val)
    {
        using EnumType = UnitLocalization::TempUnit;
    case EnumType::kFahrenheit:
    case EnumType::kCelsius:
    case EnumType::kKelvin:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(UnitLocalization::UnitLocalizationFeature val)
{
    switch (val)
    {
        using EnumType = UnitLocalization::UnitLocalizationFeature;
    case EnumType::kTemperatureUnit:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(PowerSource::BatChargeFaultType val)
{
    switch (val)
    {
        using EnumType = PowerSource::BatChargeFaultType;
    case EnumType::kUnspecfied:
    case EnumType::kAmbientTooHot:
    case EnumType::kAmbientTooCold:
    case EnumType::kBatteryTooHot:
    case EnumType::kBatteryTooCold:
    case EnumType::kBatteryAbsent:
    case EnumType::kBatteryOverVoltage:
    case EnumType::kBatteryUnderVoltage:
    case EnumType::kChargerOverVoltage:
    case EnumType::kChargerUnderVoltage:
    case EnumType::kSafetyTimeout:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(PowerSource::BatChargeLevel val)
{
    switch (val)
    {
        using EnumType = PowerSource::BatChargeLevel;
    case EnumType::kOk:
    case EnumType::kWarning:
    case EnumType::kCritical:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(PowerSource::BatChargeState val)
{
    switch (val)
    {
        using EnumType = PowerSource::BatChargeState;
    case EnumType::kUnknown:
    case EnumType::kIsCharging:
    case EnumType::kIsAtFullCharge:
    case EnumType::kIsNotCharging:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(PowerSource::BatFaultType val)
{
    switch (val)
    {
        using EnumType = PowerSource::BatFaultType;
    case EnumType::kUnspecfied:
    case EnumType::kOverTemp:
    case EnumType::kUnderTemp:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(PowerSource::BatReplaceability val)
{
    switch (val)
    {
        using EnumType = PowerSource::BatReplaceability;
    case EnumType::kUnspecified:
    case EnumType::kNotReplaceable:
    case EnumType::kUserReplaceable:
    case EnumType::kFactoryReplaceable:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(PowerSource::PowerSourceStatus val)
{
    switch (val)
    {
        using EnumType = PowerSource::PowerSourceStatus;
    case EnumType::kUnspecfied:
    case EnumType::kActive:
    case EnumType::kStandby:
    case EnumType::kUnavailable:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(PowerSource::WiredCurrentType val)
{
    switch (val)
    {
        using EnumType = PowerSource::WiredCurrentType;
    case EnumType::kAc:
    case EnumType::kDc:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(PowerSource::WiredFaultType val)
{
    switch (val)
    {
        using EnumType = PowerSource::WiredFaultType;
    case EnumType::kUnspecfied:
    case EnumType::kOverVoltage:
    case EnumType::kUnderVoltage:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(PowerSource::PowerSourceFeature val)
{
    switch (val)
    {
        using EnumType = PowerSource::PowerSourceFeature;
    case EnumType::kWired:
    case EnumType::kBattery:
    case EnumType::kRechargeable:
    case EnumType::kReplaceable:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(GeneralCommissioning::CommissioningError val)
{
    switch (val)
    {
        using EnumType = GeneralCommissioning::CommissioningError;
    case EnumType::kOk:
    case EnumType::kValueOutsideRange:
    case EnumType::kInvalidAuthentication:
    case EnumType::kNoFailSafe:
    case EnumType::kBusyWithOtherAdmin:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(GeneralCommissioning::RegulatoryLocationType val)
{
    switch (val)
    {
        using EnumType = GeneralCommissioning::RegulatoryLocationType;
    case EnumType::kIndoor:
    case EnumType::kOutdoor:
    case EnumType::kIndoorOutdoor:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(NetworkCommissioning::NetworkCommissioningStatus val)
{
    switch (val)
    {
        using EnumType = NetworkCommissioning::NetworkCommissioningStatus;
    case EnumType::kSuccess:
    case EnumType::kOutOfRange:
    case EnumType::kBoundsExceeded:
    case EnumType::kNetworkIDNotFound:
    case EnumType::kDuplicateNetworkID:
    case EnumType::kNetworkNotFound:
    case EnumType::kRegulatoryError:
    case EnumType::kAuthFailure:
    case EnumType::kUnsupportedSecurity:
    case EnumType::kOtherConnectionFailure:
    case EnumType::kIPV6Failed:
    case EnumType::kIPBindFailed:
    case EnumType::kUnknownError:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(NetworkCommissioning::WiFiBand val)
{
    switch (val)
    {
        using EnumType = NetworkCommissioning::WiFiBand;
    case EnumType::k2g4:
    case EnumType::k3g65:
    case EnumType::k5g:
    case EnumType::k6g:
    case EnumType::k60g:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(NetworkCommissioning::NetworkCommissioningFeature val)
{
    switch (val)
    {
        using EnumType = NetworkCommissioning::NetworkCommissioningFeature;
    case EnumType::kWiFiNetworkInterface:
    case EnumType::kThreadNetworkInterface:
    case EnumType::kEthernetNetworkInterface:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(NetworkCommissioning::WiFiSecurity val)
{
    switch (val)
    {
        using EnumType = NetworkCommissioning::WiFiSecurity;
    case EnumType::kUnencrypted:
    case EnumType::kWepPersonal:
    case EnumType::kWpaPersonal:
    case EnumType::kWpa2Personal:
    case EnumType::kWpa3Personal:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DiagnosticLogs::LogsIntent val)
{
    switch (val)
    {
        using EnumType = DiagnosticLogs::LogsIntent;
    case EnumType::kEndUserSupport:
    case EnumType::kNetworkDiag:
    case EnumType::kCrashLogs:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DiagnosticLogs::LogsStatus val)
{
    switch (val)
    {
        using EnumType = DiagnosticLogs::LogsStatus;
    case EnumType::kSuccess:
    case EnumType::kExhausted:
    case EnumType::kNoLogs:
    case EnumType::kBusy:
    case EnumType::kDenied:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DiagnosticLogs::LogsTransferProtocol val)
{
    switch (val)
    {
        using EnumType = DiagnosticLogs::LogsTransferProtocol;
    case EnumType::kResponsePayload:
    case EnumType::kBdx:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(GeneralDiagnostics::BootReasonType val)
{
    switch (val)
    {
        using EnumType = GeneralDiagnostics::BootReasonType;
    case EnumType::kUnspecified:
    case EnumType::kPowerOnReboot:
    case EnumType::kBrownOutReset:
    case EnumType::kSoftwareWatchdogReset:
    case EnumType::kHardwareWatchdogReset:
    case EnumType::kSoftwareUpdateCompleted:
    case EnumType::kSoftwareReset:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(GeneralDiagnostics::HardwareFaultType val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = GeneralDiagnostics::HardwareFaultType;
    case EnumType::kUnspecified:
    case EnumType::kRadio:
    case EnumType::kSensor:
    case EnumType::kResettableOverTemp:
    case EnumType::kNonResettableOverTemp:
    case EnumType::kPowerSource:
    case EnumType::kVisualDisplayFault:
    case EnumType::kAudioOutputFault:
    case EnumType::kUserInterfaceFault:
    case EnumType::kNonVolatileMemoryError:
    case EnumType::kTamperDetected:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_HARDWARE_FAULT_TYPE_UNSPECIFIED:
    case EMBER_ZCL_HARDWARE_FAULT_TYPE_RADIO:
    case EMBER_ZCL_HARDWARE_FAULT_TYPE_SENSOR:
    case EMBER_ZCL_HARDWARE_FAULT_TYPE_RESETTABLE_OVER_TEMP:
    case EMBER_ZCL_HARDWARE_FAULT_TYPE_NON_RESETTABLE_OVER_TEMP:
    case EMBER_ZCL_HARDWARE_FAULT_TYPE_POWER_SOURCE:
    case EMBER_ZCL_HARDWARE_FAULT_TYPE_VISUAL_DISPLAY_FAULT:
    case EMBER_ZCL_HARDWARE_FAULT_TYPE_AUDIO_OUTPUT_FAULT:
    case EMBER_ZCL_HARDWARE_FAULT_TYPE_USER_INTERFACE_FAULT:
    case EMBER_ZCL_HARDWARE_FAULT_TYPE_NON_VOLATILE_MEMORY_ERROR:
    case EMBER_ZCL_HARDWARE_FAULT_TYPE_TAMPER_DETECTED:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(GeneralDiagnostics::InterfaceType val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = GeneralDiagnostics::InterfaceType;
    case EnumType::kUnspecified:
    case EnumType::kWiFi:
    case EnumType::kEthernet:
    case EnumType::kCellular:
    case EnumType::kThread:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_INTERFACE_TYPE_UNSPECIFIED:
    case EMBER_ZCL_INTERFACE_TYPE_WI_FI:
    case EMBER_ZCL_INTERFACE_TYPE_ETHERNET:
    case EMBER_ZCL_INTERFACE_TYPE_CELLULAR:
    case EMBER_ZCL_INTERFACE_TYPE_THREAD:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(GeneralDiagnostics::NetworkFaultType val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = GeneralDiagnostics::NetworkFaultType;
    case EnumType::kUnspecified:
    case EnumType::kHardwareFailure:
    case EnumType::kNetworkJammed:
    case EnumType::kConnectionFailed:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_NETWORK_FAULT_TYPE_UNSPECIFIED:
    case EMBER_ZCL_NETWORK_FAULT_TYPE_HARDWARE_FAILURE:
    case EMBER_ZCL_NETWORK_FAULT_TYPE_NETWORK_JAMMED:
    case EMBER_ZCL_NETWORK_FAULT_TYPE_CONNECTION_FAILED:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(GeneralDiagnostics::RadioFaultType val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = GeneralDiagnostics::RadioFaultType;
    case EnumType::kUnspecified:
    case EnumType::kWiFiFault:
    case EnumType::kCellularFault:
    case EnumType::kThreadFault:
    case EnumType::kNFCFault:
    case EnumType::kBLEFault:
    case EnumType::kEthernetFault:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_RADIO_FAULT_TYPE_UNSPECIFIED:
    case EMBER_ZCL_RADIO_FAULT_TYPE_WI_FI_FAULT:
    case EMBER_ZCL_RADIO_FAULT_TYPE_CELLULAR_FAULT:
    case EMBER_ZCL_RADIO_FAULT_TYPE_THREAD_FAULT:
    case EMBER_ZCL_RADIO_FAULT_TYPE_NFC_FAULT:
    case EMBER_ZCL_RADIO_FAULT_TYPE_BLE_FAULT:
    case EMBER_ZCL_RADIO_FAULT_TYPE_ETHERNET_FAULT:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(SoftwareDiagnostics::SoftwareDiagnosticsFeature val)
{
    switch (val)
    {
        using EnumType = SoftwareDiagnostics::SoftwareDiagnosticsFeature;
    case EnumType::kWaterMarks:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ThreadNetworkDiagnostics::NetworkFault val)
{
    switch (val)
    {
        using EnumType = ThreadNetworkDiagnostics::NetworkFault;
    case EnumType::kUnspecified:
    case EnumType::kLinkDown:
    case EnumType::kHardwareFailure:
    case EnumType::kNetworkJammed:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ThreadNetworkDiagnostics::RoutingRole val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = ThreadNetworkDiagnostics::RoutingRole;
    case EnumType::kUnspecified:
    case EnumType::kUnassigned:
    case EnumType::kSleepyEndDevice:
    case EnumType::kEndDevice:
    case EnumType::kReed:
    case EnumType::kRouter:
    case EnumType::kLeader:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_ROUTING_ROLE_UNSPECIFIED:
    case EMBER_ZCL_ROUTING_ROLE_UNASSIGNED:
    case EMBER_ZCL_ROUTING_ROLE_SLEEPY_END_DEVICE:
    case EMBER_ZCL_ROUTING_ROLE_END_DEVICE:
    case EMBER_ZCL_ROUTING_ROLE_REED:
    case EMBER_ZCL_ROUTING_ROLE_ROUTER:
    case EMBER_ZCL_ROUTING_ROLE_LEADER:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ThreadNetworkDiagnostics::ThreadConnectionStatus val)
{
    switch (val)
    {
        using EnumType = ThreadNetworkDiagnostics::ThreadConnectionStatus;
    case EnumType::kConnected:
    case EnumType::kNotConnected:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ThreadNetworkDiagnostics::ThreadNetworkDiagnosticsFeature val)
{
    switch (val)
    {
        using EnumType = ThreadNetworkDiagnostics::ThreadNetworkDiagnosticsFeature;
    case EnumType::kPacketCounts:
    case EnumType::kErrorCounts:
    case EnumType::kMLECounts:
    case EnumType::kMACCounts:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(WiFiNetworkDiagnostics::AssociationFailureCause val)
{
    switch (val)
    {
        using EnumType = WiFiNetworkDiagnostics::AssociationFailureCause;
    case EnumType::kUnknown:
    case EnumType::kAssociationFailed:
    case EnumType::kAuthenticationFailed:
    case EnumType::kSsidNotFound:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(WiFiNetworkDiagnostics::SecurityType val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = WiFiNetworkDiagnostics::SecurityType;
    case EnumType::kUnspecified:
    case EnumType::kNone:
    case EnumType::kWep:
    case EnumType::kWpa:
    case EnumType::kWpa2:
    case EnumType::kWpa3:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_SECURITY_TYPE_UNSPECIFIED:
    case EMBER_ZCL_SECURITY_TYPE_NONE:
    case EMBER_ZCL_SECURITY_TYPE_WEP:
    case EMBER_ZCL_SECURITY_TYPE_WPA:
    case EMBER_ZCL_SECURITY_TYPE_WPA2:
    case EMBER_ZCL_SECURITY_TYPE_WPA3:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(WiFiNetworkDiagnostics::WiFiConnectionStatus val)
{
    switch (val)
    {
        using EnumType = WiFiNetworkDiagnostics::WiFiConnectionStatus;
    case EnumType::kConnected:
    case EnumType::kNotConnected:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(WiFiNetworkDiagnostics::WiFiVersionType val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = WiFiNetworkDiagnostics::WiFiVersionType;
    case EnumType::k80211a:
    case EnumType::k80211b:
    case EnumType::k80211g:
    case EnumType::k80211n:
    case EnumType::k80211ac:
    case EnumType::k80211ax:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_WI_FI_VERSION_TYPE_802__11A:
    case EMBER_ZCL_WI_FI_VERSION_TYPE_802__11B:
    case EMBER_ZCL_WI_FI_VERSION_TYPE_802__11G:
    case EMBER_ZCL_WI_FI_VERSION_TYPE_802__11N:
    case EMBER_ZCL_WI_FI_VERSION_TYPE_802__11AC:
    case EMBER_ZCL_WI_FI_VERSION_TYPE_802__11AX:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(EthernetNetworkDiagnostics::PHYRateType val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = EthernetNetworkDiagnostics::PHYRateType;
    case EnumType::k10m:
    case EnumType::k100m:
    case EnumType::k1000m:
    case EnumType::k25g:
    case EnumType::k5g:
    case EnumType::k10g:
    case EnumType::k40g:
    case EnumType::k100g:
    case EnumType::k200g:
    case EnumType::k400g:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_PHY_RATE_TYPE_10_M:
    case EMBER_ZCL_PHY_RATE_TYPE_100_M:
    case EMBER_ZCL_PHY_RATE_TYPE_1000_M:
    case EMBER_ZCL_PHY_RATE_TYPE_2__5_G:
    case EMBER_ZCL_PHY_RATE_TYPE_5_G:
    case EMBER_ZCL_PHY_RATE_TYPE_10_G:
    case EMBER_ZCL_PHY_RATE_TYPE_40_G:
    case EMBER_ZCL_PHY_RATE_TYPE_100_G:
    case EMBER_ZCL_PHY_RATE_TYPE_200_G:
    case EMBER_ZCL_PHY_RATE_TYPE_400_G:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(AdministratorCommissioning::CommissioningWindowStatus val)
{
    switch (val)
    {
        using EnumType = AdministratorCommissioning::CommissioningWindowStatus;
    case EnumType::kWindowNotOpen:
    case EnumType::kEnhancedWindowOpen:
    case EnumType::kBasicWindowOpen:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(AdministratorCommissioning::StatusCode val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = AdministratorCommissioning::StatusCode;
    case EnumType::kBusy:
    case EnumType::kPAKEParameterError:
    case EnumType::kWindowNotOpen:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_STATUS_CODE_BUSY:
    case EMBER_ZCL_STATUS_CODE_PAKE_PARAMETER_ERROR:
    case EMBER_ZCL_STATUS_CODE_WINDOW_NOT_OPEN:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(OperationalCredentials::OperationalCertStatus val)
{
    switch (val)
    {
        using EnumType = OperationalCredentials::OperationalCertStatus;
    case EnumType::kSuccess:
    case EnumType::kInvalidPublicKey:
    case EnumType::kInvalidNodeOpId:
    case EnumType::kInvalidNOC:
    case EnumType::kMissingCsr:
    case EnumType::kTableFull:
    case EnumType::kInvalidAdminSubject:
    case EnumType::kInsufficientPrivilege:
    case EnumType::kFabricConflict:
    case EnumType::kLabelConflict:
    case EnumType::kInvalidFabricIndex:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(GroupKeyManagement::GroupKeySecurityPolicy val)
{
    switch (val)
    {
        using EnumType = GroupKeyManagement::GroupKeySecurityPolicy;
    case EnumType::kTrustFirst:
    case EnumType::kCacheAndSync:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ModeSelect::ModeSelectFeature val)
{
    switch (val)
    {
        using EnumType = ModeSelect::ModeSelectFeature;
    case EnumType::kDeponoff:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlAlarmCode val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlAlarmCode;
    case EnumType::kLockJammed:
    case EnumType::kLockFactoryReset:
    case EnumType::kLockRadioPowerCycled:
    case EnumType::kWrongCodeEntryLimit:
    case EnumType::kFrontEsceutcheonRemoved:
    case EnumType::kDoorForcedOpen:
    case EnumType::kDoorAjar:
    case EnumType::kForcedUser:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlCredentialRule val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlCredentialRule;
    case EnumType::kSingle:
    case EnumType::kDouble:
    case EnumType::kTri:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlCredentialType val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlCredentialType;
    case EnumType::kProgrammingPIN:
    case EnumType::kPin:
    case EnumType::kRfid:
    case EnumType::kFingerprint:
    case EnumType::kFingerVein:
    case EnumType::kFace:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlDataOperationType val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlDataOperationType;
    case EnumType::kAdd:
    case EnumType::kClear:
    case EnumType::kModify:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlDoorState val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlDoorState;
    case EnumType::kDoorOpen:
    case EnumType::kDoorClosed:
    case EnumType::kDoorJammed:
    case EnumType::kDoorForcedOpen:
    case EnumType::kDoorUnspecifiedError:
    case EnumType::kDoorAjar:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlLockDataType val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlLockDataType;
    case EnumType::kUnspecified:
    case EnumType::kProgrammingCode:
    case EnumType::kUserIndex:
    case EnumType::kWeekDaySchedule:
    case EnumType::kYearDaySchedule:
    case EnumType::kHolidaySchedule:
    case EnumType::kPin:
    case EnumType::kRfid:
    case EnumType::kFingerprint:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlLockOperationType val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlLockOperationType;
    case EnumType::kLock:
    case EnumType::kUnlock:
    case EnumType::kNonAccessUserEvent:
    case EnumType::kForcedUserEvent:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlLockState val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlLockState;
    case EnumType::kNotFullyLocked:
    case EnumType::kLocked:
    case EnumType::kUnlocked:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlLockType val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlLockType;
    case EnumType::kDeadBolt:
    case EnumType::kMagnetic:
    case EnumType::kOther:
    case EnumType::kMortise:
    case EnumType::kRim:
    case EnumType::kLatchBolt:
    case EnumType::kCylindricalLock:
    case EnumType::kTubularLock:
    case EnumType::kInterconnectedLock:
    case EnumType::kDeadLatch:
    case EnumType::kDoorFurniture:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlOperatingMode val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlOperatingMode;
    case EnumType::kNormal:
    case EnumType::kVacation:
    case EnumType::kPrivacy:
    case EnumType::kNoRemoteLockUnlock:
    case EnumType::kPassage:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlOperationError val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlOperationError;
    case EnumType::kUnspecified:
    case EnumType::kInvalidCredential:
    case EnumType::kDisabledUserDenied:
    case EnumType::kRestricted:
    case EnumType::kInsufficientBattery:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlOperationSource val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlOperationSource;
    case EnumType::kUnspecified:
    case EnumType::kManual:
    case EnumType::kProprietaryRemote:
    case EnumType::kKeypad:
    case EnumType::kAuto:
    case EnumType::kButton:
    case EnumType::kSchedule:
    case EnumType::kRemote:
    case EnumType::kRfid:
    case EnumType::kBiometric:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlStatus val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlStatus;
    case EnumType::kSuccess:
    case EnumType::kFailure:
    case EnumType::kDuplicate:
    case EnumType::kOccupied:
    case EnumType::kInvalidField:
    case EnumType::kResourceExhausted:
    case EnumType::kNotFound:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlUserStatus val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlUserStatus;
    case EnumType::kAvailable:
    case EnumType::kOccupiedEnabled:
    case EnumType::kOccupiedDisabled:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlUserType val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlUserType;
    case EnumType::kUnrestrictedUser:
    case EnumType::kYearDayScheduleUser:
    case EnumType::kWeekDayScheduleUser:
    case EnumType::kProgrammingUser:
    case EnumType::kNonAccessUser:
    case EnumType::kForcedUser:
    case EnumType::kDisposableUser:
    case EnumType::kExpiringUser:
    case EnumType::kScheduleRestrictedUser:
    case EnumType::kRemoteOnlyUser:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DoorLockOperationEventCode val)
{
    switch (val)
    {
        using EnumType = DoorLock::DoorLockOperationEventCode;
    case EnumType::kUnknownOrMfgSpecific:
    case EnumType::kLock:
    case EnumType::kUnlock:
    case EnumType::kLockInvalidPinOrId:
    case EnumType::kLockInvalidSchedule:
    case EnumType::kUnlockInvalidPinOrId:
    case EnumType::kUnlockInvalidSchedule:
    case EnumType::kOneTouchLock:
    case EnumType::kKeyLock:
    case EnumType::kKeyUnlock:
    case EnumType::kAutoLock:
    case EnumType::kScheduleLock:
    case EnumType::kScheduleUnlock:
    case EnumType::kManualLock:
    case EnumType::kManualUnlock:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DoorLockProgrammingEventCode val)
{
    switch (val)
    {
        using EnumType = DoorLock::DoorLockProgrammingEventCode;
    case EnumType::kUnknownOrMfgSpecific:
    case EnumType::kMasterCodeChanged:
    case EnumType::kPinAdded:
    case EnumType::kPinDeleted:
    case EnumType::kPinChanged:
    case EnumType::kIdAdded:
    case EnumType::kIdDeleted:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DoorLockSetPinOrIdStatus val)
{
    switch (val)
    {
        using EnumType = DoorLock::DoorLockSetPinOrIdStatus;
    case EnumType::kSuccess:
    case EnumType::kGeneralFailure:
    case EnumType::kMemoryFull:
    case EnumType::kDuplicateCodeError:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DoorLockUserStatus val)
{
    switch (val)
    {
        using EnumType = DoorLock::DoorLockUserStatus;
    case EnumType::kAvailable:
    case EnumType::kOccupiedEnabled:
    case EnumType::kOccupiedDisabled:
    case EnumType::kNotSupported:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DoorLockUserType val)
{
    switch (val)
    {
        using EnumType = DoorLock::DoorLockUserType;
    case EnumType::kUnrestricted:
    case EnumType::kYearDayScheduleUser:
    case EnumType::kWeekDayScheduleUser:
    case EnumType::kMasterUser:
    case EnumType::kNonAccessUser:
    case EnumType::kNotSupported:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlCredentialRuleMask val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlCredentialRuleMask;
    case EnumType::kSingle:
    case EnumType::kDual:
    case EnumType::kTri:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlCredentialRulesSupport val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlCredentialRulesSupport;
    case EnumType::kSingle:
    case EnumType::kDual:
    case EnumType::kTri:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlDaysMaskMap val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlDaysMaskMap;
    case EnumType::kSunday:
    case EnumType::kMonday:
    case EnumType::kTuesday:
    case EnumType::kWednesday:
    case EnumType::kThursday:
    case EnumType::kFriday:
    case EnumType::kSaturday:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlDefaultConfigurationRegister val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlDefaultConfigurationRegister;
    case EnumType::kEnableLocalProgrammingEnabled:
    case EnumType::kKeypadInterfaceDefaultAccessEnabled:
    case EnumType::kRemoteInterfaceDefaultAccessIsEnabled:
    case EnumType::kSoundEnabled:
    case EnumType::kAutoRelockTimeSet:
    case EnumType::kLEDSettingsSet:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlKeypadOperationEventMask val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlKeypadOperationEventMask;
    case EnumType::kUnknown:
    case EnumType::kLock:
    case EnumType::kUnlock:
    case EnumType::kLockInvalidPIN:
    case EnumType::kLockInvalidSchedule:
    case EnumType::kUnlockInvalidCode:
    case EnumType::kUnlockInvalidSchedule:
    case EnumType::kNonAccessUserOpEvent:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlKeypadProgrammingEventMask val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlKeypadProgrammingEventMask;
    case EnumType::kUnknown:
    case EnumType::kProgrammingPINChanged:
    case EnumType::kPINAdded:
    case EnumType::kPINCleared:
    case EnumType::kPINChanged:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlLocalProgrammingFeatures val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlLocalProgrammingFeatures;
    case EnumType::kAddUsersCredentialsSchedulesLocally:
    case EnumType::kModifyUsersCredentialsSchedulesLocally:
    case EnumType::kClearUsersCredentialsSchedulesLocally:
    case EnumType::kAdjustLockSettingsLocally:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlManualOperationEventMask val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlManualOperationEventMask;
    case EnumType::kUnknown:
    case EnumType::kThumbturnLock:
    case EnumType::kThumbturnUnlock:
    case EnumType::kOneTouchLock:
    case EnumType::kKeyLock:
    case EnumType::kKeyUnlock:
    case EnumType::kAutoLock:
    case EnumType::kScheduleLock:
    case EnumType::kScheduleUnlock:
    case EnumType::kManualLock:
    case EnumType::kManualUnlock:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlRFIDOperationEventMask val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlRFIDOperationEventMask;
    case EnumType::kUnknown:
    case EnumType::kLock:
    case EnumType::kUnlock:
    case EnumType::kLockInvalidRFID:
    case EnumType::kLockInvalidSchedule:
    case EnumType::kUnlockInvalidRFID:
    case EnumType::kUnlockInvalidSchedule:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlRFIDProgrammingEventMask val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlRFIDProgrammingEventMask;
    case EnumType::kUnknown:
    case EnumType::kRFIDCodeAdded:
    case EnumType::kRFIDCodeCleared:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlRemoteOperationEventMask val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlRemoteOperationEventMask;
    case EnumType::kUnknown:
    case EnumType::kLock:
    case EnumType::kUnlock:
    case EnumType::kLockInvalidCode:
    case EnumType::kLockInvalidSchedule:
    case EnumType::kUnlockInvalidCode:
    case EnumType::kUnlockInvalidSchedule:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlRemoteProgrammingEventMask val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlRemoteProgrammingEventMask;
    case EnumType::kUnknown:
    case EnumType::kProgrammingPINChanged:
    case EnumType::kPINAdded:
    case EnumType::kPINCleared:
    case EnumType::kPINChanged:
    case EnumType::kRFIDCodeAdded:
    case EnumType::kRFIDCodeCleared:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DlSupportedOperatingModes val)
{
    switch (val)
    {
        using EnumType = DoorLock::DlSupportedOperatingModes;
    case EnumType::kNormal:
    case EnumType::kVacation:
    case EnumType::kPrivacy:
    case EnumType::kNoRemoteLockUnlock:
    case EnumType::kPassage:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DoorLockDayOfWeek val)
{
    switch (val)
    {
        using EnumType = DoorLock::DoorLockDayOfWeek;
    case EnumType::kSunday:
    case EnumType::kMonday:
    case EnumType::kTuesday:
    case EnumType::kWednesday:
    case EnumType::kThursday:
    case EnumType::kFriday:
    case EnumType::kSaturday:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(DoorLock::DoorLockFeature val)
{
    switch (val)
    {
        using EnumType = DoorLock::DoorLockFeature;
    case EnumType::kPINCredentials:
    case EnumType::kRFIDCredentials:
    case EnumType::kFingerCredentials:
    case EnumType::kLogging:
    case EnumType::kAccessSchedules:
    case EnumType::kDoorPositionSensor:
    case EnumType::kFaceCredentials:
    case EnumType::kCredentialsOTA:
    case EnumType::kUsersManagement:
    case EnumType::kNotifications:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(WindowCovering::EndProductType val)
{
    switch (val)
    {
        using EnumType = WindowCovering::EndProductType;
    case EnumType::kRollerShade:
    case EnumType::kRomanShade:
    case EnumType::kBalloonShade:
    case EnumType::kWovenWood:
    case EnumType::kPleatedShade:
    case EnumType::kCellularShade:
    case EnumType::kLayeredShade:
    case EnumType::kLayeredShade2D:
    case EnumType::kSheerShade:
    case EnumType::kTiltOnlyInteriorBlind:
    case EnumType::kInteriorBlind:
    case EnumType::kVerticalBlindStripCurtain:
    case EnumType::kInteriorVenetianBlind:
    case EnumType::kExteriorVenetianBlind:
    case EnumType::kLateralLeftCurtain:
    case EnumType::kLateralRightCurtain:
    case EnumType::kCentralCurtain:
    case EnumType::kRollerShutter:
    case EnumType::kExteriorVerticalScreen:
    case EnumType::kAwningTerracePatio:
    case EnumType::kAwningVerticalScreen:
    case EnumType::kTiltOnlyPergola:
    case EnumType::kSwingingShutter:
    case EnumType::kSlidingShutter:
    case EnumType::kUnknown:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(WindowCovering::Type val)
{
    switch (val)
    {
        using EnumType = WindowCovering::Type;
    case EnumType::kRollerShade:
    case EnumType::kRollerShade2Motor:
    case EnumType::kRollerShadeExterior:
    case EnumType::kRollerShadeExterior2Motor:
    case EnumType::kDrapery:
    case EnumType::kAwning:
    case EnumType::kShutter:
    case EnumType::kTiltBlindTiltOnly:
    case EnumType::kTiltBlindLiftAndTilt:
    case EnumType::kProjectorScreen:
    case EnumType::kUnknown:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(WindowCovering::ConfigStatus val)
{
    switch (val)
    {
        using EnumType = WindowCovering::ConfigStatus;
    case EnumType::kOperational:
    case EnumType::kOnlineReserved:
    case EnumType::kLiftMovementReversed:
    case EnumType::kLiftPositionAware:
    case EnumType::kTiltPositionAware:
    case EnumType::kLiftEncoderControlled:
    case EnumType::kTiltEncoderControlled:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(WindowCovering::Feature val)
{
    switch (val)
    {
        using EnumType = WindowCovering::Feature;
    case EnumType::kLift:
    case EnumType::kTilt:
    case EnumType::kPositionAwareLift:
    case EnumType::kAbsolutePosition:
    case EnumType::kPositionAwareTilt:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(WindowCovering::Mode val)
{
    switch (val)
    {
        using EnumType = WindowCovering::Mode;
    case EnumType::kMotorDirectionReversed:
    case EnumType::kCalibrationMode:
    case EnumType::kMaintenanceMode:
    case EnumType::kLedFeedback:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(WindowCovering::OperationalStatus val)
{
    switch (val)
    {
        using EnumType = WindowCovering::OperationalStatus;
    case EnumType::kGlobal:
    case EnumType::kLift:
    case EnumType::kTilt:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(WindowCovering::SafetyStatus val)
{
    switch (val)
    {
        using EnumType = WindowCovering::SafetyStatus;
    case EnumType::kRemoteLockout:
    case EnumType::kTamperDetection:
    case EnumType::kFailedCommunication:
    case EnumType::kPositionFailure:
    case EnumType::kThermalProtection:
    case EnumType::kObstacleDetected:
    case EnumType::kPower:
    case EnumType::kStopInput:
    case EnumType::kMotorJammed:
    case EnumType::kHardwareFailure:
    case EnumType::kManualOperation:
    case EnumType::kProtection:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(PumpConfigurationAndControl::PumpControlMode val)
{
    switch (val)
    {
        using EnumType = PumpConfigurationAndControl::PumpControlMode;
    case EnumType::kConstantSpeed:
    case EnumType::kConstantPressure:
    case EnumType::kProportionalPressure:
    case EnumType::kConstantFlow:
    case EnumType::kConstantTemperature:
    case EnumType::kAutomatic:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(PumpConfigurationAndControl::PumpOperationMode val)
{
    switch (val)
    {
        using EnumType = PumpConfigurationAndControl::PumpOperationMode;
    case EnumType::kNormal:
    case EnumType::kMinimum:
    case EnumType::kMaximum:
    case EnumType::kLocal:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(PumpConfigurationAndControl::PumpStatus val)
{
    switch (val)
    {
        using EnumType = PumpConfigurationAndControl::PumpStatus;
    case EnumType::kDeviceFault:
    case EnumType::kSupplyfault:
    case EnumType::kSpeedLow:
    case EnumType::kSpeedHigh:
    case EnumType::kLocalOverride:
    case EnumType::kRunning:
    case EnumType::kRemotePressure:
    case EnumType::kRemoteFlow:
    case EnumType::kRemoteTemperature:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Thermostat::SetpointAdjustMode val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = Thermostat::SetpointAdjustMode;
    case EnumType::kHeatSetpoint:
    case EnumType::kCoolSetpoint:
    case EnumType::kHeatAndCoolSetpoints:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_SETPOINT_ADJUST_MODE_HEAT_SETPOINT:
    case EMBER_ZCL_SETPOINT_ADJUST_MODE_COOL_SETPOINT:
    case EMBER_ZCL_SETPOINT_ADJUST_MODE_HEAT_AND_COOL_SETPOINTS:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Thermostat::ThermostatControlSequence val)
{
    switch (val)
    {
        using EnumType = Thermostat::ThermostatControlSequence;
    case EnumType::kCoolingOnly:
    case EnumType::kCoolingWithReheat:
    case EnumType::kHeatingOnly:
    case EnumType::kHeatingWithReheat:
    case EnumType::kCoolingAndHeating:
    case EnumType::kCoolingAndHeatingWithReheat:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Thermostat::ThermostatRunningMode val)
{
    switch (val)
    {
        using EnumType = Thermostat::ThermostatRunningMode;
    case EnumType::kOff:
    case EnumType::kCool:
    case EnumType::kHeat:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Thermostat::ThermostatSystemMode val)
{
    switch (val)
    {
        using EnumType = Thermostat::ThermostatSystemMode;
    case EnumType::kOff:
    case EnumType::kAuto:
    case EnumType::kCool:
    case EnumType::kHeat:
    case EnumType::kEmergencyHeating:
    case EnumType::kPrecooling:
    case EnumType::kFanOnly:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Thermostat::DayOfWeek val)
{
    switch (val)
    {
        using EnumType = Thermostat::DayOfWeek;
    case EnumType::kSunday:
    case EnumType::kMonday:
    case EnumType::kTuesday:
    case EnumType::kWednesday:
    case EnumType::kThursday:
    case EnumType::kFriday:
    case EnumType::kSaturday:
    case EnumType::kAwayOrVacation:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Thermostat::ModeForSequence val)
{
    switch (val)
    {
        using EnumType = Thermostat::ModeForSequence;
    case EnumType::kHeatSetpointFieldPresent:
    case EnumType::kCoolSetpointFieldPresent:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Thermostat::ThermostatFeature val)
{
    switch (val)
    {
        using EnumType = Thermostat::ThermostatFeature;
    case EnumType::kHeating:
    case EnumType::kCooling:
    case EnumType::kOccupancy:
    case EnumType::kSchedule:
    case EnumType::kSetback:
    case EnumType::kAutomode:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(FanControl::FanModeSequenceType val)
{
    switch (val)
    {
        using EnumType = FanControl::FanModeSequenceType;
    case EnumType::kOffLowMedHigh:
    case EnumType::kOffLowHigh:
    case EnumType::kOffLowMedHighAuto:
    case EnumType::kOffLowHighAuto:
    case EnumType::kOffOnAuto:
    case EnumType::kOffOn:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(FanControl::FanModeType val)
{
    switch (val)
    {
        using EnumType = FanControl::FanModeType;
    case EnumType::kOff:
    case EnumType::kLow:
    case EnumType::kMedium:
    case EnumType::kHigh:
    case EnumType::kOn:
    case EnumType::kAuto:
    case EnumType::kSmart:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(FanControl::FanControlFeature val)
{
    switch (val)
    {
        using EnumType = FanControl::FanControlFeature;
    case EnumType::kMultiSpeed:
    case EnumType::kAuto:
    case EnumType::kRocking:
    case EnumType::kWind:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(FanControl::RockSupportMask val)
{
    switch (val)
    {
        using EnumType = FanControl::RockSupportMask;
    case EnumType::kRockLeftRight:
    case EnumType::kRockUpDown:
    case EnumType::kRockRound:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(FanControl::WindSettingMask val)
{
    switch (val)
    {
        using EnumType = FanControl::WindSettingMask;
    case EnumType::kSleepWind:
    case EnumType::kNaturalWind:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(FanControl::WindSupportMask val)
{
    switch (val)
    {
        using EnumType = FanControl::WindSupportMask;
    case EnumType::kSleepWind:
    case EnumType::kNaturalWind:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ColorControl::ColorLoopAction val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = ColorControl::ColorLoopAction;
    case EnumType::kDeactivate:
    case EnumType::kActivateFromColorLoopStartEnhancedHue:
    case EnumType::kActivateFromEnhancedCurrentHue:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_COLOR_LOOP_ACTION_DEACTIVATE:
    case EMBER_ZCL_COLOR_LOOP_ACTION_ACTIVATE_FROM_COLOR_LOOP_START_ENHANCED_HUE:
    case EMBER_ZCL_COLOR_LOOP_ACTION_ACTIVATE_FROM_ENHANCED_CURRENT_HUE:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ColorControl::ColorLoopDirection val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = ColorControl::ColorLoopDirection;
    case EnumType::kDecrementHue:
    case EnumType::kIncrementHue:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_COLOR_LOOP_DIRECTION_DECREMENT_HUE:
    case EMBER_ZCL_COLOR_LOOP_DIRECTION_INCREMENT_HUE:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ColorControl::ColorMode val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = ColorControl::ColorMode;
    case EnumType::kCurrentHueAndCurrentSaturation:
    case EnumType::kCurrentXAndCurrentY:
    case EnumType::kColorTemperature:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_COLOR_MODE_CURRENT_HUE_AND_CURRENT_SATURATION:
    case EMBER_ZCL_COLOR_MODE_CURRENT_X_AND_CURRENT_Y:
    case EMBER_ZCL_COLOR_MODE_COLOR_TEMPERATURE:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ColorControl::HueDirection val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = ColorControl::HueDirection;
    case EnumType::kShortestDistance:
    case EnumType::kLongestDistance:
    case EnumType::kUp:
    case EnumType::kDown:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_HUE_DIRECTION_SHORTEST_DISTANCE:
    case EMBER_ZCL_HUE_DIRECTION_LONGEST_DISTANCE:
    case EMBER_ZCL_HUE_DIRECTION_UP:
    case EMBER_ZCL_HUE_DIRECTION_DOWN:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ColorControl::HueMoveMode val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = ColorControl::HueMoveMode;
    case EnumType::kStop:
    case EnumType::kUp:
    case EnumType::kDown:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_HUE_MOVE_MODE_STOP:
    case EMBER_ZCL_HUE_MOVE_MODE_UP:
    case EMBER_ZCL_HUE_MOVE_MODE_DOWN:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ColorControl::HueStepMode val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = ColorControl::HueStepMode;
    case EnumType::kUp:
    case EnumType::kDown:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_HUE_STEP_MODE_UP:
    case EMBER_ZCL_HUE_STEP_MODE_DOWN:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ColorControl::SaturationMoveMode val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = ColorControl::SaturationMoveMode;
    case EnumType::kStop:
    case EnumType::kUp:
    case EnumType::kDown:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_SATURATION_MOVE_MODE_STOP:
    case EMBER_ZCL_SATURATION_MOVE_MODE_UP:
    case EMBER_ZCL_SATURATION_MOVE_MODE_DOWN:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ColorControl::SaturationStepMode val)
{
    switch (val)
    {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        using EnumType = ColorControl::SaturationStepMode;
    case EnumType::kUp:
    case EnumType::kDown:
#else  // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
    case EMBER_ZCL_SATURATION_STEP_MODE_UP:
    case EMBER_ZCL_SATURATION_STEP_MODE_DOWN:
#endif // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ColorControl::ColorCapabilities val)
{
    switch (val)
    {
        using EnumType = ColorControl::ColorCapabilities;
    case EnumType::kHueSaturationSupported:
    case EnumType::kEnhancedHueSupported:
    case EnumType::kColorLoopSupported:
    case EnumType::kXYAttributesSupported:
    case EnumType::kColorTemperatureSupported:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ColorControl::ColorControlFeature val)
{
    switch (val)
    {
        using EnumType = ColorControl::ColorControlFeature;
    case EnumType::kHueAndSaturation:
    case EnumType::kEnhancedHue:
    case EnumType::kColorLoop:
    case EnumType::kXy:
    case EnumType::kColorTemperature:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ColorControl::ColorLoopUpdateFlags val)
{
    switch (val)
    {
        using EnumType = ColorControl::ColorLoopUpdateFlags;
    case EnumType::kUpdateAction:
    case EnumType::kUpdateDirection:
    case EnumType::kUpdateTime:
    case EnumType::kUpdateStartHue:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(IlluminanceMeasurement::LightSensorType val)
{
    switch (val)
    {
        using EnumType = IlluminanceMeasurement::LightSensorType;
    case EnumType::kPhotodiode:
    case EnumType::kCmos:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(PressureMeasurement::PressureFeature val)
{
    switch (val)
    {
        using EnumType = PressureMeasurement::PressureFeature;
    case EnumType::kExt:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Channel::ChannelStatusEnum val)
{
    switch (val)
    {
        using EnumType = Channel::ChannelStatusEnum;
    case EnumType::kSuccess:
    case EnumType::kMultipleMatches:
    case EnumType::kNoMatches:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Channel::LineupInfoTypeEnum val)
{
    switch (val)
    {
        using EnumType = Channel::LineupInfoTypeEnum;
    case EnumType::kMso:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Channel::ChannelFeature val)
{
    switch (val)
    {
        using EnumType = Channel::ChannelFeature;
    case EnumType::kChannelList:
    case EnumType::kLineupInfo:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(TargetNavigator::TargetNavigatorStatusEnum val)
{
    switch (val)
    {
        using EnumType = TargetNavigator::TargetNavigatorStatusEnum;
    case EnumType::kSuccess:
    case EnumType::kTargetNotFound:
    case EnumType::kNotAllowed:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(MediaPlayback::MediaPlaybackStatusEnum val)
{
    switch (val)
    {
        using EnumType = MediaPlayback::MediaPlaybackStatusEnum;
    case EnumType::kSuccess:
    case EnumType::kInvalidStateForCommand:
    case EnumType::kNotAllowed:
    case EnumType::kNotActive:
    case EnumType::kSpeedOutOfRange:
    case EnumType::kSeekOutOfRange:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(MediaPlayback::PlaybackStateEnum val)
{
    switch (val)
    {
        using EnumType = MediaPlayback::PlaybackStateEnum;
    case EnumType::kPlaying:
    case EnumType::kPaused:
    case EnumType::kNotPlaying:
    case EnumType::kBuffering:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(MediaInput::InputTypeEnum val)
{
    switch (val)
    {
        using EnumType = MediaInput::InputTypeEnum;
    case EnumType::kInternal:
    case EnumType::kAux:
    case EnumType::kCoax:
    case EnumType::kComposite:
    case EnumType::kHdmi:
    case EnumType::kInput:
    case EnumType::kLine:
    case EnumType::kOptical:
    case EnumType::kVideo:
    case EnumType::kScart:
    case EnumType::kUsb:
    case EnumType::kOther:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(MediaInput::MediaInputFeature val)
{
    switch (val)
    {
        using EnumType = MediaInput::MediaInputFeature;
    case EnumType::kNameUpdates:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(KeypadInput::CecKeyCode val)
{
    switch (val)
    {
        using EnumType = KeypadInput::CecKeyCode;
    case EnumType::kSelect:
    case EnumType::kUp:
    case EnumType::kDown:
    case EnumType::kLeft:
    case EnumType::kRight:
    case EnumType::kRightUp:
    case EnumType::kRightDown:
    case EnumType::kLeftUp:
    case EnumType::kLeftDown:
    case EnumType::kRootMenu:
    case EnumType::kSetupMenu:
    case EnumType::kContentsMenu:
    case EnumType::kFavoriteMenu:
    case EnumType::kExit:
    case EnumType::kMediaTopMenu:
    case EnumType::kMediaContextSensitiveMenu:
    case EnumType::kNumberEntryMode:
    case EnumType::kNumber11:
    case EnumType::kNumber12:
    case EnumType::kNumber0OrNumber10:
    case EnumType::kNumbers1:
    case EnumType::kNumbers2:
    case EnumType::kNumbers3:
    case EnumType::kNumbers4:
    case EnumType::kNumbers5:
    case EnumType::kNumbers6:
    case EnumType::kNumbers7:
    case EnumType::kNumbers8:
    case EnumType::kNumbers9:
    case EnumType::kDot:
    case EnumType::kEnter:
    case EnumType::kClear:
    case EnumType::kNextFavorite:
    case EnumType::kChannelUp:
    case EnumType::kChannelDown:
    case EnumType::kPreviousChannel:
    case EnumType::kSoundSelect:
    case EnumType::kInputSelect:
    case EnumType::kDisplayInformation:
    case EnumType::kHelp:
    case EnumType::kPageUp:
    case EnumType::kPageDown:
    case EnumType::kPower:
    case EnumType::kVolumeUp:
    case EnumType::kVolumeDown:
    case EnumType::kMute:
    case EnumType::kPlay:
    case EnumType::kStop:
    case EnumType::kPause:
    case EnumType::kRecord:
    case EnumType::kRewind:
    case EnumType::kFastForward:
    case EnumType::kEject:
    case EnumType::kForward:
    case EnumType::kBackward:
    case EnumType::kStopRecord:
    case EnumType::kPauseRecord:
    case EnumType::kReserved:
    case EnumType::kAngle:
    case EnumType::kSubPicture:
    case EnumType::kVideoOnDemand:
    case EnumType::kElectronicProgramGuide:
    case EnumType::kTimerProgramming:
    case EnumType::kInitialConfiguration:
    case EnumType::kSelectBroadcastType:
    case EnumType::kSelectSoundPresentation:
    case EnumType::kPlayFunction:
    case EnumType::kPausePlayFunction:
    case EnumType::kRecordFunction:
    case EnumType::kPauseRecordFunction:
    case EnumType::kStopFunction:
    case EnumType::kMuteFunction:
    case EnumType::kRestoreVolumeFunction:
    case EnumType::kTuneFunction:
    case EnumType::kSelectMediaFunction:
    case EnumType::kSelectAvInputFunction:
    case EnumType::kSelectAudioInputFunction:
    case EnumType::kPowerToggleFunction:
    case EnumType::kPowerOffFunction:
    case EnumType::kPowerOnFunction:
    case EnumType::kF1Blue:
    case EnumType::kF2Red:
    case EnumType::kF3Green:
    case EnumType::kF4Yellow:
    case EnumType::kF5:
    case EnumType::kData:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(KeypadInput::KeypadInputStatusEnum val)
{
    switch (val)
    {
        using EnumType = KeypadInput::KeypadInputStatusEnum;
    case EnumType::kSuccess:
    case EnumType::kUnsupportedKey:
    case EnumType::kInvalidKeyInCurrentState:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(KeypadInput::KeypadInputFeature val)
{
    switch (val)
    {
        using EnumType = KeypadInput::KeypadInputFeature;
    case EnumType::kNavigationKeyCodes:
    case EnumType::kLocationKeys:
    case EnumType::kNumberKeys:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ContentLauncher::ContentLaunchStatusEnum val)
{
    switch (val)
    {
        using EnumType = ContentLauncher::ContentLaunchStatusEnum;
    case EnumType::kSuccess:
    case EnumType::kUrlNotAvailable:
    case EnumType::kAuthFailed:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ContentLauncher::MetricTypeEnum val)
{
    switch (val)
    {
        using EnumType = ContentLauncher::MetricTypeEnum;
    case EnumType::kPixels:
    case EnumType::kPercentage:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ContentLauncher::ParameterEnum val)
{
    switch (val)
    {
        using EnumType = ContentLauncher::ParameterEnum;
    case EnumType::kActor:
    case EnumType::kChannel:
    case EnumType::kCharacter:
    case EnumType::kDirector:
    case EnumType::kEvent:
    case EnumType::kFranchise:
    case EnumType::kGenre:
    case EnumType::kLeague:
    case EnumType::kPopularity:
    case EnumType::kProvider:
    case EnumType::kSport:
    case EnumType::kSportsTeam:
    case EnumType::kType:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ContentLauncher::ContentLauncherFeature val)
{
    switch (val)
    {
        using EnumType = ContentLauncher::ContentLauncherFeature;
    case EnumType::kContentSearch:
    case EnumType::kURLPlayback:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ContentLauncher::SupportedStreamingProtocol val)
{
    switch (val)
    {
        using EnumType = ContentLauncher::SupportedStreamingProtocol;
    case EnumType::kDash:
    case EnumType::kHls:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(AudioOutput::OutputTypeEnum val)
{
    switch (val)
    {
        using EnumType = AudioOutput::OutputTypeEnum;
    case EnumType::kHdmi:
    case EnumType::kBt:
    case EnumType::kOptical:
    case EnumType::kHeadphone:
    case EnumType::kInternal:
    case EnumType::kOther:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(AudioOutput::AudioOutputFeature val)
{
    switch (val)
    {
        using EnumType = AudioOutput::AudioOutputFeature;
    case EnumType::kNameUpdates:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ApplicationLauncher::ApplicationLauncherStatusEnum val)
{
    switch (val)
    {
        using EnumType = ApplicationLauncher::ApplicationLauncherStatusEnum;
    case EnumType::kSuccess:
    case EnumType::kAppNotAvailable:
    case EnumType::kSystemBusy:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ApplicationLauncher::ApplicationLauncherFeature val)
{
    switch (val)
    {
        using EnumType = ApplicationLauncher::ApplicationLauncherFeature;
    case EnumType::kApplicationPlatform:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ApplicationBasic::ApplicationStatusEnum val)
{
    switch (val)
    {
        using EnumType = ApplicationBasic::ApplicationStatusEnum;
    case EnumType::kStopped:
    case EnumType::kActiveVisibleFocus:
    case EnumType::kActiveHidden:
    case EnumType::kActiveVisibleNotFocus:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Messaging::EventId val)
{
    switch (val)
    {
        using EnumType = Messaging::EventId;
    case EnumType::kMeterCoverRemoved:
    case EnumType::kMeterCoverClosed:
    case EnumType::kStrongMagneticField:
    case EnumType::kNoStrongMagneticField:
    case EnumType::kBatteryFailure:
    case EnumType::kLowBattery:
    case EnumType::kProgramMemoryError:
    case EnumType::kRamError:
    case EnumType::kNvMemoryError:
    case EnumType::kMeasurementSystemError:
    case EnumType::kWatchdogError:
    case EnumType::kSupplyDisconnectFailure:
    case EnumType::kSupplyConnectFailure:
    case EnumType::kMeasurmentSoftwareChanged:
    case EnumType::kDstEnabled:
    case EnumType::kDstDisabled:
    case EnumType::kClockAdjBackward:
    case EnumType::kClockAdjForward:
    case EnumType::kClockInvalid:
    case EnumType::kCommsErrorHan:
    case EnumType::kCommsOkHan:
    case EnumType::kFraudAttempt:
    case EnumType::kPowerLoss:
    case EnumType::kIncorrectProtocol:
    case EnumType::kUnusualHanTraffic:
    case EnumType::kUnexpectedClockChange:
    case EnumType::kCommsUsingUnauthenticatedComponent:
    case EnumType::kErrorRegClear:
    case EnumType::kAlarmRegClear:
    case EnumType::kUnexpectedHwReset:
    case EnumType::kUnexpectedProgramExecution:
    case EnumType::kEventLogCleared:
    case EnumType::kManualDisconnect:
    case EnumType::kManualConnect:
    case EnumType::kRemoteDisconnection:
    case EnumType::kLocalDisconnection:
    case EnumType::kLimitThresholdExceeded:
    case EnumType::kLimitThresholdOk:
    case EnumType::kLimitThresholdChanged:
    case EnumType::kMaximumDemandExceeded:
    case EnumType::kProfileCleared:
    case EnumType::kFirmwareReadyForActivation:
    case EnumType::kFirmwareActivated:
    case EnumType::kPatchFailure:
    case EnumType::kTouTariffActivation:
    case EnumType::k8x8Tariffactivated:
    case EnumType::kSingleTariffRateActivated:
    case EnumType::kAsynchronousBillingOccurred:
    case EnumType::kSynchronousBillingOccurred:
    case EnumType::kIncorrectPolarity:
    case EnumType::kCurrentNoVoltage:
    case EnumType::kUnderVoltage:
    case EnumType::kOverVoltage:
    case EnumType::kNormalVoltage:
    case EnumType::kPfBelowThreshold:
    case EnumType::kPfAboveThreshold:
    case EnumType::kTerminalCoverRemoved:
    case EnumType::kTerminalCoverClosed:
    case EnumType::kReverseFlow:
    case EnumType::kTiltTamper:
    case EnumType::kBatteryCoverRemoved:
    case EnumType::kBatteryCoverClosed:
    case EnumType::kExcessFlow:
    case EnumType::kCreditOk:
    case EnumType::kLowCredit:
    case EnumType::kEmergencyCreditInUse:
    case EnumType::kEmergencyCreditExhausted:
    case EnumType::kZeroCreditEcNotSelected:
    case EnumType::kSupplyOn:
    case EnumType::kSupplyOffAarmed:
    case EnumType::kSupplyOff:
    case EnumType::kDiscountApplied:
    case EnumType::kManufacturerSpecificA:
    case EnumType::kManufacturerSpecificB:
    case EnumType::kManufacturerSpecificC:
    case EnumType::kManufacturerSpecificD:
    case EnumType::kManufacturerSpecificE:
    case EnumType::kManufacturerSpecificF:
    case EnumType::kManufacturerSpecificG:
    case EnumType::kManufacturerSpecificH:
    case EnumType::kManufacturerSpecificI:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Messaging::MessagingControlConfirmation val)
{
    switch (val)
    {
        using EnumType = Messaging::MessagingControlConfirmation;
    case EnumType::kNotRequired:
    case EnumType::kRequired:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Messaging::MessagingControlEnhancedConfirmation val)
{
    switch (val)
    {
        using EnumType = Messaging::MessagingControlEnhancedConfirmation;
    case EnumType::kNotRequired:
    case EnumType::kRequired:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Messaging::MessagingControlImportance val)
{
    switch (val)
    {
        using EnumType = Messaging::MessagingControlImportance;
    case EnumType::kLow:
    case EnumType::kMedium:
    case EnumType::kHigh:
    case EnumType::kCritical:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Messaging::MessagingControlTransmission val)
{
    switch (val)
    {
        using EnumType = Messaging::MessagingControlTransmission;
    case EnumType::kNormal:
    case EnumType::kNormalAndAnonymous:
    case EnumType::kAnonymous:
    case EnumType::kReserved:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Messaging::MessagingConfirmationControl val)
{
    switch (val)
    {
        using EnumType = Messaging::MessagingConfirmationControl;
    case EnumType::kNoReturned:
    case EnumType::kYesReturned:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Messaging::MessagingControlMask val)
{
    switch (val)
    {
        using EnumType = Messaging::MessagingControlMask;
    case EnumType::kTransMechanism:
    case EnumType::kMessageUrgency:
    case EnumType::kEnhancedConfirmationRequest:
    case EnumType::kMessageConfirmation:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(Messaging::MessagingExtendedControlMask val)
{
    switch (val)
    {
        using EnumType = Messaging::MessagingExtendedControlMask;
    case EnumType::kMessageConfirmationStatus:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ApplianceEventsAndAlert::EventIdentification val)
{
    switch (val)
    {
        using EnumType = ApplianceEventsAndAlert::EventIdentification;
    case EnumType::kEndOfCycle:
    case EnumType::kTemperatureReached:
    case EnumType::kEndOfCooking:
    case EnumType::kSwitchingOff:
    case EnumType::kWrongData:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ApplianceEventsAndAlert::AlertCount val)
{
    switch (val)
    {
        using EnumType = ApplianceEventsAndAlert::AlertCount;
    case EnumType::kNumberOfAlerts:
    case EnumType::kTypeOfAlert:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(ApplianceEventsAndAlert::AlertStructure val)
{
    switch (val)
    {
        using EnumType = ApplianceEventsAndAlert::AlertStructure;
    case EnumType::kAlertId:
    case EnumType::kCategory:
    case EnumType::kPresenceRecovery:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(TestCluster::SimpleEnum val)
{
    switch (val)
    {
        using EnumType = TestCluster::SimpleEnum;
    case EnumType::kUnspecified:
    case EnumType::kValueA:
    case EnumType::kValueB:
    case EnumType::kValueC:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(TestCluster::Bitmap16MaskMap val)
{
    switch (val)
    {
        using EnumType = TestCluster::Bitmap16MaskMap;
    case EnumType::kMaskVal1:
    case EnumType::kMaskVal2:
    case EnumType::kMaskVal3:
    case EnumType::kMaskVal4:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(TestCluster::Bitmap32MaskMap val)
{
    switch (val)
    {
        using EnumType = TestCluster::Bitmap32MaskMap;
    case EnumType::kMaskVal1:
    case EnumType::kMaskVal2:
    case EnumType::kMaskVal3:
    case EnumType::kMaskVal4:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(TestCluster::Bitmap64MaskMap val)
{
    switch (val)
    {
        using EnumType = TestCluster::Bitmap64MaskMap;
    case EnumType::kMaskVal1:
    case EnumType::kMaskVal2:
    case EnumType::kMaskVal3:
    case EnumType::kMaskVal4:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(TestCluster::Bitmap8MaskMap val)
{
    switch (val)
    {
        using EnumType = TestCluster::Bitmap8MaskMap;
    case EnumType::kMaskVal1:
    case EnumType::kMaskVal2:
    case EnumType::kMaskVal3:
    case EnumType::kMaskVal4:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
static CHIP_ERROR __attribute__((unused)) CheckValidEnumValue(TestCluster::SimpleBitmap val)
{
    switch (val)
    {
        using EnumType = TestCluster::SimpleBitmap;
    case EnumType::kValueA:
    case EnumType::kValueB:
    case EnumType::kValueC:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

} // namespace Clusters
} // namespace app
} // namespace chip
