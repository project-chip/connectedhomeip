/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

/**
 *  @file
 *    This file contains definitions for accessors around clusters attributes.
 */

#include <app-common/zap-generated/attributes/Accessors.h>

#include <app-common/zap-generated/attribute-type.h>
#include <app-common/zap-generated/ids/Attributes.h>
#include <app-common/zap-generated/ids/Clusters.h>
#include <app/util/af.h>
#include <app/util/attribute-storage-null-handling.h>
#include <app/util/odd-sized-integers.h>

namespace chip {
namespace app {
namespace Clusters {

namespace PowerConfiguration {
namespace Attributes {

namespace MainsVoltage {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MainsVoltage

namespace MainsFrequency {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace MainsFrequency

namespace MainsAlarmMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace MainsAlarmMask

namespace MainsVoltageMinThreshold {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MainsVoltageMinThreshold

namespace MainsVoltageMaxThreshold {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MainsVoltageMaxThreshold

namespace MainsVoltageDwellTrip {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MainsVoltageDwellTrip

namespace BatteryVoltage {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BatteryVoltage

namespace BatteryPercentageRemaining {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BatteryPercentageRemaining

namespace BatteryManufacturer {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace BatteryManufacturer

namespace BatterySize {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace BatterySize

namespace BatteryAhrRating {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace BatteryAhrRating

namespace BatteryQuantity {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BatteryQuantity

namespace BatteryRatedVoltage {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BatteryRatedVoltage

namespace BatteryAlarmMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace BatteryAlarmMask

namespace BatteryVoltageMinThreshold {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BatteryVoltageMinThreshold

namespace BatteryVoltageThreshold1 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BatteryVoltageThreshold1

namespace BatteryVoltageThreshold2 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BatteryVoltageThreshold2

namespace BatteryVoltageThreshold3 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BatteryVoltageThreshold3

namespace BatteryPercentageMinThreshold {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BatteryPercentageMinThreshold

namespace BatteryPercentageThreshold1 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BatteryPercentageThreshold1

namespace BatteryPercentageThreshold2 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BatteryPercentageThreshold2

namespace BatteryPercentageThreshold3 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BatteryPercentageThreshold3

namespace BatteryAlarmState {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_BITMAP32_ATTRIBUTE_TYPE);
}

} // namespace BatteryAlarmState

namespace Battery2Voltage {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery2Voltage

namespace Battery2PercentageRemaining {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery2PercentageRemaining

namespace Battery2Manufacturer {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace Battery2Manufacturer

namespace Battery2Size {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace Battery2Size

namespace Battery2AhrRating {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Battery2AhrRating

namespace Battery2Quantity {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery2Quantity

namespace Battery2RatedVoltage {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery2RatedVoltage

namespace Battery2AlarmMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace Battery2AlarmMask

namespace Battery2VoltageMinThreshold {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery2VoltageMinThreshold

namespace Battery2VoltageThreshold1 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery2VoltageThreshold1

namespace Battery2VoltageThreshold2 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery2VoltageThreshold2

namespace Battery2VoltageThreshold3 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery2VoltageThreshold3

namespace Battery2PercentageMinThreshold {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery2PercentageMinThreshold

namespace Battery2PercentageThreshold1 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery2PercentageThreshold1

namespace Battery2PercentageThreshold2 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery2PercentageThreshold2

namespace Battery2PercentageThreshold3 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery2PercentageThreshold3

namespace Battery2AlarmState {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_BITMAP32_ATTRIBUTE_TYPE);
}

} // namespace Battery2AlarmState

namespace Battery3Voltage {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery3Voltage

namespace Battery3PercentageRemaining {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery3PercentageRemaining

namespace Battery3Manufacturer {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace Battery3Manufacturer

namespace Battery3Size {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace Battery3Size

namespace Battery3AhrRating {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Battery3AhrRating

namespace Battery3Quantity {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery3Quantity

namespace Battery3RatedVoltage {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery3RatedVoltage

namespace Battery3AlarmMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace Battery3AlarmMask

namespace Battery3VoltageMinThreshold {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery3VoltageMinThreshold

namespace Battery3VoltageThreshold1 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery3VoltageThreshold1

namespace Battery3VoltageThreshold2 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery3VoltageThreshold2

namespace Battery3VoltageThreshold3 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery3VoltageThreshold3

namespace Battery3PercentageMinThreshold {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery3PercentageMinThreshold

namespace Battery3PercentageThreshold1 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery3PercentageThreshold1

namespace Battery3PercentageThreshold2 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery3PercentageThreshold2

namespace Battery3PercentageThreshold3 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Battery3PercentageThreshold3

namespace Battery3AlarmState {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerConfiguration::Id, Id, writable, ZCL_BITMAP32_ATTRIBUTE_TYPE);
}

} // namespace Battery3AlarmState

} // namespace Attributes
} // namespace PowerConfiguration

namespace DeviceTemperatureConfiguration {
namespace Attributes {

namespace CurrentTemperature {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, writable,
                                       ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace CurrentTemperature

namespace MinTempExperienced {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, writable,
                                       ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MinTempExperienced

namespace MaxTempExperienced {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, writable,
                                       ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MaxTempExperienced

namespace OverTempTotalDwell {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, writable,
                                       ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace OverTempTotalDwell

namespace DeviceTempAlarmMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, writable,
                                       ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace DeviceTempAlarmMask

namespace LowTempThreshold {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, writable,
                                       ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace LowTempThreshold

namespace HighTempThreshold {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, writable,
                                       ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace HighTempThreshold

namespace LowTempDwellTripPoint {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<3, false>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<3, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, writable,
                                       ZCL_INT24U_ATTRIBUTE_TYPE);
}

} // namespace LowTempDwellTripPoint

namespace HighTempDwellTripPoint {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<3, false>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<3, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DeviceTemperatureConfiguration::Id, Id, writable,
                                       ZCL_INT24U_ATTRIBUTE_TYPE);
}

} // namespace HighTempDwellTripPoint

} // namespace Attributes
} // namespace DeviceTemperatureConfiguration

namespace Identify {
namespace Attributes {

namespace IdentifyTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Identify::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Identify::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace IdentifyTime

namespace IdentifyType {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Identify::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Identify::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace IdentifyType

} // namespace Attributes
} // namespace Identify

namespace Groups {
namespace Attributes {

namespace NameSupport {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Groups::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Groups::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace NameSupport

} // namespace Attributes
} // namespace Groups

namespace Scenes {
namespace Attributes {

namespace SceneCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Scenes::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Scenes::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace SceneCount

namespace CurrentScene {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Scenes::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Scenes::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace CurrentScene

namespace CurrentGroup {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Scenes::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Scenes::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace CurrentGroup

namespace SceneValid {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Scenes::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Scenes::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace SceneValid

namespace NameSupport {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Scenes::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Scenes::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace NameSupport

namespace LastConfiguredBy {

EmberAfStatus Get(chip::EndpointId endpoint, chip::NodeId * value)
{
    NumericAttributeTraits<chip::NodeId>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<chip::NodeId>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Scenes::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<chip::NodeId>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<chip::NodeId>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::NodeId value)
{
    if (!NumericAttributeTraits<chip::NodeId>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<chip::NodeId>::StorageType storageValue;
    NumericAttributeTraits<chip::NodeId>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<chip::NodeId>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Scenes::Id, Id, writable, ZCL_NODE_ID_ATTRIBUTE_TYPE);
}

} // namespace LastConfiguredBy

} // namespace Attributes
} // namespace Scenes

namespace OnOff {
namespace Attributes {

namespace OnOff {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OnOff::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OnOff::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace OnOff

namespace GlobalSceneControl {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OnOff::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OnOff::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace GlobalSceneControl

namespace OnTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OnOff::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OnOff::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace OnTime

namespace OffWaitTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OnOff::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OnOff::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace OffWaitTime

namespace StartUpOnOff {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OnOff::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OnOff::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace StartUpOnOff

} // namespace Attributes
} // namespace OnOff

namespace OnOffSwitchConfiguration {
namespace Attributes {

namespace SwitchType {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OnOffSwitchConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OnOffSwitchConfiguration::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace SwitchType

namespace SwitchActions {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OnOffSwitchConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OnOffSwitchConfiguration::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace SwitchActions

} // namespace Attributes
} // namespace OnOffSwitchConfiguration

namespace LevelControl {
namespace Attributes {

namespace CurrentLevel {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::LevelControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace CurrentLevel

namespace RemainingTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::LevelControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RemainingTime

namespace MinLevel {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::LevelControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace MinLevel

namespace MaxLevel {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::LevelControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace MaxLevel

namespace CurrentFrequency {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::LevelControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace CurrentFrequency

namespace MinFrequency {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::LevelControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MinFrequency

namespace MaxFrequency {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::LevelControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MaxFrequency

namespace Options {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::LevelControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace Options

namespace OnOffTransitionTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::LevelControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace OnOffTransitionTime

namespace OnLevel {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint8_t> & value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::LevelControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint8_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint8_t>::StorageType value;
    NumericAttributeTraits<uint8_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint8_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace OnLevel

namespace OnTransitionTime {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint16_t> & value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::LevelControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint16_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint16_t>::StorageType value;
    NumericAttributeTraits<uint16_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint16_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace OnTransitionTime

namespace OffTransitionTime {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint16_t> & value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::LevelControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint16_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint16_t>::StorageType value;
    NumericAttributeTraits<uint16_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint16_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace OffTransitionTime

namespace DefaultMoveRate {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint8_t> & value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::LevelControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint8_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint8_t>::StorageType value;
    NumericAttributeTraits<uint8_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint8_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace DefaultMoveRate

namespace StartUpCurrentLevel {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::LevelControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LevelControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace StartUpCurrentLevel

} // namespace Attributes
} // namespace LevelControl

namespace Alarms {
namespace Attributes {

namespace AlarmCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Alarms::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Alarms::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AlarmCount

} // namespace Attributes
} // namespace Alarms

namespace Time {
namespace Attributes {

namespace Time {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Time::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Time::Id, Id, writable, ZCL_EPOCH_S_ATTRIBUTE_TYPE);
}

} // namespace Time

namespace TimeStatus {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Time::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Time::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace TimeStatus

namespace TimeZone {

EmberAfStatus Get(chip::EndpointId endpoint, int32_t * value)
{
    NumericAttributeTraits<int32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Time::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int32_t value)
{
    if (!NumericAttributeTraits<int32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int32_t>::StorageType storageValue;
    NumericAttributeTraits<int32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Time::Id, Id, writable, ZCL_INT32S_ATTRIBUTE_TYPE);
}

} // namespace TimeZone

namespace DstStart {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Time::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Time::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace DstStart

namespace DstEnd {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Time::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Time::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace DstEnd

namespace DstShift {

EmberAfStatus Get(chip::EndpointId endpoint, int32_t * value)
{
    NumericAttributeTraits<int32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Time::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int32_t value)
{
    if (!NumericAttributeTraits<int32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int32_t>::StorageType storageValue;
    NumericAttributeTraits<int32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Time::Id, Id, writable, ZCL_INT32S_ATTRIBUTE_TYPE);
}

} // namespace DstShift

namespace StandardTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Time::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Time::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace StandardTime

namespace LocalTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Time::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Time::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace LocalTime

namespace LastSetTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Time::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Time::Id, Id, writable, ZCL_EPOCH_S_ATTRIBUTE_TYPE);
}

} // namespace LastSetTime

namespace ValidUntilTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Time::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Time::Id, Id, writable, ZCL_EPOCH_S_ATTRIBUTE_TYPE);
}

} // namespace ValidUntilTime

} // namespace Attributes
} // namespace Time

namespace BinaryInputBasic {
namespace Attributes {

namespace ActiveText {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace ActiveText

namespace Description {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace Description

namespace InactiveText {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace InactiveText

namespace OutOfService {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace OutOfService

namespace Polarity {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace Polarity

namespace PresentValue {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace PresentValue

namespace Reliability {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace Reliability

namespace StatusFlags {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace StatusFlags

namespace ApplicationType {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BinaryInputBasic::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace ApplicationType

} // namespace Attributes
} // namespace BinaryInputBasic

namespace PowerProfile {
namespace Attributes {

namespace TotalProfileNum {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerProfile::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerProfile::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace TotalProfileNum

namespace MultipleScheduling {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerProfile::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerProfile::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace MultipleScheduling

namespace EnergyFormatting {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerProfile::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerProfile::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace EnergyFormatting

namespace EnergyRemote {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerProfile::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerProfile::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace EnergyRemote

namespace ScheduleMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerProfile::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerProfile::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace ScheduleMode

} // namespace Attributes
} // namespace PowerProfile

namespace ApplianceControl {
namespace Attributes {

namespace StartTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplianceControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace StartTime

namespace FinishTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplianceControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace FinishTime

namespace RemainingTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplianceControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RemainingTime

} // namespace Attributes
} // namespace ApplianceControl

namespace Descriptor {
namespace Attributes {

} // namespace Attributes
} // namespace Descriptor

namespace AccessControl {
namespace Attributes {

} // namespace Attributes
} // namespace AccessControl

namespace PollControl {
namespace Attributes {

namespace CheckInInterval {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PollControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PollControl::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace CheckInInterval

namespace LongPollInterval {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PollControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PollControl::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace LongPollInterval

namespace ShortPollInterval {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PollControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PollControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ShortPollInterval

namespace FastPollTimeout {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PollControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PollControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace FastPollTimeout

namespace CheckInIntervalMin {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PollControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PollControl::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace CheckInIntervalMin

namespace LongPollIntervalMin {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PollControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PollControl::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace LongPollIntervalMin

namespace FastPollTimeoutMax {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PollControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PollControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace FastPollTimeoutMax

} // namespace Attributes
} // namespace PollControl

namespace BridgedActions {
namespace Attributes {

namespace SetupUrl {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[512 + 2];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedActions::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfLongStringLength(zclString);
    if (length == NumericAttributeTraits<uint16_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 512, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[2], 512);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(512 < NumericAttributeTraits<uint16_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 512, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[512 + 2];
    emberAfCopyInt16u(zclString, 0, static_cast<uint16_t>(value.size()));
    memcpy(&zclString[2], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedActions::Id, Id, zclString, ZCL_LONG_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace SetupUrl

} // namespace Attributes
} // namespace BridgedActions

namespace Basic {
namespace Attributes {

namespace InteractionModelVersion {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace InteractionModelVersion

namespace VendorName {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace VendorName

namespace VendorID {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace VendorID

namespace ProductName {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace ProductName

namespace ProductID {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ProductID

namespace NodeLabel {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace NodeLabel

namespace Location {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[2 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 2, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 2);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(2 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 2, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[2 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace Location

namespace HardwareVersion {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace HardwareVersion

namespace HardwareVersionString {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[64 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 64, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 64);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(64 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 64, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[64 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace HardwareVersionString

namespace SoftwareVersion {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace SoftwareVersion

namespace SoftwareVersionString {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[64 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 64, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 64);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(64 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 64, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[64 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace SoftwareVersionString

namespace ManufacturingDate {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace ManufacturingDate

namespace PartNumber {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace PartNumber

namespace ProductURL {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[256 + 2];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfLongStringLength(zclString);
    if (length == NumericAttributeTraits<uint16_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 256, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[2], 256);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(256 < NumericAttributeTraits<uint16_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 256, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[256 + 2];
    emberAfCopyInt16u(zclString, 0, static_cast<uint16_t>(value.size()));
    memcpy(&zclString[2], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, ZCL_LONG_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace ProductURL

namespace ProductLabel {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[64 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 64, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 64);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(64 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 64, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[64 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace ProductLabel

namespace SerialNumber {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace SerialNumber

namespace LocalConfigDisabled {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace LocalConfigDisabled

namespace Reachable {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace Reachable

namespace UniqueID {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::Basic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace UniqueID

} // namespace Attributes
} // namespace Basic

namespace OtaSoftwareUpdateRequestor {
namespace Attributes {

namespace DefaultOtaProvider {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::OtaSoftwareUpdateRequestor::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::OtaSoftwareUpdateRequestor::Id, Id, zclString,
                                       ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace DefaultOtaProvider

namespace UpdatePossible {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::OtaSoftwareUpdateRequestor::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OtaSoftwareUpdateRequestor::Id, Id, writable,
                                       ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace UpdatePossible

} // namespace Attributes
} // namespace OtaSoftwareUpdateRequestor

namespace PowerSourceConfiguration {
namespace Attributes {

} // namespace Attributes
} // namespace PowerSourceConfiguration

namespace PowerSource {
namespace Attributes {

namespace Status {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace Status

namespace Order {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Order

namespace Description {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[60 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 60, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 60);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(60 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 60, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[60 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace Description

namespace WiredAssessedInputVoltage {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace WiredAssessedInputVoltage

namespace WiredAssessedInputFrequency {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace WiredAssessedInputFrequency

namespace WiredCurrentType {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace WiredCurrentType

namespace WiredAssessedCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace WiredAssessedCurrent

namespace WiredNominalVoltage {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace WiredNominalVoltage

namespace WiredMaximumCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace WiredMaximumCurrent

namespace WiredPresent {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace WiredPresent

namespace BatteryVoltage {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace BatteryVoltage

namespace BatteryPercentRemaining {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BatteryPercentRemaining

namespace BatteryTimeRemaining {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace BatteryTimeRemaining

namespace BatteryChargeLevel {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace BatteryChargeLevel

namespace BatteryReplacementNeeded {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace BatteryReplacementNeeded

namespace BatteryReplaceability {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace BatteryReplaceability

namespace BatteryPresent {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace BatteryPresent

namespace BatteryReplacementDescription {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[60 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 60, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 60);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(60 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 60, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[60 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace BatteryReplacementDescription

namespace BatteryCommonDesignation {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace BatteryCommonDesignation

namespace BatteryANSIDesignation {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[20 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 20, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 20);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(20 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 20, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[20 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace BatteryANSIDesignation

namespace BatteryIECDesignation {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[20 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 20, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 20);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(20 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 20, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[20 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace BatteryIECDesignation

namespace BatteryApprovedChemistry {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace BatteryApprovedChemistry

namespace BatteryCapacity {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace BatteryCapacity

namespace BatteryQuantity {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BatteryQuantity

namespace BatteryChargeState {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace BatteryChargeState

namespace BatteryTimeToFullCharge {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace BatteryTimeToFullCharge

namespace BatteryFunctionalWhileCharging {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace BatteryFunctionalWhileCharging

namespace BatteryChargingCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PowerSource::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PowerSource::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace BatteryChargingCurrent

} // namespace Attributes
} // namespace PowerSource

namespace GeneralCommissioning {
namespace Attributes {

namespace Breadcrumb {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::GeneralCommissioning::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::GeneralCommissioning::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace Breadcrumb

namespace RegulatoryConfig {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::GeneralCommissioning::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::GeneralCommissioning::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace RegulatoryConfig

namespace LocationCapability {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::GeneralCommissioning::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::GeneralCommissioning::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace LocationCapability

} // namespace Attributes
} // namespace GeneralCommissioning

namespace GeneralDiagnostics {
namespace Attributes {

namespace RebootCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::GeneralDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::GeneralDiagnostics::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RebootCount

namespace UpTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::GeneralDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::GeneralDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace UpTime

namespace TotalOperationalHours {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::GeneralDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::GeneralDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TotalOperationalHours

namespace BootReasons {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::GeneralDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::GeneralDiagnostics::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace BootReasons

} // namespace Attributes
} // namespace GeneralDiagnostics

namespace SoftwareDiagnostics {
namespace Attributes {

namespace CurrentHeapFree {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::SoftwareDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::SoftwareDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace CurrentHeapFree

namespace CurrentHeapUsed {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::SoftwareDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::SoftwareDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace CurrentHeapUsed

namespace CurrentHeapHighWatermark {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::SoftwareDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::SoftwareDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace CurrentHeapHighWatermark

} // namespace Attributes
} // namespace SoftwareDiagnostics

namespace ThreadNetworkDiagnostics {
namespace Attributes {

namespace Channel {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Channel

namespace RoutingRole {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace RoutingRole

namespace NetworkName {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, zclString,
                                       ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace NetworkName

namespace PanId {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace PanId

namespace ExtendedPanId {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace ExtendedPanId

namespace MeshLocalPrefix {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[17 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 17, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 17);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(17 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 17, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[17 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, zclString,
                                       ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace MeshLocalPrefix

namespace OverrunCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace OverrunCount

namespace PartitionId {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace PartitionId

namespace Weighting {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Weighting

namespace DataVersion {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace DataVersion

namespace StableDataVersion {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace StableDataVersion

namespace LeaderRouterId {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace LeaderRouterId

namespace DetachedRoleCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace DetachedRoleCount

namespace ChildRoleCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ChildRoleCount

namespace RouterRoleCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RouterRoleCount

namespace LeaderRoleCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace LeaderRoleCount

namespace AttachAttemptCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AttachAttemptCount

namespace PartitionIdChangeCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace PartitionIdChangeCount

namespace BetterPartitionAttachAttemptCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace BetterPartitionAttachAttemptCount

namespace ParentChangeCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ParentChangeCount

namespace TxTotalCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxTotalCount

namespace TxUnicastCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxUnicastCount

namespace TxBroadcastCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxBroadcastCount

namespace TxAckRequestedCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxAckRequestedCount

namespace TxAckedCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxAckedCount

namespace TxNoAckRequestedCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxNoAckRequestedCount

namespace TxDataCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxDataCount

namespace TxDataPollCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxDataPollCount

namespace TxBeaconCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxBeaconCount

namespace TxBeaconRequestCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxBeaconRequestCount

namespace TxOtherCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxOtherCount

namespace TxRetryCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxRetryCount

namespace TxDirectMaxRetryExpiryCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxDirectMaxRetryExpiryCount

namespace TxIndirectMaxRetryExpiryCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxIndirectMaxRetryExpiryCount

namespace TxErrCcaCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxErrCcaCount

namespace TxErrAbortCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxErrAbortCount

namespace TxErrBusyChannelCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TxErrBusyChannelCount

namespace RxTotalCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxTotalCount

namespace RxUnicastCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxUnicastCount

namespace RxBroadcastCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxBroadcastCount

namespace RxDataCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxDataCount

namespace RxDataPollCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxDataPollCount

namespace RxBeaconCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxBeaconCount

namespace RxBeaconRequestCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxBeaconRequestCount

namespace RxOtherCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxOtherCount

namespace RxAddressFilteredCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxAddressFilteredCount

namespace RxDestAddrFilteredCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxDestAddrFilteredCount

namespace RxDuplicatedCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxDuplicatedCount

namespace RxErrNoFrameCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxErrNoFrameCount

namespace RxErrUnknownNeighborCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxErrUnknownNeighborCount

namespace RxErrInvalidSrcAddrCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxErrInvalidSrcAddrCount

namespace RxErrSecCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxErrSecCount

namespace RxErrFcsCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxErrFcsCount

namespace RxErrOtherCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace RxErrOtherCount

namespace ActiveTimestamp {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace ActiveTimestamp

namespace PendingTimestamp {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace PendingTimestamp

namespace Delay {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace Delay

namespace ChannelMask {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[4 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 4, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 4);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(4 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 4, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[4 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::ThreadNetworkDiagnostics::Id, Id, zclString,
                                       ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace ChannelMask

} // namespace Attributes
} // namespace ThreadNetworkDiagnostics

namespace WiFiNetworkDiagnostics {
namespace Attributes {

namespace Bssid {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[6 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 6, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 6);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(6 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 6, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[6 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, zclString,
                                       ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace Bssid

namespace SecurityType {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace SecurityType

namespace WiFiVersion {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace WiFiVersion

namespace ChannelNumber {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ChannelNumber

namespace Rssi {

EmberAfStatus Get(chip::EndpointId endpoint, int8_t * value)
{
    NumericAttributeTraits<int8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int8_t value)
{
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int8_t>::StorageType storageValue;
    NumericAttributeTraits<int8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, writable, ZCL_INT8S_ATTRIBUTE_TYPE);
}

} // namespace Rssi

namespace BeaconLostCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace BeaconLostCount

namespace BeaconRxCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace BeaconRxCount

namespace PacketMulticastRxCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace PacketMulticastRxCount

namespace PacketMulticastTxCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace PacketMulticastTxCount

namespace PacketUnicastRxCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace PacketUnicastRxCount

namespace PacketUnicastTxCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace PacketUnicastTxCount

namespace CurrentMaxRate {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace CurrentMaxRate

namespace OverrunCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WiFiNetworkDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace OverrunCount

} // namespace Attributes
} // namespace WiFiNetworkDiagnostics

namespace EthernetNetworkDiagnostics {
namespace Attributes {

namespace PHYRate {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace PHYRate

namespace FullDuplex {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, writable,
                                       ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace FullDuplex

namespace PacketRxCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace PacketRxCount

namespace PacketTxCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace PacketTxCount

namespace TxErrCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace TxErrCount

namespace CollisionCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace CollisionCount

namespace OverrunCount {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace OverrunCount

namespace CarrierDetect {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, writable,
                                       ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace CarrierDetect

namespace TimeSinceReset {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthernetNetworkDiagnostics::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace TimeSinceReset

} // namespace Attributes
} // namespace EthernetNetworkDiagnostics

namespace BridgedDeviceBasic {
namespace Attributes {

namespace VendorName {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace VendorName

namespace VendorID {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace VendorID

namespace ProductName {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace ProductName

namespace NodeLabel {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace NodeLabel

namespace HardwareVersion {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace HardwareVersion

namespace HardwareVersionString {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[64 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 64, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 64);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(64 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 64, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[64 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace HardwareVersionString

namespace SoftwareVersion {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace SoftwareVersion

namespace SoftwareVersionString {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[64 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 64, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 64);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(64 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 64, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[64 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace SoftwareVersionString

namespace ManufacturingDate {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace ManufacturingDate

namespace PartNumber {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace PartNumber

namespace ProductURL {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[256 + 2];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfLongStringLength(zclString);
    if (length == NumericAttributeTraits<uint16_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 256, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[2], 256);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(256 < NumericAttributeTraits<uint16_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 256, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[256 + 2];
    emberAfCopyInt16u(zclString, 0, static_cast<uint16_t>(value.size()));
    memcpy(&zclString[2], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString,
                                       ZCL_LONG_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace ProductURL

namespace ProductLabel {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[64 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 64, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 64);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(64 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 64, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[64 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace ProductLabel

namespace SerialNumber {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace SerialNumber

namespace Reachable {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace Reachable

namespace UniqueID {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BridgedDeviceBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace UniqueID

} // namespace Attributes
} // namespace BridgedDeviceBasic

namespace Switch {
namespace Attributes {

namespace NumberOfPositions {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Switch::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Switch::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace NumberOfPositions

namespace CurrentPosition {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Switch::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Switch::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace CurrentPosition

namespace MultiPressMax {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Switch::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Switch::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace MultiPressMax

} // namespace Attributes
} // namespace Switch

namespace OperationalCredentials {
namespace Attributes {

namespace SupportedFabrics {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OperationalCredentials::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OperationalCredentials::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace SupportedFabrics

namespace CommissionedFabrics {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OperationalCredentials::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OperationalCredentials::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace CommissionedFabrics

namespace CurrentFabricIndex {

EmberAfStatus Get(chip::EndpointId endpoint, chip::FabricIndex * value)
{
    NumericAttributeTraits<chip::FabricIndex>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<chip::FabricIndex>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OperationalCredentials::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<chip::FabricIndex>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<chip::FabricIndex>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::FabricIndex value)
{
    if (!NumericAttributeTraits<chip::FabricIndex>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<chip::FabricIndex>::StorageType storageValue;
    NumericAttributeTraits<chip::FabricIndex>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<chip::FabricIndex>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OperationalCredentials::Id, Id, writable, ZCL_FABRIC_IDX_ATTRIBUTE_TYPE);
}

} // namespace CurrentFabricIndex

} // namespace Attributes
} // namespace OperationalCredentials

namespace GroupKeyManagement {
namespace Attributes {

} // namespace Attributes
} // namespace GroupKeyManagement

namespace FixedLabel {
namespace Attributes {

} // namespace Attributes
} // namespace FixedLabel

namespace UserLabel {
namespace Attributes {

} // namespace Attributes
} // namespace UserLabel

namespace BooleanState {
namespace Attributes {

namespace StateValue {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BooleanState::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BooleanState::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace StateValue

} // namespace Attributes
} // namespace BooleanState

namespace ModeSelect {
namespace Attributes {

namespace CurrentMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ModeSelect::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ModeSelect::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace CurrentMode

namespace OnMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ModeSelect::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ModeSelect::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace OnMode

namespace StartUpMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ModeSelect::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ModeSelect::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace StartUpMode

namespace Description {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ModeSelect::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::ModeSelect::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace Description

} // namespace Attributes
} // namespace ModeSelect

namespace ShadeConfiguration {
namespace Attributes {

namespace PhysicalClosedLimit {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ShadeConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ShadeConfiguration::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace PhysicalClosedLimit

namespace MotorStepSize {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ShadeConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ShadeConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace MotorStepSize

namespace Status {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ShadeConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ShadeConfiguration::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace Status

namespace ClosedLimit {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ShadeConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ShadeConfiguration::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ClosedLimit

namespace Mode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ShadeConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ShadeConfiguration::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace Mode

} // namespace Attributes
} // namespace ShadeConfiguration

namespace DoorLock {
namespace Attributes {

namespace LockState {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint8_t> & value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint8_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint8_t>::StorageType value;
    NumericAttributeTraits<uint8_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint8_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace LockState

namespace LockType {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace LockType

namespace ActuatorEnabled {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace ActuatorEnabled

namespace DoorState {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint8_t> & value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint8_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint8_t>::StorageType value;
    NumericAttributeTraits<uint8_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint8_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace DoorState

namespace DoorOpenEvents {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace DoorOpenEvents

namespace DoorClosedEvents {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace DoorClosedEvents

namespace OpenPeriod {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace OpenPeriod

namespace NumberOfLogRecordsSupported {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace NumberOfLogRecordsSupported

namespace NumberOfTotalUsersSupported {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace NumberOfTotalUsersSupported

namespace NumberOfPINUsersSupported {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace NumberOfPINUsersSupported

namespace NumberOfRFIDUsersSupported {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace NumberOfRFIDUsersSupported

namespace NumberOfWeekDaySchedulesSupportedPerUser {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace NumberOfWeekDaySchedulesSupportedPerUser

namespace NumberOfYearDaySchedulesSupportedPerUser {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace NumberOfYearDaySchedulesSupportedPerUser

namespace NumberOfHolidaySchedulesSupported {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace NumberOfHolidaySchedulesSupported

namespace MaxPINCodeLength {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace MaxPINCodeLength

namespace MinPINCodeLength {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace MinPINCodeLength

namespace MaxRFIDCodeLength {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace MaxRFIDCodeLength

namespace MinRFIDCodeLength {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace MinRFIDCodeLength

namespace CredentialRulesSupport {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace CredentialRulesSupport

namespace EnableLogging {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace EnableLogging

namespace Language {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[3 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 3, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 3);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(3 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 3, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[3 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace Language

namespace LEDSettings {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace LEDSettings

namespace AutoRelockTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace AutoRelockTime

namespace SoundVolume {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace SoundVolume

namespace OperatingMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace OperatingMode

namespace SupportedOperatingModes {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace SupportedOperatingModes

namespace DefaultConfigurationRegister {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace DefaultConfigurationRegister

namespace EnableLocalProgramming {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace EnableLocalProgramming

namespace EnableOneTouchLocking {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace EnableOneTouchLocking

namespace EnableInsideStatusLED {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace EnableInsideStatusLED

namespace EnablePrivacyModeButton {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace EnablePrivacyModeButton

namespace LocalProgrammingFeatures {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace LocalProgrammingFeatures

namespace WrongCodeEntryLimit {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace WrongCodeEntryLimit

namespace UserCodeTemporaryDisableTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace UserCodeTemporaryDisableTime

namespace SendPINOverTheAir {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace SendPINOverTheAir

namespace RequirePINforRemoteOperation {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace RequirePINforRemoteOperation

namespace ExpiringUserTimeout {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ExpiringUserTimeout

namespace AlarmMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace AlarmMask

namespace KeypadOperationEventMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace KeypadOperationEventMask

namespace RemoteOperationEventMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace RemoteOperationEventMask

namespace ManualOperationEventMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace ManualOperationEventMask

namespace RFIDOperationEventMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace RFIDOperationEventMask

namespace KeypadProgrammingEventMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace KeypadProgrammingEventMask

namespace RemoteProgrammingEventMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace RemoteProgrammingEventMask

namespace RFIDProgrammingEventMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DoorLock::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DoorLock::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace RFIDProgrammingEventMask

} // namespace Attributes
} // namespace DoorLock

namespace WindowCovering {
namespace Attributes {

namespace Type {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace Type

namespace PhysicalClosedLimitLift {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace PhysicalClosedLimitLift

namespace PhysicalClosedLimitTilt {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace PhysicalClosedLimitTilt

namespace CurrentPositionLift {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace CurrentPositionLift

namespace CurrentPositionTilt {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace CurrentPositionTilt

namespace NumberOfActuationsLift {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace NumberOfActuationsLift

namespace NumberOfActuationsTilt {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace NumberOfActuationsTilt

namespace ConfigStatus {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace ConfigStatus

namespace CurrentPositionLiftPercentage {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace CurrentPositionLiftPercentage

namespace CurrentPositionTiltPercentage {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace CurrentPositionTiltPercentage

namespace OperationalStatus {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace OperationalStatus

namespace TargetPositionLiftPercent100ths {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace TargetPositionLiftPercent100ths

namespace TargetPositionTiltPercent100ths {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace TargetPositionTiltPercent100ths

namespace EndProductType {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace EndProductType

namespace CurrentPositionLiftPercent100ths {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace CurrentPositionLiftPercent100ths

namespace CurrentPositionTiltPercent100ths {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace CurrentPositionTiltPercent100ths

namespace InstalledOpenLimitLift {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace InstalledOpenLimitLift

namespace InstalledClosedLimitLift {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace InstalledClosedLimitLift

namespace InstalledOpenLimitTilt {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace InstalledOpenLimitTilt

namespace InstalledClosedLimitTilt {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace InstalledClosedLimitTilt

namespace VelocityLift {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace VelocityLift

namespace AccelerationTimeLift {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AccelerationTimeLift

namespace DecelerationTimeLift {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace DecelerationTimeLift

namespace Mode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace Mode

namespace IntermediateSetpointsLift {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[254 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 254, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 254);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(254 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 254, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[254 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, zclString, ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace IntermediateSetpointsLift

namespace IntermediateSetpointsTilt {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[254 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 254, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 254);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(254 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 254, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[254 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, zclString, ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace IntermediateSetpointsTilt

namespace SafetyStatus {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::WindowCovering::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace SafetyStatus

} // namespace Attributes
} // namespace WindowCovering

namespace BarrierControl {
namespace Attributes {

namespace BarrierMovingState {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace BarrierMovingState

namespace BarrierSafetyStatus {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace BarrierSafetyStatus

namespace BarrierCapabilities {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace BarrierCapabilities

namespace BarrierOpenEvents {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace BarrierOpenEvents

namespace BarrierCloseEvents {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace BarrierCloseEvents

namespace BarrierCommandOpenEvents {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace BarrierCommandOpenEvents

namespace BarrierCommandCloseEvents {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace BarrierCommandCloseEvents

namespace BarrierOpenPeriod {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace BarrierOpenPeriod

namespace BarrierClosePeriod {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace BarrierClosePeriod

namespace BarrierPosition {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BarrierControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BarrierPosition

} // namespace Attributes
} // namespace BarrierControl

namespace PumpConfigurationAndControl {
namespace Attributes {

namespace MaxPressure {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MaxPressure

namespace MaxSpeed {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MaxSpeed

namespace MaxFlow {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MaxFlow

namespace MinConstPressure {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MinConstPressure

namespace MaxConstPressure {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MaxConstPressure

namespace MinCompPressure {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MinCompPressure

namespace MaxCompPressure {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MaxCompPressure

namespace MinConstSpeed {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MinConstSpeed

namespace MaxConstSpeed {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MaxConstSpeed

namespace MinConstFlow {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MinConstFlow

namespace MaxConstFlow {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MaxConstFlow

namespace MinConstTemp {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MinConstTemp

namespace MaxConstTemp {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MaxConstTemp

namespace PumpStatus {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace PumpStatus

namespace EffectiveOperationMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace EffectiveOperationMode

namespace EffectiveControlMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace EffectiveControlMode

namespace Capacity {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace Capacity

namespace Speed {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Speed

namespace LifetimeRunningHours {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint32_t> & value)
{
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<OddSizedInteger<3, false>>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<OddSizedInteger<3, false>>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<3, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT24U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType value;
    NumericAttributeTraits<OddSizedInteger<3, false>>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT24U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint32_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace LifetimeRunningHours

namespace Power {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<3, false>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<3, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT24U_ATTRIBUTE_TYPE);
}

} // namespace Power

namespace LifetimeEnergyConsumed {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint32_t> & value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint32_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT32U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint32_t>::StorageType value;
    NumericAttributeTraits<uint32_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_INT32U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint32_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace LifetimeEnergyConsumed

namespace OperationMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace OperationMode

namespace ControlMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace ControlMode

namespace AlarmMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PumpConfigurationAndControl::Id, Id, writable,
                                       ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace AlarmMask

} // namespace Attributes
} // namespace PumpConfigurationAndControl

namespace Thermostat {
namespace Attributes {

namespace LocalTemperature {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace LocalTemperature

namespace OutdoorTemperature {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace OutdoorTemperature

namespace Occupancy {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace Occupancy

namespace AbsMinHeatSetpointLimit {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace AbsMinHeatSetpointLimit

namespace AbsMaxHeatSetpointLimit {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace AbsMaxHeatSetpointLimit

namespace AbsMinCoolSetpointLimit {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace AbsMinCoolSetpointLimit

namespace AbsMaxCoolSetpointLimit {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace AbsMaxCoolSetpointLimit

namespace PiCoolingDemand {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace PiCoolingDemand

namespace PiHeatingDemand {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace PiHeatingDemand

namespace HvacSystemTypeConfiguration {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace HvacSystemTypeConfiguration

namespace LocalTemperatureCalibration {

EmberAfStatus Get(chip::EndpointId endpoint, int8_t * value)
{
    NumericAttributeTraits<int8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int8_t value)
{
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int8_t>::StorageType storageValue;
    NumericAttributeTraits<int8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT8S_ATTRIBUTE_TYPE);
}

} // namespace LocalTemperatureCalibration

namespace OccupiedCoolingSetpoint {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace OccupiedCoolingSetpoint

namespace OccupiedHeatingSetpoint {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace OccupiedHeatingSetpoint

namespace UnoccupiedCoolingSetpoint {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace UnoccupiedCoolingSetpoint

namespace UnoccupiedHeatingSetpoint {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace UnoccupiedHeatingSetpoint

namespace MinHeatSetpointLimit {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MinHeatSetpointLimit

namespace MaxHeatSetpointLimit {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MaxHeatSetpointLimit

namespace MinCoolSetpointLimit {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MinCoolSetpointLimit

namespace MaxCoolSetpointLimit {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MaxCoolSetpointLimit

namespace MinSetpointDeadBand {

EmberAfStatus Get(chip::EndpointId endpoint, int8_t * value)
{
    NumericAttributeTraits<int8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int8_t value)
{
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int8_t>::StorageType storageValue;
    NumericAttributeTraits<int8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT8S_ATTRIBUTE_TYPE);
}

} // namespace MinSetpointDeadBand

namespace RemoteSensing {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace RemoteSensing

namespace ControlSequenceOfOperation {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace ControlSequenceOfOperation

namespace SystemMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace SystemMode

namespace AlarmMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace AlarmMask

namespace ThermostatRunningMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace ThermostatRunningMode

namespace StartOfWeek {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace StartOfWeek

namespace NumberOfWeeklyTransitions {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace NumberOfWeeklyTransitions

namespace NumberOfDailyTransitions {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace NumberOfDailyTransitions

namespace TemperatureSetpointHold {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace TemperatureSetpointHold

namespace TemperatureSetpointHoldDuration {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace TemperatureSetpointHoldDuration

namespace ThermostatProgrammingOperationMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace ThermostatProgrammingOperationMode

namespace HvacRelayState {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace HvacRelayState

namespace SetpointChangeSource {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace SetpointChangeSource

namespace SetpointChangeAmount {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace SetpointChangeAmount

namespace SetpointChangeSourceTimestamp {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_EPOCH_S_ATTRIBUTE_TYPE);
}

} // namespace SetpointChangeSourceTimestamp

namespace AcType {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace AcType

namespace AcCapacity {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AcCapacity

namespace AcRefrigerantType {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace AcRefrigerantType

namespace AcCompressor {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace AcCompressor

namespace AcErrorCode {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_BITMAP32_ATTRIBUTE_TYPE);
}

} // namespace AcErrorCode

namespace AcLouverPosition {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace AcLouverPosition

namespace AcCoilTemperature {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace AcCoilTemperature

namespace AcCapacityFormat {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::Thermostat::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::Thermostat::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace AcCapacityFormat

} // namespace Attributes
} // namespace Thermostat

namespace FanControl {
namespace Attributes {

namespace FanMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::FanControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::FanControl::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace FanMode

namespace FanModeSequence {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::FanControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::FanControl::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace FanModeSequence

} // namespace Attributes
} // namespace FanControl

namespace DehumidificationControl {
namespace Attributes {

namespace RelativeHumidity {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace RelativeHumidity

namespace DehumidificationCooling {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace DehumidificationCooling

namespace RhDehumidificationSetpoint {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace RhDehumidificationSetpoint

namespace RelativeHumidityMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace RelativeHumidityMode

namespace DehumidificationLockout {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace DehumidificationLockout

namespace DehumidificationHysteresis {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace DehumidificationHysteresis

namespace DehumidificationMaxCool {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace DehumidificationMaxCool

namespace RelativeHumidityDisplay {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DehumidificationControl::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace RelativeHumidityDisplay

} // namespace Attributes
} // namespace DehumidificationControl

namespace ThermostatUserInterfaceConfiguration {
namespace Attributes {

namespace TemperatureDisplayMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ThermostatUserInterfaceConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThermostatUserInterfaceConfiguration::Id, Id, writable,
                                       ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace TemperatureDisplayMode

namespace KeypadLockout {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ThermostatUserInterfaceConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThermostatUserInterfaceConfiguration::Id, Id, writable,
                                       ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace KeypadLockout

namespace ScheduleProgrammingVisibility {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ThermostatUserInterfaceConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ThermostatUserInterfaceConfiguration::Id, Id, writable,
                                       ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace ScheduleProgrammingVisibility

} // namespace Attributes
} // namespace ThermostatUserInterfaceConfiguration

namespace ColorControl {
namespace Attributes {

namespace CurrentHue {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace CurrentHue

namespace CurrentSaturation {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace CurrentSaturation

namespace RemainingTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RemainingTime

namespace CurrentX {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace CurrentX

namespace CurrentY {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace CurrentY

namespace DriftCompensation {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace DriftCompensation

namespace CompensationText {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[254 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 254, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 254);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(254 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 254, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[254 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace CompensationText

namespace ColorTemperature {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ColorTemperature

namespace ColorMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace ColorMode

namespace ColorControlOptions {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace ColorControlOptions

namespace NumberOfPrimaries {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace NumberOfPrimaries

namespace Primary1X {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Primary1X

namespace Primary1Y {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Primary1Y

namespace Primary1Intensity {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Primary1Intensity

namespace Primary2X {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Primary2X

namespace Primary2Y {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Primary2Y

namespace Primary2Intensity {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Primary2Intensity

namespace Primary3X {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Primary3X

namespace Primary3Y {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Primary3Y

namespace Primary3Intensity {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Primary3Intensity

namespace Primary4X {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Primary4X

namespace Primary4Y {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Primary4Y

namespace Primary4Intensity {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Primary4Intensity

namespace Primary5X {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Primary5X

namespace Primary5Y {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Primary5Y

namespace Primary5Intensity {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Primary5Intensity

namespace Primary6X {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Primary6X

namespace Primary6Y {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Primary6Y

namespace Primary6Intensity {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Primary6Intensity

namespace WhitePointX {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace WhitePointX

namespace WhitePointY {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace WhitePointY

namespace ColorPointRX {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ColorPointRX

namespace ColorPointRY {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ColorPointRY

namespace ColorPointRIntensity {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace ColorPointRIntensity

namespace ColorPointGX {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ColorPointGX

namespace ColorPointGY {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ColorPointGY

namespace ColorPointGIntensity {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace ColorPointGIntensity

namespace ColorPointBX {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ColorPointBX

namespace ColorPointBY {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ColorPointBY

namespace ColorPointBIntensity {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace ColorPointBIntensity

namespace EnhancedCurrentHue {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace EnhancedCurrentHue

namespace EnhancedColorMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace EnhancedColorMode

namespace ColorLoopActive {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace ColorLoopActive

namespace ColorLoopDirection {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace ColorLoopDirection

namespace ColorLoopTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ColorLoopTime

namespace ColorLoopStartEnhancedHue {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ColorLoopStartEnhancedHue

namespace ColorLoopStoredEnhancedHue {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ColorLoopStoredEnhancedHue

namespace ColorCapabilities {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace ColorCapabilities

namespace ColorTempPhysicalMin {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ColorTempPhysicalMin

namespace ColorTempPhysicalMax {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ColorTempPhysicalMax

namespace CoupleColorTempToLevelMinMireds {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace CoupleColorTempToLevelMinMireds

namespace StartUpColorTemperatureMireds {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ColorControl::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ColorControl::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace StartUpColorTemperatureMireds

} // namespace Attributes
} // namespace ColorControl

namespace BallastConfiguration {
namespace Attributes {

namespace PhysicalMinLevel {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace PhysicalMinLevel

namespace PhysicalMaxLevel {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace PhysicalMaxLevel

namespace BallastStatus {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace BallastStatus

namespace MinLevel {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace MinLevel

namespace MaxLevel {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace MaxLevel

namespace PowerOnLevel {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace PowerOnLevel

namespace PowerOnFadeTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace PowerOnFadeTime

namespace IntrinsicBallastFactor {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace IntrinsicBallastFactor

namespace BallastFactorAdjustment {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace BallastFactorAdjustment

namespace LampQuality {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace LampQuality

namespace LampType {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace LampType

namespace LampManufacturer {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace LampManufacturer

namespace LampRatedHours {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<3, false>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<3, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, writable, ZCL_INT24U_ATTRIBUTE_TYPE);
}

} // namespace LampRatedHours

namespace LampBurnHours {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<3, false>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<3, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, writable, ZCL_INT24U_ATTRIBUTE_TYPE);
}

} // namespace LampBurnHours

namespace LampAlarmMode {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace LampAlarmMode

namespace LampBurnHoursTripPoint {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<3, false>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<3, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BallastConfiguration::Id, Id, writable, ZCL_INT24U_ATTRIBUTE_TYPE);
}

} // namespace LampBurnHoursTripPoint

} // namespace Attributes
} // namespace BallastConfiguration

namespace IlluminanceMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint16_t> & value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::IlluminanceMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint16_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::IlluminanceMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint16_t>::StorageType value;
    NumericAttributeTraits<uint16_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::IlluminanceMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint16_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint16_t> & value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::IlluminanceMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint16_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::IlluminanceMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint16_t>::StorageType value;
    NumericAttributeTraits<uint16_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::IlluminanceMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint16_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint16_t> & value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::IlluminanceMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint16_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::IlluminanceMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint16_t>::StorageType value;
    NumericAttributeTraits<uint16_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::IlluminanceMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint16_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::IlluminanceMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::IlluminanceMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

namespace LightSensorType {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint8_t> & value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::IlluminanceMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint8_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::IlluminanceMeasurement::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint8_t>::StorageType value;
    NumericAttributeTraits<uint8_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::IlluminanceMeasurement::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint8_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace LightSensorType

} // namespace Attributes
} // namespace IlluminanceMeasurement

namespace TemperatureMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TemperatureMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TemperatureMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TemperatureMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TemperatureMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TemperatureMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TemperatureMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TemperatureMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TemperatureMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace TemperatureMeasurement

namespace PressureMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

namespace ScaledValue {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ScaledValue

namespace MinScaledValue {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MinScaledValue

namespace MaxScaledValue {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MaxScaledValue

namespace ScaledTolerance {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ScaledTolerance

namespace Scale {

EmberAfStatus Get(chip::EndpointId endpoint, int8_t * value)
{
    NumericAttributeTraits<int8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int8_t value)
{
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int8_t>::StorageType storageValue;
    NumericAttributeTraits<int8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::PressureMeasurement::Id, Id, writable, ZCL_INT8S_ATTRIBUTE_TYPE);
}

} // namespace Scale

} // namespace Attributes
} // namespace PressureMeasurement

namespace FlowMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::FlowMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::FlowMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::FlowMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::FlowMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::FlowMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::FlowMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::FlowMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::FlowMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace FlowMeasurement

namespace RelativeHumidityMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::RelativeHumidityMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::RelativeHumidityMeasurement::Id, Id, writable,
                                       ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::RelativeHumidityMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::RelativeHumidityMeasurement::Id, Id, writable,
                                       ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::RelativeHumidityMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::RelativeHumidityMeasurement::Id, Id, writable,
                                       ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::RelativeHumidityMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::RelativeHumidityMeasurement::Id, Id, writable,
                                       ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace RelativeHumidityMeasurement

namespace OccupancySensing {
namespace Attributes {

namespace Occupancy {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace Occupancy

namespace OccupancySensorType {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace OccupancySensorType

namespace OccupancySensorTypeBitmap {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace OccupancySensorTypeBitmap

namespace PirOccupiedToUnoccupiedDelay {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace PirOccupiedToUnoccupiedDelay

namespace PirUnoccupiedToOccupiedDelay {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace PirUnoccupiedToOccupiedDelay

namespace PirUnoccupiedToOccupiedThreshold {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace PirUnoccupiedToOccupiedThreshold

namespace UltrasonicOccupiedToUnoccupiedDelay {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace UltrasonicOccupiedToUnoccupiedDelay

namespace UltrasonicUnoccupiedToOccupiedDelay {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace UltrasonicUnoccupiedToOccupiedDelay

namespace UltrasonicUnoccupiedToOccupiedThreshold {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace UltrasonicUnoccupiedToOccupiedThreshold

namespace PhysicalContactOccupiedToUnoccupiedDelay {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace PhysicalContactOccupiedToUnoccupiedDelay

namespace PhysicalContactUnoccupiedToOccupiedDelay {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace PhysicalContactUnoccupiedToOccupiedDelay

namespace PhysicalContactUnoccupiedToOccupiedThreshold {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OccupancySensing::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace PhysicalContactUnoccupiedToOccupiedThreshold

} // namespace Attributes
} // namespace OccupancySensing

namespace CarbonMonoxideConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::CarbonMonoxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::CarbonMonoxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::CarbonMonoxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::CarbonMonoxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::CarbonMonoxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::CarbonMonoxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::CarbonMonoxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::CarbonMonoxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace CarbonMonoxideConcentrationMeasurement

namespace CarbonDioxideConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::CarbonDioxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::CarbonDioxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::CarbonDioxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::CarbonDioxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::CarbonDioxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::CarbonDioxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::CarbonDioxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::CarbonDioxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace CarbonDioxideConcentrationMeasurement

namespace EthyleneConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthyleneConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthyleneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthyleneConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthyleneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthyleneConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthyleneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthyleneConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthyleneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace EthyleneConcentrationMeasurement

namespace EthyleneOxideConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthyleneOxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthyleneOxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthyleneOxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthyleneOxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthyleneOxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthyleneOxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::EthyleneOxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::EthyleneOxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace EthyleneOxideConcentrationMeasurement

namespace HydrogenConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::HydrogenConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::HydrogenConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::HydrogenConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::HydrogenConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::HydrogenConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::HydrogenConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::HydrogenConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::HydrogenConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace HydrogenConcentrationMeasurement

namespace HydrogenSulphideConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::HydrogenSulphideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::HydrogenSulphideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::HydrogenSulphideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::HydrogenSulphideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::HydrogenSulphideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::HydrogenSulphideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::HydrogenSulphideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::HydrogenSulphideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace HydrogenSulphideConcentrationMeasurement

namespace NitricOxideConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::NitricOxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::NitricOxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::NitricOxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::NitricOxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::NitricOxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::NitricOxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::NitricOxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::NitricOxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace NitricOxideConcentrationMeasurement

namespace NitrogenDioxideConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::NitrogenDioxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::NitrogenDioxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::NitrogenDioxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::NitrogenDioxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::NitrogenDioxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::NitrogenDioxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::NitrogenDioxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::NitrogenDioxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace NitrogenDioxideConcentrationMeasurement

namespace OxygenConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::OxygenConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OxygenConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::OxygenConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OxygenConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::OxygenConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OxygenConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::OxygenConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OxygenConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace OxygenConcentrationMeasurement

namespace OzoneConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::OzoneConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OzoneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::OzoneConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OzoneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::OzoneConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OzoneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::OzoneConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::OzoneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace OzoneConcentrationMeasurement

namespace SulfurDioxideConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::SulfurDioxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::SulfurDioxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::SulfurDioxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::SulfurDioxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::SulfurDioxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::SulfurDioxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::SulfurDioxideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::SulfurDioxideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace SulfurDioxideConcentrationMeasurement

namespace DissolvedOxygenConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::DissolvedOxygenConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DissolvedOxygenConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::DissolvedOxygenConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DissolvedOxygenConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::DissolvedOxygenConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DissolvedOxygenConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::DissolvedOxygenConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::DissolvedOxygenConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace DissolvedOxygenConcentrationMeasurement

namespace BromateConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::BromateConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BromateConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::BromateConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BromateConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::BromateConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BromateConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::BromateConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BromateConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace BromateConcentrationMeasurement

namespace ChloraminesConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ChloraminesConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChloraminesConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ChloraminesConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChloraminesConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ChloraminesConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChloraminesConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ChloraminesConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChloraminesConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace ChloraminesConcentrationMeasurement

namespace ChlorineConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ChlorineConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChlorineConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ChlorineConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChlorineConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ChlorineConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChlorineConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ChlorineConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChlorineConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace ChlorineConcentrationMeasurement

namespace FecalColiformAndEColiConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::FecalColiformAndEColiConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::FecalColiformAndEColiConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::FecalColiformAndEColiConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::FecalColiformAndEColiConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::FecalColiformAndEColiConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::FecalColiformAndEColiConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::FecalColiformAndEColiConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::FecalColiformAndEColiConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace FecalColiformAndEColiConcentrationMeasurement

namespace FluorideConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::FluorideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::FluorideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::FluorideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::FluorideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::FluorideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::FluorideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::FluorideConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::FluorideConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace FluorideConcentrationMeasurement

namespace HaloaceticAcidsConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::HaloaceticAcidsConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::HaloaceticAcidsConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::HaloaceticAcidsConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::HaloaceticAcidsConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::HaloaceticAcidsConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::HaloaceticAcidsConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::HaloaceticAcidsConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::HaloaceticAcidsConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace HaloaceticAcidsConcentrationMeasurement

namespace TotalTrihalomethanesConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TotalTrihalomethanesConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TotalTrihalomethanesConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TotalTrihalomethanesConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TotalTrihalomethanesConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TotalTrihalomethanesConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TotalTrihalomethanesConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TotalTrihalomethanesConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TotalTrihalomethanesConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace TotalTrihalomethanesConcentrationMeasurement

namespace TotalColiformBacteriaConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TotalColiformBacteriaConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TotalColiformBacteriaConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TotalColiformBacteriaConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TotalColiformBacteriaConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TotalColiformBacteriaConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TotalColiformBacteriaConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TotalColiformBacteriaConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TotalColiformBacteriaConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace TotalColiformBacteriaConcentrationMeasurement

namespace TurbidityConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::TurbidityConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TurbidityConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::TurbidityConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TurbidityConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::TurbidityConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TurbidityConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::TurbidityConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TurbidityConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace TurbidityConcentrationMeasurement

namespace CopperConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::CopperConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::CopperConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::CopperConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::CopperConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::CopperConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::CopperConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::CopperConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::CopperConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace CopperConcentrationMeasurement

namespace LeadConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::LeadConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LeadConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::LeadConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LeadConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::LeadConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LeadConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::LeadConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::LeadConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace LeadConcentrationMeasurement

namespace ManganeseConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ManganeseConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ManganeseConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ManganeseConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ManganeseConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ManganeseConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ManganeseConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ManganeseConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ManganeseConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace ManganeseConcentrationMeasurement

namespace SulfateConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::SulfateConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::SulfateConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::SulfateConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::SulfateConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::SulfateConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::SulfateConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::SulfateConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::SulfateConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace SulfateConcentrationMeasurement

namespace BromodichloromethaneConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BromodichloromethaneConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BromodichloromethaneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BromodichloromethaneConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BromodichloromethaneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BromodichloromethaneConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BromodichloromethaneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::BromodichloromethaneConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BromodichloromethaneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace BromodichloromethaneConcentrationMeasurement

namespace BromoformConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::BromoformConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BromoformConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::BromoformConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BromoformConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::BromoformConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BromoformConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::BromoformConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::BromoformConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace BromoformConcentrationMeasurement

namespace ChlorodibromomethaneConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ChlorodibromomethaneConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChlorodibromomethaneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ChlorodibromomethaneConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChlorodibromomethaneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ChlorodibromomethaneConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChlorodibromomethaneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ChlorodibromomethaneConcentrationMeasurement::Id, Id,
                                                      readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChlorodibromomethaneConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace ChlorodibromomethaneConcentrationMeasurement

namespace ChloroformConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ChloroformConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChloroformConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ChloroformConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChloroformConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ChloroformConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChloroformConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ChloroformConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ChloroformConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace ChloroformConcentrationMeasurement

namespace SodiumConcentrationMeasurement {
namespace Attributes {

namespace MeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::SodiumConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::SodiumConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MeasuredValue

namespace MinMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::SodiumConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::SodiumConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MinMeasuredValue

namespace MaxMeasuredValue {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::SodiumConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::SodiumConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace MaxMeasuredValue

namespace Tolerance {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::SodiumConcentrationMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::SodiumConcentrationMeasurement::Id, Id, writable,
                                       ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace Tolerance

} // namespace Attributes
} // namespace SodiumConcentrationMeasurement

namespace IasZone {
namespace Attributes {

namespace ZoneState {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::IasZone::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::IasZone::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace ZoneState

namespace ZoneType {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::IasZone::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::IasZone::Id, Id, writable, ZCL_ENUM16_ATTRIBUTE_TYPE);
}

} // namespace ZoneType

namespace ZoneStatus {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::IasZone::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::IasZone::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace ZoneStatus

namespace IasCieAddress {

EmberAfStatus Get(chip::EndpointId endpoint, chip::NodeId * value)
{
    NumericAttributeTraits<chip::NodeId>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<chip::NodeId>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::IasZone::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<chip::NodeId>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<chip::NodeId>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::NodeId value)
{
    if (!NumericAttributeTraits<chip::NodeId>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<chip::NodeId>::StorageType storageValue;
    NumericAttributeTraits<chip::NodeId>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<chip::NodeId>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::IasZone::Id, Id, writable, ZCL_NODE_ID_ATTRIBUTE_TYPE);
}

} // namespace IasCieAddress

namespace ZoneId {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::IasZone::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::IasZone::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace ZoneId

namespace NumberOfZoneSensitivityLevelsSupported {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::IasZone::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::IasZone::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace NumberOfZoneSensitivityLevelsSupported

namespace CurrentZoneSensitivityLevel {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::IasZone::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::IasZone::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace CurrentZoneSensitivityLevel

} // namespace Attributes
} // namespace IasZone

namespace IasWd {
namespace Attributes {

namespace MaxDuration {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::IasWd::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::IasWd::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MaxDuration

} // namespace Attributes
} // namespace IasWd

namespace WakeOnLan {
namespace Attributes {

namespace WakeOnLanMacAddress {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::WakeOnLan::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::WakeOnLan::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace WakeOnLanMacAddress

} // namespace Attributes
} // namespace WakeOnLan

namespace TvChannel {
namespace Attributes {

namespace TvChannelLineup {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TvChannel::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::TvChannel::Id, Id, zclString, ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace TvChannelLineup

namespace CurrentTvChannel {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TvChannel::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::TvChannel::Id, Id, zclString, ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace CurrentTvChannel

} // namespace Attributes
} // namespace TvChannel

namespace TargetNavigator {
namespace Attributes {

namespace CurrentNavigatorTarget {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TargetNavigator::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TargetNavigator::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace CurrentNavigatorTarget

} // namespace Attributes
} // namespace TargetNavigator

namespace MediaPlayback {
namespace Attributes {

namespace PlaybackState {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace PlaybackState

namespace StartTime {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace StartTime

namespace Duration {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace Duration

namespace PositionUpdatedAt {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace PositionUpdatedAt

namespace Position {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace Position

namespace PlaybackSpeed {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace PlaybackSpeed

namespace SeekRangeEnd {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace SeekRangeEnd

namespace SeekRangeStart {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::MediaPlayback::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace SeekRangeStart

} // namespace Attributes
} // namespace MediaPlayback

namespace MediaInput {
namespace Attributes {

namespace CurrentMediaInput {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::MediaInput::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::MediaInput::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace CurrentMediaInput

} // namespace Attributes
} // namespace MediaInput

namespace ContentLauncher {
namespace Attributes {

} // namespace Attributes
} // namespace ContentLauncher

namespace AudioOutput {
namespace Attributes {

namespace CurrentAudioOutput {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::AudioOutput::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::AudioOutput::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace CurrentAudioOutput

} // namespace Attributes
} // namespace AudioOutput

namespace ApplicationLauncher {
namespace Attributes {

namespace CatalogVendorId {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplicationLauncher::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplicationLauncher::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace CatalogVendorId

namespace ApplicationId {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplicationLauncher::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplicationLauncher::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace ApplicationId

} // namespace Attributes
} // namespace ApplicationLauncher

namespace ApplicationBasic {
namespace Attributes {

namespace VendorName {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplicationBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplicationBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace VendorName

namespace VendorId {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplicationBasic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplicationBasic::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace VendorId

namespace ApplicationName {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplicationBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplicationBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace ApplicationName

namespace ProductId {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplicationBasic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplicationBasic::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ProductId

namespace ApplicationId {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[32 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplicationBasic::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 32, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 32);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(32 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 32, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[32 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplicationBasic::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace ApplicationId

namespace CatalogVendorId {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplicationBasic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplicationBasic::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace CatalogVendorId

namespace ApplicationStatus {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplicationBasic::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplicationBasic::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace ApplicationStatus

} // namespace Attributes
} // namespace ApplicationBasic

namespace TestCluster {
namespace Attributes {

namespace Boolean {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace Boolean

namespace Bitmap8 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace Bitmap8

namespace Bitmap16 {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace Bitmap16

namespace Bitmap32 {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BITMAP32_ATTRIBUTE_TYPE);
}

} // namespace Bitmap32

namespace Bitmap64 {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BITMAP64_ATTRIBUTE_TYPE);
}

} // namespace Bitmap64

namespace Int8u {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace Int8u

namespace Int16u {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace Int16u

namespace Int24u {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<3, false>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<3, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT24U_ATTRIBUTE_TYPE);
}

} // namespace Int24u

namespace Int32u {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace Int32u

namespace Int40u {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<OddSizedInteger<5, false>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<5, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<5, false>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<5, false>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<5, false>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<5, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<5, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<5, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT40U_ATTRIBUTE_TYPE);
}

} // namespace Int40u

namespace Int48u {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<OddSizedInteger<6, false>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<6, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<6, false>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<6, false>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<6, false>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<6, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<6, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<6, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT48U_ATTRIBUTE_TYPE);
}

} // namespace Int48u

namespace Int56u {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<OddSizedInteger<7, false>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<7, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<7, false>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<7, false>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<7, false>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<7, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<7, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<7, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT56U_ATTRIBUTE_TYPE);
}

} // namespace Int56u

namespace Int64u {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

} // namespace Int64u

namespace Int8s {

EmberAfStatus Get(chip::EndpointId endpoint, int8_t * value)
{
    NumericAttributeTraits<int8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int8_t value)
{
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int8_t>::StorageType storageValue;
    NumericAttributeTraits<int8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT8S_ATTRIBUTE_TYPE);
}

} // namespace Int8s

namespace Int16s {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace Int16s

namespace Int24s {

EmberAfStatus Get(chip::EndpointId endpoint, int32_t * value)
{
    NumericAttributeTraits<OddSizedInteger<3, true>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<3, true>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<3, true>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<3, true>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int32_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<3, true>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<3, true>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<3, true>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, true>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT24S_ATTRIBUTE_TYPE);
}

} // namespace Int24s

namespace Int32s {

EmberAfStatus Get(chip::EndpointId endpoint, int32_t * value)
{
    NumericAttributeTraits<int32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int32_t value)
{
    if (!NumericAttributeTraits<int32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int32_t>::StorageType storageValue;
    NumericAttributeTraits<int32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT32S_ATTRIBUTE_TYPE);
}

} // namespace Int32s

namespace Int40s {

EmberAfStatus Get(chip::EndpointId endpoint, int64_t * value)
{
    NumericAttributeTraits<OddSizedInteger<5, true>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<5, true>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<5, true>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<5, true>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int64_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<5, true>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<5, true>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<5, true>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<5, true>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT40S_ATTRIBUTE_TYPE);
}

} // namespace Int40s

namespace Int48s {

EmberAfStatus Get(chip::EndpointId endpoint, int64_t * value)
{
    NumericAttributeTraits<OddSizedInteger<6, true>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<6, true>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<6, true>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<6, true>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int64_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<6, true>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<6, true>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<6, true>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<6, true>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT48S_ATTRIBUTE_TYPE);
}

} // namespace Int48s

namespace Int56s {

EmberAfStatus Get(chip::EndpointId endpoint, int64_t * value)
{
    NumericAttributeTraits<OddSizedInteger<7, true>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<7, true>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<7, true>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<7, true>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int64_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<7, true>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<7, true>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<7, true>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<7, true>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT56S_ATTRIBUTE_TYPE);
}

} // namespace Int56s

namespace Int64s {

EmberAfStatus Get(chip::EndpointId endpoint, int64_t * value)
{
    NumericAttributeTraits<int64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int64_t value)
{
    if (!NumericAttributeTraits<int64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int64_t>::StorageType storageValue;
    NumericAttributeTraits<int64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT64S_ATTRIBUTE_TYPE);
}

} // namespace Int64s

namespace Enum8 {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace Enum8

namespace Enum16 {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_ENUM16_ATTRIBUTE_TYPE);
}

} // namespace Enum16

namespace FloatSingle {

EmberAfStatus Get(chip::EndpointId endpoint, float * value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<float>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_SINGLE_ATTRIBUTE_TYPE);
}

} // namespace FloatSingle

namespace FloatDouble {

EmberAfStatus Get(chip::EndpointId endpoint, double * value)
{
    NumericAttributeTraits<double>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<double>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<double>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<double>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, double value)
{
    if (!NumericAttributeTraits<double>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<double>::StorageType storageValue;
    NumericAttributeTraits<double>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<double>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_DOUBLE_ATTRIBUTE_TYPE);
}

} // namespace FloatDouble

namespace OctetString {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[10 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 10, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 10);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(10 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 10, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[10 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, zclString, ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace OctetString

namespace LongOctetString {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[1000 + 2];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfLongStringLength(zclString);
    if (length == NumericAttributeTraits<uint16_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 1000, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[2], 1000);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(1000 < NumericAttributeTraits<uint16_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 1000, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[1000 + 2];
    emberAfCopyInt16u(zclString, 0, static_cast<uint16_t>(value.size()));
    memcpy(&zclString[2], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, zclString, ZCL_LONG_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace LongOctetString

namespace CharString {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[10 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 10, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 10);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(10 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 10, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[10 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace CharString

namespace LongCharString {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[1000 + 2];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfLongStringLength(zclString);
    if (length == NumericAttributeTraits<uint16_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 1000, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[2], 1000);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(1000 < NumericAttributeTraits<uint16_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 1000, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[1000 + 2];
    emberAfCopyInt16u(zclString, 0, static_cast<uint16_t>(value.size()));
    memcpy(&zclString[2], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, zclString, ZCL_LONG_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace LongCharString

namespace EpochUs {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_EPOCH_US_ATTRIBUTE_TYPE);
}

} // namespace EpochUs

namespace EpochS {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_EPOCH_S_ATTRIBUTE_TYPE);
}

} // namespace EpochS

namespace VendorId {

EmberAfStatus Get(chip::EndpointId endpoint, chip::VendorId * value)
{
    NumericAttributeTraits<chip::VendorId>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<chip::VendorId>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<chip::VendorId>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<chip::VendorId>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::VendorId value)
{
    if (!NumericAttributeTraits<chip::VendorId>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<chip::VendorId>::StorageType storageValue;
    NumericAttributeTraits<chip::VendorId>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<chip::VendorId>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_VENDOR_ID_ATTRIBUTE_TYPE);
}

} // namespace VendorId

namespace EnumAttr {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

} // namespace EnumAttr

namespace RangeRestrictedInt8u {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace RangeRestrictedInt8u

namespace RangeRestrictedInt8s {

EmberAfStatus Get(chip::EndpointId endpoint, int8_t * value)
{
    NumericAttributeTraits<int8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int8_t value)
{
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int8_t>::StorageType storageValue;
    NumericAttributeTraits<int8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT8S_ATTRIBUTE_TYPE);
}

} // namespace RangeRestrictedInt8s

namespace RangeRestrictedInt16u {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RangeRestrictedInt16u

namespace RangeRestrictedInt16s {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace RangeRestrictedInt16s

namespace TimedWriteBoolean {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace TimedWriteBoolean

namespace Unsupported {

EmberAfStatus Get(chip::EndpointId endpoint, bool * value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<bool>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

} // namespace Unsupported

namespace NullableBoolean {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<bool> & value)
{
    NumericAttributeTraits<bool>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<bool>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<bool>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, bool value)
{
    if (!NumericAttributeTraits<bool>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<bool>::StorageType storageValue;
    NumericAttributeTraits<bool>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<bool>::StorageType value;
    NumericAttributeTraits<bool>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<bool>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BOOLEAN_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<bool> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableBoolean

namespace NullableBitmap8 {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint8_t> & value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint8_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint8_t>::StorageType value;
    NumericAttributeTraits<uint8_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint8_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableBitmap8

namespace NullableBitmap16 {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint16_t> & value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint16_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint16_t>::StorageType value;
    NumericAttributeTraits<uint16_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint16_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableBitmap16

namespace NullableBitmap32 {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint32_t> & value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint32_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BITMAP32_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint32_t>::StorageType value;
    NumericAttributeTraits<uint32_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BITMAP32_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint32_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableBitmap32

namespace NullableBitmap64 {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint64_t> & value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint64_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BITMAP64_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint64_t>::StorageType value;
    NumericAttributeTraits<uint64_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_BITMAP64_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint64_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableBitmap64

namespace NullableInt8u {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint8_t> & value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint8_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint8_t>::StorageType value;
    NumericAttributeTraits<uint8_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint8_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt8u

namespace NullableInt16u {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint16_t> & value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint16_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint16_t>::StorageType value;
    NumericAttributeTraits<uint16_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint16_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt16u

namespace NullableInt24u {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint32_t> & value)
{
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<OddSizedInteger<3, false>>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<OddSizedInteger<3, false>>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<3, false>>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<3, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT24U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<OddSizedInteger<3, false>>::StorageType value;
    NumericAttributeTraits<OddSizedInteger<3, false>>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, false>>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT24U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint32_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt24u

namespace NullableInt32u {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint32_t> & value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint32_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint32_t>::StorageType value;
    NumericAttributeTraits<uint32_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint32_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt32u

namespace NullableInt40u {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint64_t> & value)
{
    NumericAttributeTraits<OddSizedInteger<5, false>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<5, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<OddSizedInteger<5, false>>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<OddSizedInteger<5, false>>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<5, false>>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<5, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<5, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<5, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT40U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<OddSizedInteger<5, false>>::StorageType value;
    NumericAttributeTraits<OddSizedInteger<5, false>>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<5, false>>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT40U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint64_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt40u

namespace NullableInt48u {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint64_t> & value)
{
    NumericAttributeTraits<OddSizedInteger<6, false>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<6, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<OddSizedInteger<6, false>>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<OddSizedInteger<6, false>>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<6, false>>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<6, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<6, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<6, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT48U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<OddSizedInteger<6, false>>::StorageType value;
    NumericAttributeTraits<OddSizedInteger<6, false>>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<6, false>>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT48U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint64_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt48u

namespace NullableInt56u {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint64_t> & value)
{
    NumericAttributeTraits<OddSizedInteger<7, false>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<7, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<OddSizedInteger<7, false>>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<OddSizedInteger<7, false>>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<7, false>>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<7, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<7, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<7, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT56U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<OddSizedInteger<7, false>>::StorageType value;
    NumericAttributeTraits<OddSizedInteger<7, false>>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<7, false>>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT56U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint64_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt56u

namespace NullableInt64u {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint64_t> & value)
{
    NumericAttributeTraits<uint64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint64_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint64_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<uint64_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint64_t>::StorageType storageValue;
    NumericAttributeTraits<uint64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint64_t>::StorageType value;
    NumericAttributeTraits<uint64_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint64_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT64U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint64_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt64u

namespace NullableInt8s {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<int8_t> & value)
{
    NumericAttributeTraits<int8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<int8_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<int8_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int8_t value)
{
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int8_t>::StorageType storageValue;
    NumericAttributeTraits<int8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT8S_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<int8_t>::StorageType value;
    NumericAttributeTraits<int8_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT8S_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<int8_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt8s

namespace NullableInt16s {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<int16_t> & value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<int16_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<int16_t>::StorageType value;
    NumericAttributeTraits<int16_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<int16_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt16s

namespace NullableInt24s {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<int32_t> & value)
{
    NumericAttributeTraits<OddSizedInteger<3, true>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<3, true>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<OddSizedInteger<3, true>>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<OddSizedInteger<3, true>>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int32_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<3, true>>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<3, true>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<3, true>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, true>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT24S_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<OddSizedInteger<3, true>>::StorageType value;
    NumericAttributeTraits<OddSizedInteger<3, true>>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, true>>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT24S_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<int32_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt24s

namespace NullableInt32s {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<int32_t> & value)
{
    NumericAttributeTraits<int32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<int32_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<int32_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int32_t value)
{
    if (!NumericAttributeTraits<int32_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int32_t>::StorageType storageValue;
    NumericAttributeTraits<int32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT32S_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<int32_t>::StorageType value;
    NumericAttributeTraits<int32_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<int32_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT32S_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<int32_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt32s

namespace NullableInt40s {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<int64_t> & value)
{
    NumericAttributeTraits<OddSizedInteger<5, true>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<5, true>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<OddSizedInteger<5, true>>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<OddSizedInteger<5, true>>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int64_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<5, true>>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<5, true>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<5, true>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<5, true>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT40S_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<OddSizedInteger<5, true>>::StorageType value;
    NumericAttributeTraits<OddSizedInteger<5, true>>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<5, true>>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT40S_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<int64_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt40s

namespace NullableInt48s {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<int64_t> & value)
{
    NumericAttributeTraits<OddSizedInteger<6, true>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<6, true>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<OddSizedInteger<6, true>>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<OddSizedInteger<6, true>>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int64_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<6, true>>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<6, true>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<6, true>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<6, true>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT48S_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<OddSizedInteger<6, true>>::StorageType value;
    NumericAttributeTraits<OddSizedInteger<6, true>>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<6, true>>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT48S_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<int64_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt48s

namespace NullableInt56s {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<int64_t> & value)
{
    NumericAttributeTraits<OddSizedInteger<7, true>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<7, true>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<OddSizedInteger<7, true>>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<OddSizedInteger<7, true>>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int64_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<7, true>>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<7, true>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<7, true>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<7, true>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT56S_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<OddSizedInteger<7, true>>::StorageType value;
    NumericAttributeTraits<OddSizedInteger<7, true>>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<7, true>>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT56S_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<int64_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt56s

namespace NullableInt64s {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<int64_t> & value)
{
    NumericAttributeTraits<int64_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int64_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<int64_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<int64_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int64_t value)
{
    if (!NumericAttributeTraits<int64_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int64_t>::StorageType storageValue;
    NumericAttributeTraits<int64_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int64_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT64S_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<int64_t>::StorageType value;
    NumericAttributeTraits<int64_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<int64_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT64S_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<int64_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableInt64s

namespace NullableEnum8 {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint8_t> & value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint8_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint8_t>::StorageType value;
    NumericAttributeTraits<uint8_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint8_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableEnum8

namespace NullableEnum16 {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint16_t> & value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint16_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_ENUM16_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint16_t>::StorageType value;
    NumericAttributeTraits<uint16_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_ENUM16_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint16_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableEnum16

namespace NullableFloatSingle {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<float> & value)
{
    NumericAttributeTraits<float>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<float>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<float>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, float value)
{
    if (!NumericAttributeTraits<float>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<float>::StorageType storageValue;
    NumericAttributeTraits<float>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_SINGLE_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<float>::StorageType value;
    NumericAttributeTraits<float>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<float>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_SINGLE_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<float> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableFloatSingle

namespace NullableFloatDouble {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<double> & value)
{
    NumericAttributeTraits<double>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<double>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<double>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<double>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, double value)
{
    if (!NumericAttributeTraits<double>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<double>::StorageType storageValue;
    NumericAttributeTraits<double>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<double>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_DOUBLE_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<double>::StorageType value;
    NumericAttributeTraits<double>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<double>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_DOUBLE_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<double> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableFloatDouble

namespace NullableOctetString {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<chip::MutableByteSpan> & value)
{
    uint8_t zclString[10 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        value.SetNull();
        return EMBER_ZCL_STATUS_SUCCESS;
    }
    auto & span = value.SetNonNull();

    VerifyOrReturnError(span.size() == 10, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(span.data(), &zclString[1], 10);
    span.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(10 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 10, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[10 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, zclString, ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    uint8_t zclString[1] = { 0xFF };
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, zclString, ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<chip::ByteSpan> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableOctetString

namespace NullableCharString {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<chip::MutableCharSpan> & value)
{
    uint8_t zclString[10 + 1];
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        value.SetNull();
        return EMBER_ZCL_STATUS_SUCCESS;
    }
    auto & span = value.SetNonNull();

    VerifyOrReturnError(span.size() == 10, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(span.data(), &zclString[1], 10);
    span.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(10 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 10, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[10 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    uint8_t zclString[1] = { 0xFF };
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<chip::CharSpan> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableCharString

namespace NullableEnumAttr {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint8_t> & value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint8_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint8_t>::StorageType value;
    NumericAttributeTraits<uint8_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_ENUM8_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint8_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableEnumAttr

namespace NullableRangeRestrictedInt8u {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint8_t> & value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint8_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint8_t>::StorageType value;
    NumericAttributeTraits<uint8_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint8_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableRangeRestrictedInt8u

namespace NullableRangeRestrictedInt8s {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<int8_t> & value)
{
    NumericAttributeTraits<int8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<int8_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<int8_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int8_t value)
{
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int8_t>::StorageType storageValue;
    NumericAttributeTraits<int8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT8S_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<int8_t>::StorageType value;
    NumericAttributeTraits<int8_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT8S_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<int8_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableRangeRestrictedInt8s

namespace NullableRangeRestrictedInt16u {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<uint16_t> & value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<uint16_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<uint16_t>::StorageType value;
    NumericAttributeTraits<uint16_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<uint16_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableRangeRestrictedInt16u

namespace NullableRangeRestrictedInt16s {

EmberAfStatus Get(chip::EndpointId endpoint, DataModel::Nullable<int16_t> & value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::TestCluster::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (NumericAttributeTraits<int16_t>::IsNullValue(temp))
    {
        value.SetNull();
    }
    else
    {
        value.SetNonNull() = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    }
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ true, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

EmberAfStatus SetNull(chip::EndpointId endpoint)
{
    NumericAttributeTraits<int16_t>::StorageType value;
    NumericAttributeTraits<int16_t>::SetNull(value);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(value);
    return emberAfWriteServerAttribute(endpoint, Clusters::TestCluster::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

EmberAfStatus Set(chip::EndpointId endpoint, const DataModel::Nullable<int16_t> & value)
{
    if (value.IsNull())
    {
        return SetNull(endpoint);
    }

    return Set(endpoint, value.Value());
}

} // namespace NullableRangeRestrictedInt16s

} // namespace Attributes
} // namespace TestCluster

namespace ApplianceIdentification {
namespace Attributes {

namespace BasicIdentification {

EmberAfStatus Get(chip::EndpointId endpoint, uint64_t * value)
{
    NumericAttributeTraits<OddSizedInteger<7, false>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<7, false>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<7, false>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<7, false>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint64_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<7, false>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<7, false>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<7, false>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<7, false>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, writable, ZCL_INT56U_ATTRIBUTE_TYPE);
}

} // namespace BasicIdentification

namespace CompanyName {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, zclString,
                                       ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace CompanyName

namespace CompanyId {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace CompanyId

namespace BrandName {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, zclString,
                                       ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace BrandName

namespace BrandId {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace BrandId

namespace Model {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, zclString,
                                       ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace Model

namespace PartNumber {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, zclString,
                                       ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace PartNumber

namespace ProductRevision {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[6 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 6, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 6);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(6 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 6, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[6 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, zclString,
                                       ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace ProductRevision

namespace SoftwareRevision {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[6 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 6, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 6);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(6 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 6, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[6 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, zclString,
                                       ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace SoftwareRevision

namespace ProductTypeName {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[2 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 2, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 2);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(2 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 2, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[2 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, zclString,
                                       ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace ProductTypeName

namespace ProductTypeId {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ProductTypeId

namespace CecedSpecificationVersion {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceIdentification::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace CecedSpecificationVersion

} // namespace Attributes
} // namespace ApplianceIdentification

namespace MeterIdentification {
namespace Attributes {

namespace CompanyName {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace CompanyName

namespace MeterTypeId {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace MeterTypeId

namespace DataQualityId {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace DataQualityId

namespace CustomerName {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace CustomerName

namespace Model {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace Model

namespace PartNumber {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace PartNumber

namespace ProductRevision {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[6 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 6, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 6);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(6 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 6, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[6 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace ProductRevision

namespace SoftwareRevision {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableByteSpan value)
{
    uint8_t zclString[6 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 6, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 6);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::ByteSpan value)
{
    static_assert(6 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 6, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[6 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, ZCL_OCTET_STRING_ATTRIBUTE_TYPE);
}

} // namespace SoftwareRevision

namespace UtilityName {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace UtilityName

namespace Pod {

EmberAfStatus Get(chip::EndpointId endpoint, chip::MutableCharSpan value)
{
    uint8_t zclString[16 + 1];
    EmberAfStatus status =
        emberAfReadServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, sizeof(zclString));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    size_t length = emberAfStringLength(zclString);
    if (length == NumericAttributeTraits<uint8_t>::kNullValue)
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }

    VerifyOrReturnError(value.size() == 16, EMBER_ZCL_STATUS_INVALID_DATA_TYPE);
    memcpy(value.data(), &zclString[1], 16);
    value.reduce_size(length);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, chip::CharSpan value)
{
    static_assert(16 < NumericAttributeTraits<uint8_t>::kNullValue, "value.size() might be too big");
    VerifyOrReturnError(value.size() <= 16, EMBER_ZCL_STATUS_CONSTRAINT_ERROR);
    uint8_t zclString[16 + 1];
    emberAfCopyInt8u(zclString, 0, static_cast<uint8_t>(value.size()));
    memcpy(&zclString[1], value.data(), value.size());
    return emberAfWriteServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, zclString, ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
}

} // namespace Pod

namespace AvailablePower {

EmberAfStatus Get(chip::EndpointId endpoint, int32_t * value)
{
    NumericAttributeTraits<OddSizedInteger<3, true>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<3, true>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<3, true>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<3, true>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int32_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<3, true>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<3, true>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<3, true>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, true>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, writable, ZCL_INT24S_ATTRIBUTE_TYPE);
}

} // namespace AvailablePower

namespace PowerThreshold {

EmberAfStatus Get(chip::EndpointId endpoint, int32_t * value)
{
    NumericAttributeTraits<OddSizedInteger<3, true>>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<OddSizedInteger<3, true>>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<OddSizedInteger<3, true>>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<OddSizedInteger<3, true>>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int32_t value)
{
    if (!NumericAttributeTraits<OddSizedInteger<3, true>>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<OddSizedInteger<3, true>>::StorageType storageValue;
    NumericAttributeTraits<OddSizedInteger<3, true>>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<OddSizedInteger<3, true>>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::MeterIdentification::Id, Id, writable, ZCL_INT24S_ATTRIBUTE_TYPE);
}

} // namespace PowerThreshold

} // namespace Attributes
} // namespace MeterIdentification

namespace ApplianceStatistics {
namespace Attributes {

namespace LogMaxSize {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplianceStatistics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceStatistics::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace LogMaxSize

namespace LogQueueMaxSize {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ApplianceStatistics::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ApplianceStatistics::Id, Id, writable, ZCL_INT8U_ATTRIBUTE_TYPE);
}

} // namespace LogQueueMaxSize

} // namespace Attributes
} // namespace ApplianceStatistics

namespace ElectricalMeasurement {
namespace Attributes {

namespace MeasurementType {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_BITMAP32_ATTRIBUTE_TYPE);
}

} // namespace MeasurementType

namespace DcVoltage {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace DcVoltage

namespace DcVoltageMin {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace DcVoltageMin

namespace DcVoltageMax {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace DcVoltageMax

namespace DcCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace DcCurrent

namespace DcCurrentMin {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace DcCurrentMin

namespace DcCurrentMax {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace DcCurrentMax

namespace DcPower {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace DcPower

namespace DcPowerMin {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace DcPowerMin

namespace DcPowerMax {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace DcPowerMax

namespace DcVoltageMultiplier {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace DcVoltageMultiplier

namespace DcVoltageDivisor {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace DcVoltageDivisor

namespace DcCurrentMultiplier {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace DcCurrentMultiplier

namespace DcCurrentDivisor {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace DcCurrentDivisor

namespace DcPowerMultiplier {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace DcPowerMultiplier

namespace DcPowerDivisor {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace DcPowerDivisor

namespace AcFrequency {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AcFrequency

namespace AcFrequencyMin {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AcFrequencyMin

namespace AcFrequencyMax {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AcFrequencyMax

namespace NeutralCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace NeutralCurrent

namespace TotalActivePower {

EmberAfStatus Get(chip::EndpointId endpoint, int32_t * value)
{
    NumericAttributeTraits<int32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int32_t value)
{
    if (!NumericAttributeTraits<int32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int32_t>::StorageType storageValue;
    NumericAttributeTraits<int32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT32S_ATTRIBUTE_TYPE);
}

} // namespace TotalActivePower

namespace TotalReactivePower {

EmberAfStatus Get(chip::EndpointId endpoint, int32_t * value)
{
    NumericAttributeTraits<int32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int32_t value)
{
    if (!NumericAttributeTraits<int32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int32_t>::StorageType storageValue;
    NumericAttributeTraits<int32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT32S_ATTRIBUTE_TYPE);
}

} // namespace TotalReactivePower

namespace TotalApparentPower {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace TotalApparentPower

namespace Measured1stHarmonicCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace Measured1stHarmonicCurrent

namespace Measured3rdHarmonicCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace Measured3rdHarmonicCurrent

namespace Measured5thHarmonicCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace Measured5thHarmonicCurrent

namespace Measured7thHarmonicCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace Measured7thHarmonicCurrent

namespace Measured9thHarmonicCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace Measured9thHarmonicCurrent

namespace Measured11thHarmonicCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace Measured11thHarmonicCurrent

namespace MeasuredPhase1stHarmonicCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MeasuredPhase1stHarmonicCurrent

namespace MeasuredPhase3rdHarmonicCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MeasuredPhase3rdHarmonicCurrent

namespace MeasuredPhase5thHarmonicCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MeasuredPhase5thHarmonicCurrent

namespace MeasuredPhase7thHarmonicCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MeasuredPhase7thHarmonicCurrent

namespace MeasuredPhase9thHarmonicCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MeasuredPhase9thHarmonicCurrent

namespace MeasuredPhase11thHarmonicCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace MeasuredPhase11thHarmonicCurrent

namespace AcFrequencyMultiplier {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AcFrequencyMultiplier

namespace AcFrequencyDivisor {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AcFrequencyDivisor

namespace PowerMultiplier {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace PowerMultiplier

namespace PowerDivisor {

EmberAfStatus Get(chip::EndpointId endpoint, uint32_t * value)
{
    NumericAttributeTraits<uint32_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint32_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint32_t value)
{
    if (!NumericAttributeTraits<uint32_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint32_t>::StorageType storageValue;
    NumericAttributeTraits<uint32_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint32_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT32U_ATTRIBUTE_TYPE);
}

} // namespace PowerDivisor

namespace HarmonicCurrentMultiplier {

EmberAfStatus Get(chip::EndpointId endpoint, int8_t * value)
{
    NumericAttributeTraits<int8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int8_t value)
{
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int8_t>::StorageType storageValue;
    NumericAttributeTraits<int8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT8S_ATTRIBUTE_TYPE);
}

} // namespace HarmonicCurrentMultiplier

namespace PhaseHarmonicCurrentMultiplier {

EmberAfStatus Get(chip::EndpointId endpoint, int8_t * value)
{
    NumericAttributeTraits<int8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int8_t value)
{
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int8_t>::StorageType storageValue;
    NumericAttributeTraits<int8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT8S_ATTRIBUTE_TYPE);
}

} // namespace PhaseHarmonicCurrentMultiplier

namespace InstantaneousVoltage {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace InstantaneousVoltage

namespace InstantaneousLineCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace InstantaneousLineCurrent

namespace InstantaneousActiveCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace InstantaneousActiveCurrent

namespace InstantaneousReactiveCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace InstantaneousReactiveCurrent

namespace InstantaneousPower {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace InstantaneousPower

namespace RmsVoltage {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltage

namespace RmsVoltageMin {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltageMin

namespace RmsVoltageMax {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltageMax

namespace RmsCurrent {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsCurrent

namespace RmsCurrentMin {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsCurrentMin

namespace RmsCurrentMax {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsCurrentMax

namespace ActivePower {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ActivePower

namespace ActivePowerMin {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ActivePowerMin

namespace ActivePowerMax {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ActivePowerMax

namespace ReactivePower {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ReactivePower

namespace ApparentPower {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ApparentPower

namespace PowerFactor {

EmberAfStatus Get(chip::EndpointId endpoint, int8_t * value)
{
    NumericAttributeTraits<int8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int8_t value)
{
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int8_t>::StorageType storageValue;
    NumericAttributeTraits<int8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT8S_ATTRIBUTE_TYPE);
}

} // namespace PowerFactor

namespace AverageRmsVoltageMeasurementPeriod {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AverageRmsVoltageMeasurementPeriod

namespace AverageRmsUnderVoltageCounter {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AverageRmsUnderVoltageCounter

namespace RmsExtremeOverVoltagePeriod {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsExtremeOverVoltagePeriod

namespace RmsExtremeUnderVoltagePeriod {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsExtremeUnderVoltagePeriod

namespace RmsVoltageSagPeriod {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltageSagPeriod

namespace RmsVoltageSwellPeriod {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltageSwellPeriod

namespace AcVoltageMultiplier {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AcVoltageMultiplier

namespace AcVoltageDivisor {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AcVoltageDivisor

namespace AcCurrentMultiplier {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AcCurrentMultiplier

namespace AcCurrentDivisor {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AcCurrentDivisor

namespace AcPowerMultiplier {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AcPowerMultiplier

namespace AcPowerDivisor {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AcPowerDivisor

namespace OverloadAlarmsMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint8_t * value)
{
    NumericAttributeTraits<uint8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint8_t value)
{
    if (!NumericAttributeTraits<uint8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint8_t>::StorageType storageValue;
    NumericAttributeTraits<uint8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_BITMAP8_ATTRIBUTE_TYPE);
}

} // namespace OverloadAlarmsMask

namespace VoltageOverload {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace VoltageOverload

namespace CurrentOverload {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace CurrentOverload

namespace AcOverloadAlarmsMask {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_BITMAP16_ATTRIBUTE_TYPE);
}

} // namespace AcOverloadAlarmsMask

namespace AcVoltageOverload {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace AcVoltageOverload

namespace AcCurrentOverload {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace AcCurrentOverload

namespace AcActivePowerOverload {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace AcActivePowerOverload

namespace AcReactivePowerOverload {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace AcReactivePowerOverload

namespace AverageRmsOverVoltage {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace AverageRmsOverVoltage

namespace AverageRmsUnderVoltage {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace AverageRmsUnderVoltage

namespace RmsExtremeOverVoltage {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace RmsExtremeOverVoltage

namespace RmsExtremeUnderVoltage {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace RmsExtremeUnderVoltage

namespace RmsVoltageSag {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltageSag

namespace RmsVoltageSwell {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltageSwell

namespace LineCurrentPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace LineCurrentPhaseB

namespace ActiveCurrentPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ActiveCurrentPhaseB

namespace ReactiveCurrentPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ReactiveCurrentPhaseB

namespace RmsVoltagePhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltagePhaseB

namespace RmsVoltageMinPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltageMinPhaseB

namespace RmsVoltageMaxPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltageMaxPhaseB

namespace RmsCurrentPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsCurrentPhaseB

namespace RmsCurrentMinPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsCurrentMinPhaseB

namespace RmsCurrentMaxPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsCurrentMaxPhaseB

namespace ActivePowerPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ActivePowerPhaseB

namespace ActivePowerMinPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ActivePowerMinPhaseB

namespace ActivePowerMaxPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ActivePowerMaxPhaseB

namespace ReactivePowerPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ReactivePowerPhaseB

namespace ApparentPowerPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ApparentPowerPhaseB

namespace PowerFactorPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, int8_t * value)
{
    NumericAttributeTraits<int8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int8_t value)
{
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int8_t>::StorageType storageValue;
    NumericAttributeTraits<int8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT8S_ATTRIBUTE_TYPE);
}

} // namespace PowerFactorPhaseB

namespace AverageRmsVoltageMeasurementPeriodPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AverageRmsVoltageMeasurementPeriodPhaseB

namespace AverageRmsOverVoltageCounterPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AverageRmsOverVoltageCounterPhaseB

namespace AverageRmsUnderVoltageCounterPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AverageRmsUnderVoltageCounterPhaseB

namespace RmsExtremeOverVoltagePeriodPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsExtremeOverVoltagePeriodPhaseB

namespace RmsExtremeUnderVoltagePeriodPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsExtremeUnderVoltagePeriodPhaseB

namespace RmsVoltageSagPeriodPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltageSagPeriodPhaseB

namespace RmsVoltageSwellPeriodPhaseB {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltageSwellPeriodPhaseB

namespace LineCurrentPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace LineCurrentPhaseC

namespace ActiveCurrentPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ActiveCurrentPhaseC

namespace ReactiveCurrentPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ReactiveCurrentPhaseC

namespace RmsVoltagePhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltagePhaseC

namespace RmsVoltageMinPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltageMinPhaseC

namespace RmsVoltageMaxPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltageMaxPhaseC

namespace RmsCurrentPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsCurrentPhaseC

namespace RmsCurrentMinPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsCurrentMinPhaseC

namespace RmsCurrentMaxPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsCurrentMaxPhaseC

namespace ActivePowerPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ActivePowerPhaseC

namespace ActivePowerMinPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ActivePowerMinPhaseC

namespace ActivePowerMaxPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ActivePowerMaxPhaseC

namespace ReactivePowerPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, int16_t * value)
{
    NumericAttributeTraits<int16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int16_t value)
{
    if (!NumericAttributeTraits<int16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int16_t>::StorageType storageValue;
    NumericAttributeTraits<int16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16S_ATTRIBUTE_TYPE);
}

} // namespace ReactivePowerPhaseC

namespace ApparentPowerPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace ApparentPowerPhaseC

namespace PowerFactorPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, int8_t * value)
{
    NumericAttributeTraits<int8_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<int8_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, int8_t value)
{
    if (!NumericAttributeTraits<int8_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<int8_t>::StorageType storageValue;
    NumericAttributeTraits<int8_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<int8_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT8S_ATTRIBUTE_TYPE);
}

} // namespace PowerFactorPhaseC

namespace AverageRmsVoltageMeasurementPeriodPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AverageRmsVoltageMeasurementPeriodPhaseC

namespace AverageRmsOverVoltageCounterPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AverageRmsOverVoltageCounterPhaseC

namespace AverageRmsUnderVoltageCounterPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace AverageRmsUnderVoltageCounterPhaseC

namespace RmsExtremeOverVoltagePeriodPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsExtremeOverVoltagePeriodPhaseC

namespace RmsExtremeUnderVoltagePeriodPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsExtremeUnderVoltagePeriodPhaseC

namespace RmsVoltageSagPeriodPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltageSagPeriodPhaseC

namespace RmsVoltageSwellPeriodPhaseC {

EmberAfStatus Get(chip::EndpointId endpoint, uint16_t * value)
{
    NumericAttributeTraits<uint16_t>::StorageType temp;
    uint8_t * readable   = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(temp);
    EmberAfStatus status = emberAfReadServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, readable, sizeof(temp));
    VerifyOrReturnError(EMBER_ZCL_STATUS_SUCCESS == status, status);
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, temp))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    *value = NumericAttributeTraits<uint16_t>::StorageToWorking(temp);
    return status;
}
EmberAfStatus Set(chip::EndpointId endpoint, uint16_t value)
{
    if (!NumericAttributeTraits<uint16_t>::CanRepresentValue(/* isNullable = */ false, value))
    {
        return EMBER_ZCL_STATUS_CONSTRAINT_ERROR;
    }
    NumericAttributeTraits<uint16_t>::StorageType storageValue;
    NumericAttributeTraits<uint16_t>::WorkingToStorage(value, storageValue);
    uint8_t * writable = NumericAttributeTraits<uint16_t>::ToAttributeStoreRepresentation(storageValue);
    return emberAfWriteServerAttribute(endpoint, Clusters::ElectricalMeasurement::Id, Id, writable, ZCL_INT16U_ATTRIBUTE_TYPE);
}

} // namespace RmsVoltageSwellPeriodPhaseC

} // namespace Attributes
} // namespace ElectricalMeasurement

} // namespace Clusters
} // namespace app
} // namespace chip
