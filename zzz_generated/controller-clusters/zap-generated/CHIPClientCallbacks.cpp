/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include <zap-generated/CHIPClientCallbacks.h>

#include <cinttypes>

#include <app-common/zap-generated/enums.h>
#include <app/util/CHIPDeviceCallbacksMgr.h>
#include <app/util/af-enums.h>
#include <app/util/af.h>
#include <app/util/basic-types.h>
#include <lib/core/CHIPEncoding.h>
#include <lib/support/SafeInt.h>
#include <lib/support/TypeTraits.h>
#include <lib/support/logging/CHIPLogging.h>

using namespace ::chip;
using namespace ::chip::app::DataModel;

namespace {
[[maybe_unused]] constexpr uint16_t kByteSpanSizeLengthInBytes = 2;
} // namespace

#define CHECK_STATUS_WITH_RETVAL(error, retval)                                                                                    \
    if (CHIP_NO_ERROR != error)                                                                                                    \
    {                                                                                                                              \
        ChipLogError(Zcl, "CHECK_STATUS %s", ErrorStr(error));                                                                     \
        if (onFailureCallback != nullptr)                                                                                          \
        {                                                                                                                          \
            Callback::Callback<DefaultFailureCallback> * cb =                                                                      \
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);                                     \
            cb->mCall(cb->mContext, static_cast<uint8_t>(EMBER_ZCL_STATUS_INVALID_VALUE));                                         \
        }                                                                                                                          \
        return retval;                                                                                                             \
    }

#define CHECK_STATUS(error) CHECK_STATUS_WITH_RETVAL(error, true)
#define CHECK_STATUS_VOID(error) CHECK_STATUS_WITH_RETVAL(error, )

#define CHECK_MESSAGE_LENGTH_WITH_RETVAL(value, retval)                                                                            \
    if (!CanCastTo<uint16_t>(value))                                                                                               \
    {                                                                                                                              \
        ChipLogError(Zcl, "CHECK_MESSAGE_LENGTH expects a uint16_t value, got: %d", value);                                        \
        if (onFailureCallback != nullptr)                                                                                          \
        {                                                                                                                          \
            Callback::Callback<DefaultFailureCallback> * cb =                                                                      \
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);                                     \
            cb->mCall(cb->mContext, static_cast<uint8_t>(EMBER_ZCL_STATUS_INVALID_VALUE));                                         \
        }                                                                                                                          \
        return retval;                                                                                                             \
    }                                                                                                                              \
                                                                                                                                   \
    if (messageLen < value)                                                                                                        \
    {                                                                                                                              \
        ChipLogError(Zcl, "Unexpected response length: %d", messageLen);                                                           \
        if (onFailureCallback != nullptr)                                                                                          \
        {                                                                                                                          \
            Callback::Callback<DefaultFailureCallback> * cb =                                                                      \
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);                                     \
            cb->mCall(cb->mContext, static_cast<uint8_t>(EMBER_ZCL_STATUS_INVALID_VALUE));                                         \
        }                                                                                                                          \
        return retval;                                                                                                             \
    }                                                                                                                              \
                                                                                                                                   \
    messageLen = static_cast<uint16_t>(messageLen - static_cast<uint16_t>(value));

#define CHECK_MESSAGE_LENGTH(value) CHECK_MESSAGE_LENGTH_WITH_RETVAL(value, true)
#define CHECK_MESSAGE_LENGTH_VOID(value) CHECK_MESSAGE_LENGTH_WITH_RETVAL(value, )

#define GET_RESPONSE_CALLBACKS(name)                                                                                               \
    Callback::Cancelable * onSuccessCallback = nullptr;                                                                            \
    Callback::Cancelable * onFailureCallback = nullptr;                                                                            \
    NodeId sourceId                          = emberAfCurrentCommand()->SourceNodeId();                                            \
    uint8_t sequenceNumber                   = emberAfCurrentCommand()->seqNum;                                                    \
    CHIP_ERROR err = gCallbacks.GetResponseCallback(sourceId, sequenceNumber, &onSuccessCallback, &onFailureCallback);             \
                                                                                                                                   \
    if (CHIP_NO_ERROR != err)                                                                                                      \
    {                                                                                                                              \
        if (onSuccessCallback == nullptr)                                                                                          \
        {                                                                                                                          \
            ChipLogDetail(Zcl, "%s: Missing success callback", name);                                                              \
        }                                                                                                                          \
                                                                                                                                   \
        if (onFailureCallback == nullptr)                                                                                          \
        {                                                                                                                          \
            ChipLogDetail(Zcl, "%s: Missing failure callback", name);                                                              \
        }                                                                                                                          \
                                                                                                                                   \
        return true;                                                                                                               \
    }

#define GET_CLUSTER_RESPONSE_CALLBACKS(name)                                                                                       \
    Callback::Cancelable * onSuccessCallback = nullptr;                                                                            \
    Callback::Cancelable * onFailureCallback = nullptr;                                                                            \
    NodeId sourceIdentifier                  = reinterpret_cast<NodeId>(commandObj);                                               \
    /* #6559: Currently, we only have one commands for the IMInvokeCommands and to a device, so the seqNum is always set to 0. */  \
    CHIP_ERROR err = gCallbacks.GetResponseCallback(sourceIdentifier, 0, &onSuccessCallback, &onFailureCallback);                  \
                                                                                                                                   \
    if (CHIP_NO_ERROR != err)                                                                                                      \
    {                                                                                                                              \
        if (onSuccessCallback == nullptr)                                                                                          \
        {                                                                                                                          \
            ChipLogDetail(Zcl, "%s: Missing success callback", name);                                                              \
        }                                                                                                                          \
                                                                                                                                   \
        if (onFailureCallback == nullptr)                                                                                          \
        {                                                                                                                          \
            ChipLogDetail(Zcl, "%s: Missing failure callback", name);                                                              \
        }                                                                                                                          \
                                                                                                                                   \
        return true;                                                                                                               \
    }

// Singleton instance of the callbacks manager
app::CHIPDeviceCallbacksMgr & gCallbacks = app::CHIPDeviceCallbacksMgr::GetInstance();

void AccessControlClusterAclListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<AccessControlAclListAttributeCallback> * cb =
        Callback::Callback<AccessControlAclListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void AccessControlClusterExtensionListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::ExtensionEntry::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<AccessControlExtensionListAttributeCallback> * cb =
        Callback::Callback<AccessControlExtensionListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void AccessControlClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<AccessControlAttributeListListAttributeCallback> * cb =
        Callback::Callback<AccessControlAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void AccountLoginClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<AccountLoginAttributeListListAttributeCallback> * cb =
        Callback::Callback<AccountLoginAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void AdministratorCommissioningClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                       Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<AdministratorCommissioningAttributeListListAttributeCallback> * cb =
        Callback::Callback<AdministratorCommissioningAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ApplicationBasicClusterAllowedVendorListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::VendorId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ApplicationBasicAllowedVendorListListAttributeCallback> * cb =
        Callback::Callback<ApplicationBasicAllowedVendorListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ApplicationBasicClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ApplicationBasicAttributeListListAttributeCallback> * cb =
        Callback::Callback<ApplicationBasicAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ApplicationLauncherClusterApplicationLauncherListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                          Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<uint16_t> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ApplicationLauncherApplicationLauncherListListAttributeCallback> * cb =
        Callback::Callback<ApplicationLauncherApplicationLauncherListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ApplicationLauncherClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ApplicationLauncherAttributeListListAttributeCallback> * cb =
        Callback::Callback<ApplicationLauncherAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void AudioOutputClusterAudioOutputListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::OutputInfo::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<AudioOutputAudioOutputListListAttributeCallback> * cb =
        Callback::Callback<AudioOutputAudioOutputListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void AudioOutputClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<AudioOutputAttributeListListAttributeCallback> * cb =
        Callback::Callback<AudioOutputAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void BarrierControlClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<BarrierControlAttributeListListAttributeCallback> * cb =
        Callback::Callback<BarrierControlAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void BasicClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<BasicAttributeListListAttributeCallback> * cb =
        Callback::Callback<BasicAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void BinaryInputBasicClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<BinaryInputBasicAttributeListListAttributeCallback> * cb =
        Callback::Callback<BinaryInputBasicAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void BindingClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<BindingAttributeListListAttributeCallback> * cb =
        Callback::Callback<BindingAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void BooleanStateClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<BooleanStateAttributeListListAttributeCallback> * cb =
        Callback::Callback<BooleanStateAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void BridgedActionsClusterActionListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::ActionStruct::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<BridgedActionsActionListListAttributeCallback> * cb =
        Callback::Callback<BridgedActionsActionListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void BridgedActionsClusterEndpointListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::EndpointListStruct::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<BridgedActionsEndpointListListAttributeCallback> * cb =
        Callback::Callback<BridgedActionsEndpointListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void BridgedActionsClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<BridgedActionsAttributeListListAttributeCallback> * cb =
        Callback::Callback<BridgedActionsAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void BridgedDeviceBasicClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<BridgedDeviceBasicAttributeListListAttributeCallback> * cb =
        Callback::Callback<BridgedDeviceBasicAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ChannelClusterChannelListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ChannelChannelListListAttributeCallback> * cb =
        Callback::Callback<ChannelChannelListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ChannelClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ChannelAttributeListListAttributeCallback> * cb =
        Callback::Callback<ChannelAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ColorControlClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ColorControlAttributeListListAttributeCallback> * cb =
        Callback::Callback<ColorControlAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ContentLauncherClusterAcceptHeaderListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::CharSpan> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ContentLauncherAcceptHeaderListListAttributeCallback> * cb =
        Callback::Callback<ContentLauncherAcceptHeaderListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ContentLauncherClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ContentLauncherAttributeListListAttributeCallback> * cb =
        Callback::Callback<ContentLauncherAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void DescriptorClusterDeviceListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<DescriptorDeviceListListAttributeCallback> * cb =
        Callback::Callback<DescriptorDeviceListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void DescriptorClusterServerListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::ClusterId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<DescriptorServerListListAttributeCallback> * cb =
        Callback::Callback<DescriptorServerListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void DescriptorClusterClientListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::ClusterId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<DescriptorClientListListAttributeCallback> * cb =
        Callback::Callback<DescriptorClientListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void DescriptorClusterPartsListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::EndpointId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<DescriptorPartsListListAttributeCallback> * cb =
        Callback::Callback<DescriptorPartsListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void DescriptorClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<DescriptorAttributeListListAttributeCallback> * cb =
        Callback::Callback<DescriptorAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void DiagnosticLogsClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<DiagnosticLogsAttributeListListAttributeCallback> * cb =
        Callback::Callback<DiagnosticLogsAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void DoorLockClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<DoorLockAttributeListListAttributeCallback> * cb =
        Callback::Callback<DoorLockAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ElectricalMeasurementClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                  Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ElectricalMeasurementAttributeListListAttributeCallback> * cb =
        Callback::Callback<ElectricalMeasurementAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void EthernetNetworkDiagnosticsClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                       Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<EthernetNetworkDiagnosticsAttributeListListAttributeCallback> * cb =
        Callback::Callback<EthernetNetworkDiagnosticsAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void FixedLabelClusterLabelListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::FixedLabel::Structs::LabelStruct::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<FixedLabelLabelListListAttributeCallback> * cb =
        Callback::Callback<FixedLabelLabelListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void FixedLabelClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<FixedLabelAttributeListListAttributeCallback> * cb =
        Callback::Callback<FixedLabelAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void FlowMeasurementClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<FlowMeasurementAttributeListListAttributeCallback> * cb =
        Callback::Callback<FlowMeasurementAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GeneralCommissioningClusterBasicCommissioningInfoListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                              Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<
        chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfoType::DecodableType>
        list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GeneralCommissioningBasicCommissioningInfoListListAttributeCallback> * cb =
        Callback::Callback<GeneralCommissioningBasicCommissioningInfoListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GeneralCommissioningClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GeneralCommissioningAttributeListListAttributeCallback> * cb =
        Callback::Callback<GeneralCommissioningAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GeneralDiagnosticsClusterNetworkInterfacesListAttributeFilter(TLV::TLVReader * tlvData,
                                                                   Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GeneralDiagnosticsNetworkInterfacesListAttributeCallback> * cb =
        Callback::Callback<GeneralDiagnosticsNetworkInterfacesListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GeneralDiagnosticsClusterActiveHardwareFaultsListAttributeFilter(TLV::TLVReader * tlvData,
                                                                      Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<uint8_t> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GeneralDiagnosticsActiveHardwareFaultsListAttributeCallback> * cb =
        Callback::Callback<GeneralDiagnosticsActiveHardwareFaultsListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GeneralDiagnosticsClusterActiveRadioFaultsListAttributeFilter(TLV::TLVReader * tlvData,
                                                                   Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<uint8_t> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GeneralDiagnosticsActiveRadioFaultsListAttributeCallback> * cb =
        Callback::Callback<GeneralDiagnosticsActiveRadioFaultsListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GeneralDiagnosticsClusterActiveNetworkFaultsListAttributeFilter(TLV::TLVReader * tlvData,
                                                                     Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<uint8_t> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GeneralDiagnosticsActiveNetworkFaultsListAttributeCallback> * cb =
        Callback::Callback<GeneralDiagnosticsActiveNetworkFaultsListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GeneralDiagnosticsClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GeneralDiagnosticsAttributeListListAttributeCallback> * cb =
        Callback::Callback<GeneralDiagnosticsAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GroupKeyManagementClusterGroupKeyMapListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupKey::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GroupKeyManagementGroupKeyMapListAttributeCallback> * cb =
        Callback::Callback<GroupKeyManagementGroupKeyMapListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GroupKeyManagementClusterGroupTableListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupInfo::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GroupKeyManagementGroupTableListAttributeCallback> * cb =
        Callback::Callback<GroupKeyManagementGroupTableListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GroupKeyManagementClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GroupKeyManagementAttributeListListAttributeCallback> * cb =
        Callback::Callback<GroupKeyManagementAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GroupsClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GroupsAttributeListListAttributeCallback> * cb =
        Callback::Callback<GroupsAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void IdentifyClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<IdentifyAttributeListListAttributeCallback> * cb =
        Callback::Callback<IdentifyAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void IlluminanceMeasurementClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                   Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<IlluminanceMeasurementAttributeListListAttributeCallback> * cb =
        Callback::Callback<IlluminanceMeasurementAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void KeypadInputClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<KeypadInputAttributeListListAttributeCallback> * cb =
        Callback::Callback<KeypadInputAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void LevelControlClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<LevelControlAttributeListListAttributeCallback> * cb =
        Callback::Callback<LevelControlAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void LowPowerClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<LowPowerAttributeListListAttributeCallback> * cb =
        Callback::Callback<LowPowerAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void MediaInputClusterMediaInputListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::InputInfo::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<MediaInputMediaInputListListAttributeCallback> * cb =
        Callback::Callback<MediaInputMediaInputListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void MediaInputClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<MediaInputAttributeListListAttributeCallback> * cb =
        Callback::Callback<MediaInputAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void MediaPlaybackClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<MediaPlaybackAttributeListListAttributeCallback> * cb =
        Callback::Callback<MediaPlaybackAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ModeSelectClusterSupportedModesListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ModeSelectSupportedModesListAttributeCallback> * cb =
        Callback::Callback<ModeSelectSupportedModesListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ModeSelectClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ModeSelectAttributeListListAttributeCallback> * cb =
        Callback::Callback<ModeSelectAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void NetworkCommissioningClusterNetworksListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfo::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<NetworkCommissioningNetworksListAttributeCallback> * cb =
        Callback::Callback<NetworkCommissioningNetworksListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void OtaSoftwareUpdateProviderClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                      Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<OtaSoftwareUpdateProviderAttributeListListAttributeCallback> * cb =
        Callback::Callback<OtaSoftwareUpdateProviderAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void OtaSoftwareUpdateRequestorClusterDefaultOtaProvidersListAttributeFilter(TLV::TLVReader * tlvData,
                                                                             Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::DecodableType>
        list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<OtaSoftwareUpdateRequestorDefaultOtaProvidersListAttributeCallback> * cb =
        Callback::Callback<OtaSoftwareUpdateRequestorDefaultOtaProvidersListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void OtaSoftwareUpdateRequestorClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                       Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<OtaSoftwareUpdateRequestorAttributeListListAttributeCallback> * cb =
        Callback::Callback<OtaSoftwareUpdateRequestorAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void OccupancySensingClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<OccupancySensingAttributeListListAttributeCallback> * cb =
        Callback::Callback<OccupancySensingAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void OnOffClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<OnOffAttributeListListAttributeCallback> * cb =
        Callback::Callback<OnOffAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void OnOffSwitchConfigurationClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                     Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<OnOffSwitchConfigurationAttributeListListAttributeCallback> * cb =
        Callback::Callback<OnOffSwitchConfigurationAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void OperationalCredentialsClusterFabricsListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<OperationalCredentialsFabricsListListAttributeCallback> * cb =
        Callback::Callback<OperationalCredentialsFabricsListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void OperationalCredentialsClusterTrustedRootCertificatesListAttributeFilter(TLV::TLVReader * tlvData,
                                                                             Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::ByteSpan> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<OperationalCredentialsTrustedRootCertificatesListAttributeCallback> * cb =
        Callback::Callback<OperationalCredentialsTrustedRootCertificatesListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void OperationalCredentialsClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                   Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<OperationalCredentialsAttributeListListAttributeCallback> * cb =
        Callback::Callback<OperationalCredentialsAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void PowerSourceClusterActiveBatteryFaultsListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<uint8_t> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<PowerSourceActiveBatteryFaultsListAttributeCallback> * cb =
        Callback::Callback<PowerSourceActiveBatteryFaultsListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void PowerSourceClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<PowerSourceAttributeListListAttributeCallback> * cb =
        Callback::Callback<PowerSourceAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void PowerSourceConfigurationClusterSourcesListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<uint8_t> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<PowerSourceConfigurationSourcesListAttributeCallback> * cb =
        Callback::Callback<PowerSourceConfigurationSourcesListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void PowerSourceConfigurationClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                     Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<PowerSourceConfigurationAttributeListListAttributeCallback> * cb =
        Callback::Callback<PowerSourceConfigurationAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void PressureMeasurementClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<PressureMeasurementAttributeListListAttributeCallback> * cb =
        Callback::Callback<PressureMeasurementAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void PumpConfigurationAndControlClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                        Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<PumpConfigurationAndControlAttributeListListAttributeCallback> * cb =
        Callback::Callback<PumpConfigurationAndControlAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void RelativeHumidityMeasurementClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                        Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<RelativeHumidityMeasurementAttributeListListAttributeCallback> * cb =
        Callback::Callback<RelativeHumidityMeasurementAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ScenesClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ScenesAttributeListListAttributeCallback> * cb =
        Callback::Callback<ScenesAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void SoftwareDiagnosticsClusterThreadMetricsListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<SoftwareDiagnosticsThreadMetricsListAttributeCallback> * cb =
        Callback::Callback<SoftwareDiagnosticsThreadMetricsListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void SoftwareDiagnosticsClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<SoftwareDiagnosticsAttributeListListAttributeCallback> * cb =
        Callback::Callback<SoftwareDiagnosticsAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void SwitchClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<SwitchAttributeListListAttributeCallback> * cb =
        Callback::Callback<SwitchAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void TargetNavigatorClusterTargetNavigatorListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                  Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfo::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<TargetNavigatorTargetNavigatorListListAttributeCallback> * cb =
        Callback::Callback<TargetNavigatorTargetNavigatorListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void TargetNavigatorClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<TargetNavigatorAttributeListListAttributeCallback> * cb =
        Callback::Callback<TargetNavigatorAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void TemperatureMeasurementClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                   Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<TemperatureMeasurementAttributeListListAttributeCallback> * cb =
        Callback::Callback<TemperatureMeasurementAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void TestClusterClusterListInt8uListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<uint8_t> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<TestClusterListInt8uListAttributeCallback> * cb =
        Callback::Callback<TestClusterListInt8uListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void TestClusterClusterListOctetStringListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::ByteSpan> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<TestClusterListOctetStringListAttributeCallback> * cb =
        Callback::Callback<TestClusterListOctetStringListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void TestClusterClusterListStructOctetStringListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<TestClusterListStructOctetStringListAttributeCallback> * cb =
        Callback::Callback<TestClusterListStructOctetStringListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void TestClusterClusterListNullablesAndOptionalsStructListAttributeFilter(TLV::TLVReader * tlvData,
                                                                          Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<TestClusterListNullablesAndOptionalsStructListAttributeCallback> * cb =
        Callback::Callback<TestClusterListNullablesAndOptionalsStructListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void TestClusterClusterListLongOctetStringListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::ByteSpan> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<TestClusterListLongOctetStringListAttributeCallback> * cb =
        Callback::Callback<TestClusterListLongOctetStringListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void TestClusterClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<TestClusterAttributeListListAttributeCallback> * cb =
        Callback::Callback<TestClusterAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ThermostatClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ThermostatAttributeListListAttributeCallback> * cb =
        Callback::Callback<ThermostatAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ThermostatUserInterfaceConfigurationClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                                 Callback::Cancelable * onSuccessCallback,
                                                                                 Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ThermostatUserInterfaceConfigurationAttributeListListAttributeCallback> * cb =
        Callback::Callback<ThermostatUserInterfaceConfigurationAttributeListListAttributeCallback>::FromCancelable(
            onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ThreadNetworkDiagnosticsClusterNeighborTableListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                         Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTable::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ThreadNetworkDiagnosticsNeighborTableListListAttributeCallback> * cb =
        Callback::Callback<ThreadNetworkDiagnosticsNeighborTableListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ThreadNetworkDiagnosticsClusterRouteTableListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                      Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTable::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ThreadNetworkDiagnosticsRouteTableListListAttributeCallback> * cb =
        Callback::Callback<ThreadNetworkDiagnosticsRouteTableListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ThreadNetworkDiagnosticsClusterSecurityPolicyListAttributeFilter(TLV::TLVReader * tlvData,
                                                                      Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ThreadNetworkDiagnosticsSecurityPolicyListAttributeCallback> * cb =
        Callback::Callback<ThreadNetworkDiagnosticsSecurityPolicyListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ThreadNetworkDiagnosticsClusterOperationalDatasetComponentsListAttributeFilter(TLV::TLVReader * tlvData,
                                                                                    Callback::Cancelable * onSuccessCallback,
                                                                                    Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType>
        list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallback> * cb =
        Callback::Callback<ThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallback>::FromCancelable(
            onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ThreadNetworkDiagnosticsClusterActiveNetworkFaultsListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                               Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFault> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallback> * cb =
        Callback::Callback<ThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ThreadNetworkDiagnosticsClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                     Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ThreadNetworkDiagnosticsAttributeListListAttributeCallback> * cb =
        Callback::Callback<ThreadNetworkDiagnosticsAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void UserLabelClusterLabelListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::UserLabel::Structs::LabelStruct::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<UserLabelLabelListListAttributeCallback> * cb =
        Callback::Callback<UserLabelLabelListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void WakeOnLanClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<WakeOnLanAttributeListListAttributeCallback> * cb =
        Callback::Callback<WakeOnLanAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void WiFiNetworkDiagnosticsClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                   Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<WiFiNetworkDiagnosticsAttributeListListAttributeCallback> * cb =
        Callback::Callback<WiFiNetworkDiagnosticsAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void WindowCoveringClusterAttributeListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::AttributeId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<WindowCoveringAttributeListListAttributeCallback> * cb =
        Callback::Callback<WindowCoveringAttributeListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

bool emberAfAccountLoginClusterGetSetupPINResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                           chip::CharSpan setupPIN)
{
    ChipLogProgress(Zcl, "GetSetupPINResponse:");
    ChipLogProgress(Zcl, "  setupPIN: %.*s", static_cast<int>(setupPIN.size()), setupPIN.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("AccountLoginClusterGetSetupPINResponseCallback");

    Callback::Callback<AccountLoginClusterGetSetupPINResponseCallback> * cb =
        Callback::Callback<AccountLoginClusterGetSetupPINResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, setupPIN);
    return true;
}

bool emberAfApplicationLauncherClusterLauncherResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                               chip::CharSpan data)
{
    ChipLogProgress(Zcl, "LauncherResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  data: %.*s", static_cast<int>(data.size()), data.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("ApplicationLauncherClusterLauncherResponseCallback");

    Callback::Callback<ApplicationLauncherClusterLauncherResponseCallback> * cb =
        Callback::Callback<ApplicationLauncherClusterLauncherResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, data);
    return true;
}

bool emberAfChannelClusterChangeChannelResponseCallback(
    EndpointId endpoint, app::CommandSender * commandObj,
    chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType channelMatch, uint8_t errorType)
{
    ChipLogProgress(Zcl, "ChangeChannelResponse:");
    ChipLogProgress(Zcl, "  channelMatch: Not sure how to log struct ChannelInfo");
    ChipLogProgress(Zcl, "  errorType: %" PRIu8 "", errorType);

    GET_CLUSTER_RESPONSE_CALLBACKS("ChannelClusterChangeChannelResponseCallback");

    Callback::Callback<ChannelClusterChangeChannelResponseCallback> * cb =
        Callback::Callback<ChannelClusterChangeChannelResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, ChannelInfo(), errorType);
    return true;
}

bool emberAfContentLauncherClusterLaunchResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                         chip::CharSpan data)
{
    ChipLogProgress(Zcl, "LaunchResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  data: %.*s", static_cast<int>(data.size()), data.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("ContentLauncherClusterLaunchResponseCallback");

    Callback::Callback<ContentLauncherClusterLaunchResponseCallback> * cb =
        Callback::Callback<ContentLauncherClusterLaunchResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, data);
    return true;
}

bool emberAfDiagnosticLogsClusterRetrieveLogsResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                              chip::ByteSpan content, uint32_t timeStamp, uint32_t timeSinceBoot)
{
    ChipLogProgress(Zcl, "RetrieveLogsResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  content: %zu", content.size());
    ChipLogProgress(Zcl, "  timeStamp: %" PRIu32 "", timeStamp);
    ChipLogProgress(Zcl, "  timeSinceBoot: %" PRIu32 "", timeSinceBoot);

    GET_CLUSTER_RESPONSE_CALLBACKS("DiagnosticLogsClusterRetrieveLogsResponseCallback");

    Callback::Callback<DiagnosticLogsClusterRetrieveLogsResponseCallback> * cb =
        Callback::Callback<DiagnosticLogsClusterRetrieveLogsResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, content, timeStamp, timeSinceBoot);
    return true;
}

bool emberAfDoorLockClusterGetCredentialStatusResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                               bool credentialExists, uint16_t userIndex,
                                                               uint16_t nextCredentialIndex)
{
    ChipLogProgress(Zcl, "GetCredentialStatusResponse:");
    ChipLogProgress(Zcl, "  credentialExists: %d", credentialExists);
    ChipLogProgress(Zcl, "  userIndex: %" PRIu16 "", userIndex);
    ChipLogProgress(Zcl, "  nextCredentialIndex: %" PRIu16 "", nextCredentialIndex);

    GET_CLUSTER_RESPONSE_CALLBACKS("DoorLockClusterGetCredentialStatusResponseCallback");

    Callback::Callback<DoorLockClusterGetCredentialStatusResponseCallback> * cb =
        Callback::Callback<DoorLockClusterGetCredentialStatusResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, credentialExists, userIndex, nextCredentialIndex);
    return true;
}

bool emberAfDoorLockClusterGetUserResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint16_t userIndex,
                                                   chip::CharSpan userName, uint32_t userUniqueId, uint8_t userStatus,
                                                   uint8_t userType, uint8_t credentialRule,
                                                   /* TYPE WARNING: array array defaults to */ uint8_t * credentials,
                                                   chip::FabricIndex creatorFabricIndex, chip::FabricIndex lastModifiedFabricIndex,
                                                   uint16_t nextUserIndex)
{
    ChipLogProgress(Zcl, "GetUserResponse:");
    ChipLogProgress(Zcl, "  userIndex: %" PRIu16 "", userIndex);
    ChipLogProgress(Zcl, "  userName: %.*s", static_cast<int>(userName.size()), userName.data());
    ChipLogProgress(Zcl, "  userUniqueId: %" PRIu32 "", userUniqueId);
    ChipLogProgress(Zcl, "  userStatus: %" PRIu8 "", userStatus);
    ChipLogProgress(Zcl, "  userType: %" PRIu8 "", userType);
    ChipLogProgress(Zcl, "  credentialRule: %" PRIu8 "", credentialRule);
    ChipLogProgress(Zcl, "  credentials: %p", credentials);
    ChipLogProgress(Zcl, "  creatorFabricIndex: %" PRIu8 "", creatorFabricIndex);
    ChipLogProgress(Zcl, "  lastModifiedFabricIndex: %" PRIu8 "", lastModifiedFabricIndex);
    ChipLogProgress(Zcl, "  nextUserIndex: %" PRIu16 "", nextUserIndex);

    GET_CLUSTER_RESPONSE_CALLBACKS("DoorLockClusterGetUserResponseCallback");

    Callback::Callback<DoorLockClusterGetUserResponseCallback> * cb =
        Callback::Callback<DoorLockClusterGetUserResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, userIndex, userName, userUniqueId, userStatus, userType, credentialRule, credentials,
              creatorFabricIndex, lastModifiedFabricIndex, nextUserIndex);
    return true;
}

bool emberAfDoorLockClusterSetCredentialResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                         uint16_t userIndex, uint16_t nextCredentialIndex)
{
    ChipLogProgress(Zcl, "SetCredentialResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  userIndex: %" PRIu16 "", userIndex);
    ChipLogProgress(Zcl, "  nextCredentialIndex: %" PRIu16 "", nextCredentialIndex);

    GET_CLUSTER_RESPONSE_CALLBACKS("DoorLockClusterSetCredentialResponseCallback");

    Callback::Callback<DoorLockClusterSetCredentialResponseCallback> * cb =
        Callback::Callback<DoorLockClusterSetCredentialResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, userIndex, nextCredentialIndex);
    return true;
}

bool emberAfGeneralCommissioningClusterArmFailSafeResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                   uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "ArmFailSafeResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("GeneralCommissioningClusterArmFailSafeResponseCallback");

    Callback::Callback<GeneralCommissioningClusterArmFailSafeResponseCallback> * cb =
        Callback::Callback<GeneralCommissioningClusterArmFailSafeResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfGeneralCommissioningClusterCommissioningCompleteResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                             uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "CommissioningCompleteResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("GeneralCommissioningClusterCommissioningCompleteResponseCallback");

    Callback::Callback<GeneralCommissioningClusterCommissioningCompleteResponseCallback> * cb =
        Callback::Callback<GeneralCommissioningClusterCommissioningCompleteResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfGeneralCommissioningClusterSetRegulatoryConfigResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                           uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "SetRegulatoryConfigResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("GeneralCommissioningClusterSetRegulatoryConfigResponseCallback");

    Callback::Callback<GeneralCommissioningClusterSetRegulatoryConfigResponseCallback> * cb =
        Callback::Callback<GeneralCommissioningClusterSetRegulatoryConfigResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfGroupKeyManagementClusterKeySetReadAllIndicesResponseCallback(
    EndpointId endpoint, app::CommandSender * commandObj, /* TYPE WARNING: array array defaults to */ uint8_t * groupKeySetIDs)
{
    ChipLogProgress(Zcl, "KeySetReadAllIndicesResponse:");
    ChipLogProgress(Zcl, "  groupKeySetIDs: %p", groupKeySetIDs);

    GET_CLUSTER_RESPONSE_CALLBACKS("GroupKeyManagementClusterKeySetReadAllIndicesResponseCallback");

    Callback::Callback<GroupKeyManagementClusterKeySetReadAllIndicesResponseCallback> * cb =
        Callback::Callback<GroupKeyManagementClusterKeySetReadAllIndicesResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, groupKeySetIDs);
    return true;
}

bool emberAfGroupKeyManagementClusterKeySetReadResponseCallback(
    EndpointId endpoint, app::CommandSender * commandObj,
    chip::app::Clusters::GroupKeyManagement::Structs::GroupKeySet::DecodableType groupKeySet)
{
    ChipLogProgress(Zcl, "KeySetReadResponse:");
    ChipLogProgress(Zcl, "  groupKeySet: Not sure how to log struct GroupKeySet");

    GET_CLUSTER_RESPONSE_CALLBACKS("GroupKeyManagementClusterKeySetReadResponseCallback");

    Callback::Callback<GroupKeyManagementClusterKeySetReadResponseCallback> * cb =
        Callback::Callback<GroupKeyManagementClusterKeySetReadResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, GroupKeySet());
    return true;
}

bool emberAfGroupsClusterAddGroupResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                  uint16_t groupId)
{
    ChipLogProgress(Zcl, "AddGroupResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);

    GET_CLUSTER_RESPONSE_CALLBACKS("GroupsClusterAddGroupResponseCallback");

    Callback::Callback<GroupsClusterAddGroupResponseCallback> * cb =
        Callback::Callback<GroupsClusterAddGroupResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId);
    return true;
}

bool emberAfGroupsClusterGetGroupMembershipResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t capacity,
                                                            /* TYPE WARNING: array array defaults to */ uint8_t * groupList)
{
    ChipLogProgress(Zcl, "GetGroupMembershipResponse:");
    ChipLogProgress(Zcl, "  capacity: %" PRIu8 "", capacity);
    ChipLogProgress(Zcl, "  groupList: %p", groupList);

    GET_CLUSTER_RESPONSE_CALLBACKS("GroupsClusterGetGroupMembershipResponseCallback");

    Callback::Callback<GroupsClusterGetGroupMembershipResponseCallback> * cb =
        Callback::Callback<GroupsClusterGetGroupMembershipResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, capacity, groupList);
    return true;
}

bool emberAfGroupsClusterRemoveGroupResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                     uint16_t groupId)
{
    ChipLogProgress(Zcl, "RemoveGroupResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);

    GET_CLUSTER_RESPONSE_CALLBACKS("GroupsClusterRemoveGroupResponseCallback");

    Callback::Callback<GroupsClusterRemoveGroupResponseCallback> * cb =
        Callback::Callback<GroupsClusterRemoveGroupResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId);
    return true;
}

bool emberAfGroupsClusterViewGroupResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                   uint16_t groupId, chip::CharSpan groupName)
{
    ChipLogProgress(Zcl, "ViewGroupResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);
    ChipLogProgress(Zcl, "  groupName: %.*s", static_cast<int>(groupName.size()), groupName.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("GroupsClusterViewGroupResponseCallback");

    Callback::Callback<GroupsClusterViewGroupResponseCallback> * cb =
        Callback::Callback<GroupsClusterViewGroupResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId, groupName);
    return true;
}

bool emberAfIdentifyClusterIdentifyQueryResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint16_t timeout)
{
    ChipLogProgress(Zcl, "IdentifyQueryResponse:");
    ChipLogProgress(Zcl, "  timeout: %" PRIu16 "", timeout);

    GET_CLUSTER_RESPONSE_CALLBACKS("IdentifyClusterIdentifyQueryResponseCallback");

    Callback::Callback<IdentifyClusterIdentifyQueryResponseCallback> * cb =
        Callback::Callback<IdentifyClusterIdentifyQueryResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, timeout);
    return true;
}

bool emberAfKeypadInputClusterSendKeyResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status)
{
    ChipLogProgress(Zcl, "SendKeyResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);

    GET_CLUSTER_RESPONSE_CALLBACKS("KeypadInputClusterSendKeyResponseCallback");

    Callback::Callback<KeypadInputClusterSendKeyResponseCallback> * cb =
        Callback::Callback<KeypadInputClusterSendKeyResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status);
    return true;
}

bool emberAfMediaPlaybackClusterPlaybackResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status)
{
    ChipLogProgress(Zcl, "PlaybackResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);

    GET_CLUSTER_RESPONSE_CALLBACKS("MediaPlaybackClusterPlaybackResponseCallback");

    Callback::Callback<MediaPlaybackClusterPlaybackResponseCallback> * cb =
        Callback::Callback<MediaPlaybackClusterPlaybackResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status);
    return true;
}

bool emberAfNetworkCommissioningClusterConnectNetworkResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                      uint8_t NetworkingStatus, chip::CharSpan DebugText,
                                                                      int32_t ErrorValue)
{
    ChipLogProgress(Zcl, "ConnectNetworkResponse:");
    ChipLogProgress(Zcl, "  NetworkingStatus: %" PRIu8 "", NetworkingStatus);
    ChipLogProgress(Zcl, "  DebugText: %.*s", static_cast<int>(DebugText.size()), DebugText.data());
    ChipLogProgress(Zcl, "  ErrorValue: %" PRId32 "", ErrorValue);

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterConnectNetworkResponseCallback");

    Callback::Callback<NetworkCommissioningClusterConnectNetworkResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterConnectNetworkResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, NetworkingStatus, DebugText, ErrorValue);
    return true;
}

bool emberAfNetworkCommissioningClusterNetworkConfigResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                     uint8_t NetworkingStatus, chip::CharSpan DebugText)
{
    ChipLogProgress(Zcl, "NetworkConfigResponse:");
    ChipLogProgress(Zcl, "  NetworkingStatus: %" PRIu8 "", NetworkingStatus);
    ChipLogProgress(Zcl, "  DebugText: %.*s", static_cast<int>(DebugText.size()), DebugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterNetworkConfigResponseCallback");

    Callback::Callback<NetworkCommissioningClusterNetworkConfigResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterNetworkConfigResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, NetworkingStatus, DebugText);
    return true;
}

bool emberAfNetworkCommissioningClusterScanNetworksResponseCallback(
    EndpointId endpoint, app::CommandSender * commandObj, uint8_t NetworkingStatus, chip::CharSpan DebugText,
    /* TYPE WARNING: array array defaults to */ uint8_t * WiFiScanResults,
    /* TYPE WARNING: array array defaults to */ uint8_t * ThreadScanResults)
{
    ChipLogProgress(Zcl, "ScanNetworksResponse:");
    ChipLogProgress(Zcl, "  NetworkingStatus: %" PRIu8 "", NetworkingStatus);
    ChipLogProgress(Zcl, "  DebugText: %.*s", static_cast<int>(DebugText.size()), DebugText.data());
    ChipLogProgress(Zcl, "  WiFiScanResults: %p", WiFiScanResults);
    ChipLogProgress(Zcl, "  ThreadScanResults: %p", ThreadScanResults);

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterScanNetworksResponseCallback");

    Callback::Callback<NetworkCommissioningClusterScanNetworksResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterScanNetworksResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, NetworkingStatus, DebugText, WiFiScanResults, ThreadScanResults);
    return true;
}

bool emberAfOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                        uint8_t action, uint32_t delayedActionTime)
{
    ChipLogProgress(Zcl, "ApplyUpdateResponse:");
    ChipLogProgress(Zcl, "  action: %" PRIu8 "", action);
    ChipLogProgress(Zcl, "  delayedActionTime: %" PRIu32 "", delayedActionTime);

    GET_CLUSTER_RESPONSE_CALLBACKS("OtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback");

    Callback::Callback<OtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback> * cb =
        Callback::Callback<OtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, action, delayedActionTime);
    return true;
}

bool emberAfOtaSoftwareUpdateProviderClusterQueryImageResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                       uint8_t status, uint32_t delayedActionTime,
                                                                       chip::CharSpan imageURI, uint32_t softwareVersion,
                                                                       chip::CharSpan softwareVersionString,
                                                                       chip::ByteSpan updateToken, bool userConsentNeeded,
                                                                       chip::ByteSpan metadataForRequestor)
{
    ChipLogProgress(Zcl, "QueryImageResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  delayedActionTime: %" PRIu32 "", delayedActionTime);
    ChipLogProgress(Zcl, "  imageURI: %.*s", static_cast<int>(imageURI.size()), imageURI.data());
    ChipLogProgress(Zcl, "  softwareVersion: %" PRIu32 "", softwareVersion);
    ChipLogProgress(Zcl, "  softwareVersionString: %.*s", static_cast<int>(softwareVersionString.size()),
                    softwareVersionString.data());
    ChipLogProgress(Zcl, "  updateToken: %zu", updateToken.size());
    ChipLogProgress(Zcl, "  userConsentNeeded: %d", userConsentNeeded);
    ChipLogProgress(Zcl, "  metadataForRequestor: %zu", metadataForRequestor.size());

    GET_CLUSTER_RESPONSE_CALLBACKS("OtaSoftwareUpdateProviderClusterQueryImageResponseCallback");

    Callback::Callback<OtaSoftwareUpdateProviderClusterQueryImageResponseCallback> * cb =
        Callback::Callback<OtaSoftwareUpdateProviderClusterQueryImageResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, delayedActionTime, imageURI, softwareVersion, softwareVersionString, updateToken,
              userConsentNeeded, metadataForRequestor);
    return true;
}

bool emberAfOperationalCredentialsClusterAttestationResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                     chip::ByteSpan AttestationElements, chip::ByteSpan Signature)
{
    ChipLogProgress(Zcl, "AttestationResponse:");
    ChipLogProgress(Zcl, "  AttestationElements: %zu", AttestationElements.size());
    ChipLogProgress(Zcl, "  Signature: %zu", Signature.size());

    GET_CLUSTER_RESPONSE_CALLBACKS("OperationalCredentialsClusterAttestationResponseCallback");

    Callback::Callback<OperationalCredentialsClusterAttestationResponseCallback> * cb =
        Callback::Callback<OperationalCredentialsClusterAttestationResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, AttestationElements, Signature);
    return true;
}

bool emberAfOperationalCredentialsClusterCertificateChainResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                          chip::ByteSpan Certificate)
{
    ChipLogProgress(Zcl, "CertificateChainResponse:");
    ChipLogProgress(Zcl, "  Certificate: %zu", Certificate.size());

    GET_CLUSTER_RESPONSE_CALLBACKS("OperationalCredentialsClusterCertificateChainResponseCallback");

    Callback::Callback<OperationalCredentialsClusterCertificateChainResponseCallback> * cb =
        Callback::Callback<OperationalCredentialsClusterCertificateChainResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, Certificate);
    return true;
}

bool emberAfOperationalCredentialsClusterNOCResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                             uint8_t StatusCode, uint8_t FabricIndex, chip::CharSpan DebugText)
{
    ChipLogProgress(Zcl, "NOCResponse:");
    ChipLogProgress(Zcl, "  StatusCode: %" PRIu8 "", StatusCode);
    ChipLogProgress(Zcl, "  FabricIndex: %" PRIu8 "", FabricIndex);
    ChipLogProgress(Zcl, "  DebugText: %.*s", static_cast<int>(DebugText.size()), DebugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("OperationalCredentialsClusterNOCResponseCallback");

    Callback::Callback<OperationalCredentialsClusterNOCResponseCallback> * cb =
        Callback::Callback<OperationalCredentialsClusterNOCResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, StatusCode, FabricIndex, DebugText);
    return true;
}

bool emberAfOperationalCredentialsClusterOpCSRResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                               chip::ByteSpan NOCSRElements, chip::ByteSpan AttestationSignature)
{
    ChipLogProgress(Zcl, "OpCSRResponse:");
    ChipLogProgress(Zcl, "  NOCSRElements: %zu", NOCSRElements.size());
    ChipLogProgress(Zcl, "  AttestationSignature: %zu", AttestationSignature.size());

    GET_CLUSTER_RESPONSE_CALLBACKS("OperationalCredentialsClusterOpCSRResponseCallback");

    Callback::Callback<OperationalCredentialsClusterOpCSRResponseCallback> * cb =
        Callback::Callback<OperationalCredentialsClusterOpCSRResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, NOCSRElements, AttestationSignature);
    return true;
}

bool emberAfScenesClusterAddSceneResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                  uint16_t groupId, uint8_t sceneId)
{
    ChipLogProgress(Zcl, "AddSceneResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);
    ChipLogProgress(Zcl, "  sceneId: %" PRIu8 "", sceneId);

    GET_CLUSTER_RESPONSE_CALLBACKS("ScenesClusterAddSceneResponseCallback");

    Callback::Callback<ScenesClusterAddSceneResponseCallback> * cb =
        Callback::Callback<ScenesClusterAddSceneResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId, sceneId);
    return true;
}

bool emberAfScenesClusterGetSceneMembershipResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                            uint8_t capacity, uint16_t groupId, uint8_t sceneCount,
                                                            /* TYPE WARNING: array array defaults to */ uint8_t * sceneList)
{
    ChipLogProgress(Zcl, "GetSceneMembershipResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  capacity: %" PRIu8 "", capacity);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);
    ChipLogProgress(Zcl, "  sceneCount: %" PRIu8 "", sceneCount);
    ChipLogProgress(Zcl, "  sceneList: %p", sceneList);

    GET_CLUSTER_RESPONSE_CALLBACKS("ScenesClusterGetSceneMembershipResponseCallback");

    Callback::Callback<ScenesClusterGetSceneMembershipResponseCallback> * cb =
        Callback::Callback<ScenesClusterGetSceneMembershipResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, capacity, groupId, sceneCount, sceneList);
    return true;
}

bool emberAfScenesClusterRemoveAllScenesResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                         uint16_t groupId)
{
    ChipLogProgress(Zcl, "RemoveAllScenesResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);

    GET_CLUSTER_RESPONSE_CALLBACKS("ScenesClusterRemoveAllScenesResponseCallback");

    Callback::Callback<ScenesClusterRemoveAllScenesResponseCallback> * cb =
        Callback::Callback<ScenesClusterRemoveAllScenesResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId);
    return true;
}

bool emberAfScenesClusterRemoveSceneResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                     uint16_t groupId, uint8_t sceneId)
{
    ChipLogProgress(Zcl, "RemoveSceneResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);
    ChipLogProgress(Zcl, "  sceneId: %" PRIu8 "", sceneId);

    GET_CLUSTER_RESPONSE_CALLBACKS("ScenesClusterRemoveSceneResponseCallback");

    Callback::Callback<ScenesClusterRemoveSceneResponseCallback> * cb =
        Callback::Callback<ScenesClusterRemoveSceneResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId, sceneId);
    return true;
}

bool emberAfScenesClusterStoreSceneResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                    uint16_t groupId, uint8_t sceneId)
{
    ChipLogProgress(Zcl, "StoreSceneResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);
    ChipLogProgress(Zcl, "  sceneId: %" PRIu8 "", sceneId);

    GET_CLUSTER_RESPONSE_CALLBACKS("ScenesClusterStoreSceneResponseCallback");

    Callback::Callback<ScenesClusterStoreSceneResponseCallback> * cb =
        Callback::Callback<ScenesClusterStoreSceneResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId, sceneId);
    return true;
}

bool emberAfScenesClusterViewSceneResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                   uint16_t groupId, uint8_t sceneId, uint16_t transitionTime,
                                                   chip::CharSpan sceneName,
                                                   /* TYPE WARNING: array array defaults to */ uint8_t * extensionFieldSets)
{
    ChipLogProgress(Zcl, "ViewSceneResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);
    ChipLogProgress(Zcl, "  sceneId: %" PRIu8 "", sceneId);
    ChipLogProgress(Zcl, "  transitionTime: %" PRIu16 "", transitionTime);
    ChipLogProgress(Zcl, "  sceneName: %.*s", static_cast<int>(sceneName.size()), sceneName.data());
    ChipLogProgress(Zcl, "  extensionFieldSets: %p", extensionFieldSets);

    GET_CLUSTER_RESPONSE_CALLBACKS("ScenesClusterViewSceneResponseCallback");

    Callback::Callback<ScenesClusterViewSceneResponseCallback> * cb =
        Callback::Callback<ScenesClusterViewSceneResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId, sceneId, transitionTime, sceneName, extensionFieldSets);
    return true;
}

bool emberAfTargetNavigatorClusterNavigateTargetResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                 uint8_t status, chip::CharSpan data)
{
    ChipLogProgress(Zcl, "NavigateTargetResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  data: %.*s", static_cast<int>(data.size()), data.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("TargetNavigatorClusterNavigateTargetResponseCallback");

    Callback::Callback<TargetNavigatorClusterNavigateTargetResponseCallback> * cb =
        Callback::Callback<TargetNavigatorClusterNavigateTargetResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, data);
    return true;
}

bool emberAfTestClusterClusterBooleanResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, bool value)
{
    ChipLogProgress(Zcl, "BooleanResponse:");
    ChipLogProgress(Zcl, "  value: %d", value);

    GET_CLUSTER_RESPONSE_CALLBACKS("TestClusterClusterBooleanResponseCallback");

    Callback::Callback<TestClusterClusterBooleanResponseCallback> * cb =
        Callback::Callback<TestClusterClusterBooleanResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, value);
    return true;
}

bool emberAfTestClusterClusterSimpleStructResponseCallback(
    EndpointId endpoint, app::CommandSender * commandObj,
    chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType arg1)
{
    ChipLogProgress(Zcl, "SimpleStructResponse:");
    ChipLogProgress(Zcl, "  arg1: Not sure how to log struct SimpleStruct");

    GET_CLUSTER_RESPONSE_CALLBACKS("TestClusterClusterSimpleStructResponseCallback");

    Callback::Callback<TestClusterClusterSimpleStructResponseCallback> * cb =
        Callback::Callback<TestClusterClusterSimpleStructResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, SimpleStruct());
    return true;
}

bool emberAfTestClusterClusterTestAddArgumentsResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                               uint8_t returnValue)
{
    ChipLogProgress(Zcl, "TestAddArgumentsResponse:");
    ChipLogProgress(Zcl, "  returnValue: %" PRIu8 "", returnValue);

    GET_CLUSTER_RESPONSE_CALLBACKS("TestClusterClusterTestAddArgumentsResponseCallback");

    Callback::Callback<TestClusterClusterTestAddArgumentsResponseCallback> * cb =
        Callback::Callback<TestClusterClusterTestAddArgumentsResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, returnValue);
    return true;
}

bool emberAfTestClusterClusterTestEnumsResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, chip::VendorId arg1,
                                                        uint8_t arg2)
{
    ChipLogProgress(Zcl, "TestEnumsResponse:");
    ChipLogProgress(Zcl, "  arg1: %" PRIu16 "", arg1);
    ChipLogProgress(Zcl, "  arg2: %" PRIu8 "", arg2);

    GET_CLUSTER_RESPONSE_CALLBACKS("TestClusterClusterTestEnumsResponseCallback");

    Callback::Callback<TestClusterClusterTestEnumsResponseCallback> * cb =
        Callback::Callback<TestClusterClusterTestEnumsResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, arg1, arg2);
    return true;
}

bool emberAfTestClusterClusterTestListInt8UReverseResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                   /* TYPE WARNING: array array defaults to */ uint8_t * arg1)
{
    ChipLogProgress(Zcl, "TestListInt8UReverseResponse:");
    ChipLogProgress(Zcl, "  arg1: %p", arg1);

    GET_CLUSTER_RESPONSE_CALLBACKS("TestClusterClusterTestListInt8UReverseResponseCallback");

    Callback::Callback<TestClusterClusterTestListInt8UReverseResponseCallback> * cb =
        Callback::Callback<TestClusterClusterTestListInt8UReverseResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, arg1);
    return true;
}

bool emberAfTestClusterClusterTestNullableOptionalResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                   bool wasPresent, bool wasNull, uint8_t value,
                                                                   uint8_t originalValue)
{
    ChipLogProgress(Zcl, "TestNullableOptionalResponse:");
    ChipLogProgress(Zcl, "  wasPresent: %d", wasPresent);
    ChipLogProgress(Zcl, "  wasNull: %d", wasNull);
    ChipLogProgress(Zcl, "  value: %" PRIu8 "", value);
    ChipLogProgress(Zcl, "  originalValue: %" PRIu8 "", originalValue);

    GET_CLUSTER_RESPONSE_CALLBACKS("TestClusterClusterTestNullableOptionalResponseCallback");

    Callback::Callback<TestClusterClusterTestNullableOptionalResponseCallback> * cb =
        Callback::Callback<TestClusterClusterTestNullableOptionalResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, wasPresent, wasNull, value, originalValue);
    return true;
}

bool emberAfTestClusterClusterTestSpecificResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                           uint8_t returnValue)
{
    ChipLogProgress(Zcl, "TestSpecificResponse:");
    ChipLogProgress(Zcl, "  returnValue: %" PRIu8 "", returnValue);

    GET_CLUSTER_RESPONSE_CALLBACKS("TestClusterClusterTestSpecificResponseCallback");

    Callback::Callback<TestClusterClusterTestSpecificResponseCallback> * cb =
        Callback::Callback<TestClusterClusterTestSpecificResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, returnValue);
    return true;
}

bool emberAfThermostatClusterGetRelayStatusLogResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                               uint16_t timeOfDay, uint16_t relayStatus, int16_t localTemperature,
                                                               uint8_t humidityInPercentage, int16_t setpoint,
                                                               uint16_t unreadEntries)
{
    ChipLogProgress(Zcl, "GetRelayStatusLogResponse:");
    ChipLogProgress(Zcl, "  timeOfDay: %" PRIu16 "", timeOfDay);
    ChipLogProgress(Zcl, "  relayStatus: %" PRIu16 "", relayStatus);
    ChipLogProgress(Zcl, "  localTemperature: %" PRId16 "", localTemperature);
    ChipLogProgress(Zcl, "  humidityInPercentage: %" PRIu8 "", humidityInPercentage);
    ChipLogProgress(Zcl, "  setpoint: %" PRId16 "", setpoint);
    ChipLogProgress(Zcl, "  unreadEntries: %" PRIu16 "", unreadEntries);

    GET_CLUSTER_RESPONSE_CALLBACKS("ThermostatClusterGetRelayStatusLogResponseCallback");

    Callback::Callback<ThermostatClusterGetRelayStatusLogResponseCallback> * cb =
        Callback::Callback<ThermostatClusterGetRelayStatusLogResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, timeOfDay, relayStatus, localTemperature, humidityInPercentage, setpoint, unreadEntries);
    return true;
}

bool emberAfThermostatClusterGetWeeklyScheduleResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                               uint8_t numberOfTransitionsForSequence, uint8_t dayOfWeekForSequence,
                                                               uint8_t modeForSequence,
                                                               /* TYPE WARNING: array array defaults to */ uint8_t * payload)
{
    ChipLogProgress(Zcl, "GetWeeklyScheduleResponse:");
    ChipLogProgress(Zcl, "  numberOfTransitionsForSequence: %" PRIu8 "", numberOfTransitionsForSequence);
    ChipLogProgress(Zcl, "  dayOfWeekForSequence: %" PRIu8 "", dayOfWeekForSequence);
    ChipLogProgress(Zcl, "  modeForSequence: %" PRIu8 "", modeForSequence);
    ChipLogProgress(Zcl, "  payload: %p", payload);

    GET_CLUSTER_RESPONSE_CALLBACKS("ThermostatClusterGetWeeklyScheduleResponseCallback");

    Callback::Callback<ThermostatClusterGetWeeklyScheduleResponseCallback> * cb =
        Callback::Callback<ThermostatClusterGetWeeklyScheduleResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, numberOfTransitionsForSequence, dayOfWeekForSequence, modeForSequence, payload);
    return true;
}
