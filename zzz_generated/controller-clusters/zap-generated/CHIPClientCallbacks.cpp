/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include <zap-generated/CHIPClientCallbacks.h>

#include <cinttypes>

#include <app-common/zap-generated/enums.h>
#include <app/Command.h>
#include <app/util/CHIPDeviceCallbacksMgr.h>
#include <app/util/af-enums.h>
#include <app/util/af.h>
#include <app/util/attribute-list-byte-span.h>
#include <app/util/basic-types.h>
#include <lib/core/CHIPEncoding.h>
#include <lib/support/SafeInt.h>
#include <lib/support/TypeTraits.h>
#include <lib/support/logging/CHIPLogging.h>

using namespace ::chip;
using namespace ::chip::app::DataModel;
using namespace ::chip::app::List;

namespace {
[[maybe_unused]] constexpr uint16_t kByteSpanSizeLengthInBytes = 2;
} // namespace

#define CHECK_STATUS_WITH_RETVAL(error, retval)                                                                                    \
    if (CHIP_NO_ERROR != error)                                                                                                    \
    {                                                                                                                              \
        ChipLogError(Zcl, "CHECK_STATUS %s", ErrorStr(error));                                                                     \
        if (onFailureCallback != nullptr)                                                                                          \
        {                                                                                                                          \
            Callback::Callback<DefaultFailureCallback> * cb =                                                                      \
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);                                     \
            cb->mCall(cb->mContext, static_cast<uint8_t>(EMBER_ZCL_STATUS_INVALID_VALUE));                                         \
        }                                                                                                                          \
        return retval;                                                                                                             \
    }

#define CHECK_STATUS(error) CHECK_STATUS_WITH_RETVAL(error, true)
#define CHECK_STATUS_VOID(error) CHECK_STATUS_WITH_RETVAL(error, )

#define CHECK_MESSAGE_LENGTH_WITH_RETVAL(value, retval)                                                                            \
    if (!CanCastTo<uint16_t>(value))                                                                                               \
    {                                                                                                                              \
        ChipLogError(Zcl, "CHECK_MESSAGE_LENGTH expects a uint16_t value, got: %d", value);                                        \
        if (onFailureCallback != nullptr)                                                                                          \
        {                                                                                                                          \
            Callback::Callback<DefaultFailureCallback> * cb =                                                                      \
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);                                     \
            cb->mCall(cb->mContext, static_cast<uint8_t>(EMBER_ZCL_STATUS_INVALID_VALUE));                                         \
        }                                                                                                                          \
        return retval;                                                                                                             \
    }                                                                                                                              \
                                                                                                                                   \
    if (messageLen < value)                                                                                                        \
    {                                                                                                                              \
        ChipLogError(Zcl, "Unexpected response length: %d", messageLen);                                                           \
        if (onFailureCallback != nullptr)                                                                                          \
        {                                                                                                                          \
            Callback::Callback<DefaultFailureCallback> * cb =                                                                      \
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);                                     \
            cb->mCall(cb->mContext, static_cast<uint8_t>(EMBER_ZCL_STATUS_INVALID_VALUE));                                         \
        }                                                                                                                          \
        return retval;                                                                                                             \
    }                                                                                                                              \
                                                                                                                                   \
    messageLen = static_cast<uint16_t>(messageLen - static_cast<uint16_t>(value));

#define CHECK_MESSAGE_LENGTH(value) CHECK_MESSAGE_LENGTH_WITH_RETVAL(value, true)
#define CHECK_MESSAGE_LENGTH_VOID(value) CHECK_MESSAGE_LENGTH_WITH_RETVAL(value, )

#define GET_RESPONSE_CALLBACKS(name)                                                                                               \
    Callback::Cancelable * onSuccessCallback = nullptr;                                                                            \
    Callback::Cancelable * onFailureCallback = nullptr;                                                                            \
    NodeId sourceId                          = emberAfCurrentCommand()->SourceNodeId();                                            \
    uint8_t sequenceNumber                   = emberAfCurrentCommand()->seqNum;                                                    \
    CHIP_ERROR err = gCallbacks.GetResponseCallback(sourceId, sequenceNumber, &onSuccessCallback, &onFailureCallback);             \
                                                                                                                                   \
    if (CHIP_NO_ERROR != err)                                                                                                      \
    {                                                                                                                              \
        if (onSuccessCallback == nullptr)                                                                                          \
        {                                                                                                                          \
            ChipLogDetail(Zcl, "%s: Missing success callback", name);                                                              \
        }                                                                                                                          \
                                                                                                                                   \
        if (onFailureCallback == nullptr)                                                                                          \
        {                                                                                                                          \
            ChipLogDetail(Zcl, "%s: Missing failure callback", name);                                                              \
        }                                                                                                                          \
                                                                                                                                   \
        return true;                                                                                                               \
    }

#define GET_CLUSTER_RESPONSE_CALLBACKS(name)                                                                                       \
    Callback::Cancelable * onSuccessCallback = nullptr;                                                                            \
    Callback::Cancelable * onFailureCallback = nullptr;                                                                            \
    NodeId sourceIdentifier                  = reinterpret_cast<NodeId>(commandObj);                                               \
    /* #6559: Currently, we only have one commands for the IMInvokeCommands and to a device, so the seqNum is always set to 0. */  \
    CHIP_ERROR err = gCallbacks.GetResponseCallback(sourceIdentifier, 0, &onSuccessCallback, &onFailureCallback);                  \
                                                                                                                                   \
    if (CHIP_NO_ERROR != err)                                                                                                      \
    {                                                                                                                              \
        if (onSuccessCallback == nullptr)                                                                                          \
        {                                                                                                                          \
            ChipLogDetail(Zcl, "%s: Missing success callback", name);                                                              \
        }                                                                                                                          \
                                                                                                                                   \
        if (onFailureCallback == nullptr)                                                                                          \
        {                                                                                                                          \
            ChipLogDetail(Zcl, "%s: Missing failure callback", name);                                                              \
        }                                                                                                                          \
                                                                                                                                   \
        return true;                                                                                                               \
    }

// Singleton instance of the callbacks manager
app::CHIPDeviceCallbacksMgr & gCallbacks = app::CHIPDeviceCallbacksMgr::GetInstance();

void AccessControlClusterAclListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<AccessControlAclListAttributeCallback> * cb =
        Callback::Callback<AccessControlAclListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void AccessControlClusterExtensionListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::ExtensionEntry::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<AccessControlExtensionListAttributeCallback> * cb =
        Callback::Callback<AccessControlExtensionListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ApplicationLauncherClusterApplicationLauncherListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                          Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<uint16_t> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ApplicationLauncherApplicationLauncherListListAttributeCallback> * cb =
        Callback::Callback<ApplicationLauncherApplicationLauncherListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void AudioOutputClusterAudioOutputListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<AudioOutputAudioOutputListListAttributeCallback> * cb =
        Callback::Callback<AudioOutputAudioOutputListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void BridgedActionsClusterActionListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::ActionStruct::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<BridgedActionsActionListListAttributeCallback> * cb =
        Callback::Callback<BridgedActionsActionListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void BridgedActionsClusterEndpointListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::EndpointListStruct::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<BridgedActionsEndpointListListAttributeCallback> * cb =
        Callback::Callback<BridgedActionsEndpointListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ContentLauncherClusterAcceptsHeaderListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::ByteSpan> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ContentLauncherAcceptsHeaderListListAttributeCallback> * cb =
        Callback::Callback<ContentLauncherAcceptsHeaderListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ContentLauncherClusterSupportedStreamingTypesListAttributeFilter(TLV::TLVReader * tlvData,
                                                                      Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::ContentLauncher::ContentLaunchStreamingType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ContentLauncherSupportedStreamingTypesListAttributeCallback> * cb =
        Callback::Callback<ContentLauncherSupportedStreamingTypesListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void DescriptorClusterDeviceListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<DescriptorDeviceListListAttributeCallback> * cb =
        Callback::Callback<DescriptorDeviceListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void DescriptorClusterServerListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::ClusterId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<DescriptorServerListListAttributeCallback> * cb =
        Callback::Callback<DescriptorServerListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void DescriptorClusterClientListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::ClusterId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<DescriptorClientListListAttributeCallback> * cb =
        Callback::Callback<DescriptorClientListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void DescriptorClusterPartsListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::EndpointId> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<DescriptorPartsListListAttributeCallback> * cb =
        Callback::Callback<DescriptorPartsListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void FixedLabelClusterLabelListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::FixedLabel::Structs::LabelStruct::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<FixedLabelLabelListListAttributeCallback> * cb =
        Callback::Callback<FixedLabelLabelListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GeneralCommissioningClusterBasicCommissioningInfoListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                              Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<
        chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfoType::DecodableType>
        list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GeneralCommissioningBasicCommissioningInfoListListAttributeCallback> * cb =
        Callback::Callback<GeneralCommissioningBasicCommissioningInfoListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GeneralDiagnosticsClusterNetworkInterfacesListAttributeFilter(TLV::TLVReader * tlvData,
                                                                   Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GeneralDiagnosticsNetworkInterfacesListAttributeCallback> * cb =
        Callback::Callback<GeneralDiagnosticsNetworkInterfacesListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GeneralDiagnosticsClusterActiveHardwareFaultsListAttributeFilter(TLV::TLVReader * tlvData,
                                                                      Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<uint8_t> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GeneralDiagnosticsActiveHardwareFaultsListAttributeCallback> * cb =
        Callback::Callback<GeneralDiagnosticsActiveHardwareFaultsListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GeneralDiagnosticsClusterActiveRadioFaultsListAttributeFilter(TLV::TLVReader * tlvData,
                                                                   Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<uint8_t> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GeneralDiagnosticsActiveRadioFaultsListAttributeCallback> * cb =
        Callback::Callback<GeneralDiagnosticsActiveRadioFaultsListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GeneralDiagnosticsClusterActiveNetworkFaultsListAttributeFilter(TLV::TLVReader * tlvData,
                                                                     Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<uint8_t> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GeneralDiagnosticsActiveNetworkFaultsListAttributeCallback> * cb =
        Callback::Callback<GeneralDiagnosticsActiveNetworkFaultsListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GroupKeyManagementClusterGroupsListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupState::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GroupKeyManagementGroupsListAttributeCallback> * cb =
        Callback::Callback<GroupKeyManagementGroupsListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void GroupKeyManagementClusterGroupKeysListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupKey::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<GroupKeyManagementGroupKeysListAttributeCallback> * cb =
        Callback::Callback<GroupKeyManagementGroupKeysListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void MediaInputClusterMediaInputListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<MediaInputMediaInputListListAttributeCallback> * cb =
        Callback::Callback<MediaInputMediaInputListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ModeSelectClusterSupportedModesListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ModeSelectSupportedModesListAttributeCallback> * cb =
        Callback::Callback<ModeSelectSupportedModesListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void OperationalCredentialsClusterFabricsListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<OperationalCredentialsFabricsListListAttributeCallback> * cb =
        Callback::Callback<OperationalCredentialsFabricsListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void OperationalCredentialsClusterTrustedRootCertificatesListAttributeFilter(TLV::TLVReader * tlvData,
                                                                             Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::ByteSpan> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<OperationalCredentialsTrustedRootCertificatesListAttributeCallback> * cb =
        Callback::Callback<OperationalCredentialsTrustedRootCertificatesListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void PowerSourceClusterActiveBatteryFaultsListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<uint8_t> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<PowerSourceActiveBatteryFaultsListAttributeCallback> * cb =
        Callback::Callback<PowerSourceActiveBatteryFaultsListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void PowerSourceConfigurationClusterSourcesListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<uint8_t> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<PowerSourceConfigurationSourcesListAttributeCallback> * cb =
        Callback::Callback<PowerSourceConfigurationSourcesListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void SoftwareDiagnosticsClusterThreadMetricsListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<SoftwareDiagnosticsThreadMetricsListAttributeCallback> * cb =
        Callback::Callback<SoftwareDiagnosticsThreadMetricsListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void TvChannelClusterTvChannelListListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::TvChannel::Structs::TvChannelInfo::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<TvChannelTvChannelListListAttributeCallback> * cb =
        Callback::Callback<TvChannelTvChannelListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void TargetNavigatorClusterTargetNavigatorListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                  Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType>
        list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<TargetNavigatorTargetNavigatorListListAttributeCallback> * cb =
        Callback::Callback<TargetNavigatorTargetNavigatorListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void TestClusterClusterListInt8uListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<uint8_t> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<TestClusterListInt8uListAttributeCallback> * cb =
        Callback::Callback<TestClusterListInt8uListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void TestClusterClusterListOctetStringListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::ByteSpan> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<TestClusterListOctetStringListAttributeCallback> * cb =
        Callback::Callback<TestClusterListOctetStringListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void TestClusterClusterListStructOctetStringListAttributeFilter(TLV::TLVReader * tlvData, Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<TestClusterListStructOctetStringListAttributeCallback> * cb =
        Callback::Callback<TestClusterListStructOctetStringListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void TestClusterClusterListNullablesAndOptionalsStructListAttributeFilter(TLV::TLVReader * tlvData,
                                                                          Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<TestClusterListNullablesAndOptionalsStructListAttributeCallback> * cb =
        Callback::Callback<TestClusterListNullablesAndOptionalsStructListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ThreadNetworkDiagnosticsClusterNeighborTableListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                         Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTable::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ThreadNetworkDiagnosticsNeighborTableListListAttributeCallback> * cb =
        Callback::Callback<ThreadNetworkDiagnosticsNeighborTableListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ThreadNetworkDiagnosticsClusterRouteTableListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                      Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTable::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ThreadNetworkDiagnosticsRouteTableListListAttributeCallback> * cb =
        Callback::Callback<ThreadNetworkDiagnosticsRouteTableListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ThreadNetworkDiagnosticsClusterSecurityPolicyListAttributeFilter(TLV::TLVReader * tlvData,
                                                                      Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ThreadNetworkDiagnosticsSecurityPolicyListAttributeCallback> * cb =
        Callback::Callback<ThreadNetworkDiagnosticsSecurityPolicyListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ThreadNetworkDiagnosticsClusterOperationalDatasetComponentsListAttributeFilter(TLV::TLVReader * tlvData,
                                                                                    Callback::Cancelable * onSuccessCallback,
                                                                                    Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType>
        list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallback> * cb =
        Callback::Callback<ThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallback>::FromCancelable(
            onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

void ThreadNetworkDiagnosticsClusterActiveNetworkFaultsListListAttributeFilter(TLV::TLVReader * tlvData,
                                                                               Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback)
{
    chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFault> list;
    CHIP_ERROR err = Decode(*tlvData, list);
    if (err != CHIP_NO_ERROR)
    {
        if (onFailureCallback != nullptr)
        {
            Callback::Callback<DefaultFailureCallback> * cb =
                Callback::Callback<DefaultFailureCallback>::FromCancelable(onFailureCallback);
            cb->mCall(cb->mContext, EMBER_ZCL_STATUS_INVALID_VALUE);
        }
        return;
    }

    Callback::Callback<ThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallback> * cb =
        Callback::Callback<ThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, list);
}

bool emberAfAccountLoginClusterGetSetupPINResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                           chip::CharSpan setupPIN)
{
    ChipLogProgress(Zcl, "GetSetupPINResponse:");
    ChipLogProgress(Zcl, "  setupPIN: %.*s", static_cast<int>(setupPIN.size()), setupPIN.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("AccountLoginClusterGetSetupPINResponseCallback");

    Callback::Callback<AccountLoginClusterGetSetupPINResponseCallback> * cb =
        Callback::Callback<AccountLoginClusterGetSetupPINResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, setupPIN);
    return true;
}

bool emberAfApplicationLauncherClusterLaunchAppResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                uint8_t status, chip::CharSpan data)
{
    ChipLogProgress(Zcl, "LaunchAppResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  data: %.*s", static_cast<int>(data.size()), data.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("ApplicationLauncherClusterLaunchAppResponseCallback");

    Callback::Callback<ApplicationLauncherClusterLaunchAppResponseCallback> * cb =
        Callback::Callback<ApplicationLauncherClusterLaunchAppResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, data);
    return true;
}

bool emberAfContentLauncherClusterLaunchContentResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                chip::CharSpan data, uint8_t contentLaunchStatus)
{
    ChipLogProgress(Zcl, "LaunchContentResponse:");
    ChipLogProgress(Zcl, "  data: %.*s", static_cast<int>(data.size()), data.data());
    ChipLogProgress(Zcl, "  contentLaunchStatus: %" PRIu8 "", contentLaunchStatus);

    GET_CLUSTER_RESPONSE_CALLBACKS("ContentLauncherClusterLaunchContentResponseCallback");

    Callback::Callback<ContentLauncherClusterLaunchContentResponseCallback> * cb =
        Callback::Callback<ContentLauncherClusterLaunchContentResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, data, contentLaunchStatus);
    return true;
}

bool emberAfContentLauncherClusterLaunchURLResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                            chip::CharSpan data, uint8_t contentLaunchStatus)
{
    ChipLogProgress(Zcl, "LaunchURLResponse:");
    ChipLogProgress(Zcl, "  data: %.*s", static_cast<int>(data.size()), data.data());
    ChipLogProgress(Zcl, "  contentLaunchStatus: %" PRIu8 "", contentLaunchStatus);

    GET_CLUSTER_RESPONSE_CALLBACKS("ContentLauncherClusterLaunchURLResponseCallback");

    Callback::Callback<ContentLauncherClusterLaunchURLResponseCallback> * cb =
        Callback::Callback<ContentLauncherClusterLaunchURLResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, data, contentLaunchStatus);
    return true;
}

bool emberAfDiagnosticLogsClusterRetrieveLogsResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                              chip::ByteSpan content, uint32_t timeStamp, uint32_t timeSinceBoot)
{
    ChipLogProgress(Zcl, "RetrieveLogsResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  content: %zu", content.size());
    ChipLogProgress(Zcl, "  timeStamp: %" PRIu32 "", timeStamp);
    ChipLogProgress(Zcl, "  timeSinceBoot: %" PRIu32 "", timeSinceBoot);

    GET_CLUSTER_RESPONSE_CALLBACKS("DiagnosticLogsClusterRetrieveLogsResponseCallback");

    Callback::Callback<DiagnosticLogsClusterRetrieveLogsResponseCallback> * cb =
        Callback::Callback<DiagnosticLogsClusterRetrieveLogsResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, content, timeStamp, timeSinceBoot);
    return true;
}

bool emberAfDoorLockClusterGetHolidayScheduleResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                              uint8_t holidayIndex, uint8_t status, uint32_t localStartTime,
                                                              uint32_t localEndTime, uint8_t operatingMode)
{
    ChipLogProgress(Zcl, "GetHolidayScheduleResponse:");
    ChipLogProgress(Zcl, "  holidayIndex: %" PRIu8 "", holidayIndex);
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  localStartTime: %" PRIu32 "", localStartTime);
    ChipLogProgress(Zcl, "  localEndTime: %" PRIu32 "", localEndTime);
    ChipLogProgress(Zcl, "  operatingMode: %" PRIu8 "", operatingMode);

    GET_CLUSTER_RESPONSE_CALLBACKS("DoorLockClusterGetHolidayScheduleResponseCallback");

    Callback::Callback<DoorLockClusterGetHolidayScheduleResponseCallback> * cb =
        Callback::Callback<DoorLockClusterGetHolidayScheduleResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, holidayIndex, status, localStartTime, localEndTime, operatingMode);
    return true;
}

bool emberAfDoorLockClusterGetLogRecordResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint16_t logEntryId,
                                                        uint32_t timestamp, uint8_t eventType, uint8_t source,
                                                        uint8_t eventIdOrAlarmCode, uint16_t userId, chip::ByteSpan pin)
{
    ChipLogProgress(Zcl, "GetLogRecordResponse:");
    ChipLogProgress(Zcl, "  logEntryId: %" PRIu16 "", logEntryId);
    ChipLogProgress(Zcl, "  timestamp: %" PRIu32 "", timestamp);
    ChipLogProgress(Zcl, "  eventType: %" PRIu8 "", eventType);
    ChipLogProgress(Zcl, "  source: %" PRIu8 "", source);
    ChipLogProgress(Zcl, "  eventIdOrAlarmCode: %" PRIu8 "", eventIdOrAlarmCode);
    ChipLogProgress(Zcl, "  userId: %" PRIu16 "", userId);
    ChipLogProgress(Zcl, "  pin: %zu", pin.size());

    GET_CLUSTER_RESPONSE_CALLBACKS("DoorLockClusterGetLogRecordResponseCallback");

    Callback::Callback<DoorLockClusterGetLogRecordResponseCallback> * cb =
        Callback::Callback<DoorLockClusterGetLogRecordResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, logEntryId, timestamp, eventType, source, eventIdOrAlarmCode, userId, pin);
    return true;
}

bool emberAfDoorLockClusterGetPINCodeResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint16_t userId,
                                                      uint8_t userStatus, uint8_t userType, chip::ByteSpan pin)
{
    ChipLogProgress(Zcl, "GetPINCodeResponse:");
    ChipLogProgress(Zcl, "  userId: %" PRIu16 "", userId);
    ChipLogProgress(Zcl, "  userStatus: %" PRIu8 "", userStatus);
    ChipLogProgress(Zcl, "  userType: %" PRIu8 "", userType);
    ChipLogProgress(Zcl, "  pin: %zu", pin.size());

    GET_CLUSTER_RESPONSE_CALLBACKS("DoorLockClusterGetPINCodeResponseCallback");

    Callback::Callback<DoorLockClusterGetPINCodeResponseCallback> * cb =
        Callback::Callback<DoorLockClusterGetPINCodeResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, userId, userStatus, userType, pin);
    return true;
}

bool emberAfDoorLockClusterGetRFIDCodeResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint16_t userId,
                                                       uint8_t userStatus, uint8_t userType, chip::ByteSpan rfidCode)
{
    ChipLogProgress(Zcl, "GetRFIDCodeResponse:");
    ChipLogProgress(Zcl, "  userId: %" PRIu16 "", userId);
    ChipLogProgress(Zcl, "  userStatus: %" PRIu8 "", userStatus);
    ChipLogProgress(Zcl, "  userType: %" PRIu8 "", userType);
    ChipLogProgress(Zcl, "  rfidCode: %zu", rfidCode.size());

    GET_CLUSTER_RESPONSE_CALLBACKS("DoorLockClusterGetRFIDCodeResponseCallback");

    Callback::Callback<DoorLockClusterGetRFIDCodeResponseCallback> * cb =
        Callback::Callback<DoorLockClusterGetRFIDCodeResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, userId, userStatus, userType, rfidCode);
    return true;
}

bool emberAfDoorLockClusterGetUserTypeResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint16_t userId,
                                                       uint8_t userType)
{
    ChipLogProgress(Zcl, "GetUserTypeResponse:");
    ChipLogProgress(Zcl, "  userId: %" PRIu16 "", userId);
    ChipLogProgress(Zcl, "  userType: %" PRIu8 "", userType);

    GET_CLUSTER_RESPONSE_CALLBACKS("DoorLockClusterGetUserTypeResponseCallback");

    Callback::Callback<DoorLockClusterGetUserTypeResponseCallback> * cb =
        Callback::Callback<DoorLockClusterGetUserTypeResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, userId, userType);
    return true;
}

bool emberAfDoorLockClusterGetWeekDayScheduleResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                              uint8_t weekDayIndex, uint16_t userIndex, uint8_t status,
                                                              uint8_t daysMask, uint8_t startHour, uint8_t startMinute,
                                                              uint8_t endHour, uint8_t endMinute)
{
    ChipLogProgress(Zcl, "GetWeekDayScheduleResponse:");
    ChipLogProgress(Zcl, "  weekDayIndex: %" PRIu8 "", weekDayIndex);
    ChipLogProgress(Zcl, "  userIndex: %" PRIu16 "", userIndex);
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  daysMask: %" PRIu8 "", daysMask);
    ChipLogProgress(Zcl, "  startHour: %" PRIu8 "", startHour);
    ChipLogProgress(Zcl, "  startMinute: %" PRIu8 "", startMinute);
    ChipLogProgress(Zcl, "  endHour: %" PRIu8 "", endHour);
    ChipLogProgress(Zcl, "  endMinute: %" PRIu8 "", endMinute);

    GET_CLUSTER_RESPONSE_CALLBACKS("DoorLockClusterGetWeekDayScheduleResponseCallback");

    Callback::Callback<DoorLockClusterGetWeekDayScheduleResponseCallback> * cb =
        Callback::Callback<DoorLockClusterGetWeekDayScheduleResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, weekDayIndex, userIndex, status, daysMask, startHour, startMinute, endHour, endMinute);
    return true;
}

bool emberAfDoorLockClusterGetYearDayScheduleResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                              uint8_t yearDayIndex, uint16_t userIndex, uint8_t status,
                                                              uint32_t localStartTime, uint32_t localEndTime)
{
    ChipLogProgress(Zcl, "GetYearDayScheduleResponse:");
    ChipLogProgress(Zcl, "  yearDayIndex: %" PRIu8 "", yearDayIndex);
    ChipLogProgress(Zcl, "  userIndex: %" PRIu16 "", userIndex);
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  localStartTime: %" PRIu32 "", localStartTime);
    ChipLogProgress(Zcl, "  localEndTime: %" PRIu32 "", localEndTime);

    GET_CLUSTER_RESPONSE_CALLBACKS("DoorLockClusterGetYearDayScheduleResponseCallback");

    Callback::Callback<DoorLockClusterGetYearDayScheduleResponseCallback> * cb =
        Callback::Callback<DoorLockClusterGetYearDayScheduleResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, yearDayIndex, userIndex, status, localStartTime, localEndTime);
    return true;
}

bool emberAfGeneralCommissioningClusterArmFailSafeResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                   uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "ArmFailSafeResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("GeneralCommissioningClusterArmFailSafeResponseCallback");

    Callback::Callback<GeneralCommissioningClusterArmFailSafeResponseCallback> * cb =
        Callback::Callback<GeneralCommissioningClusterArmFailSafeResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfGeneralCommissioningClusterCommissioningCompleteResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                             uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "CommissioningCompleteResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("GeneralCommissioningClusterCommissioningCompleteResponseCallback");

    Callback::Callback<GeneralCommissioningClusterCommissioningCompleteResponseCallback> * cb =
        Callback::Callback<GeneralCommissioningClusterCommissioningCompleteResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfGeneralCommissioningClusterSetRegulatoryConfigResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                           uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "SetRegulatoryConfigResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("GeneralCommissioningClusterSetRegulatoryConfigResponseCallback");

    Callback::Callback<GeneralCommissioningClusterSetRegulatoryConfigResponseCallback> * cb =
        Callback::Callback<GeneralCommissioningClusterSetRegulatoryConfigResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfGroupsClusterAddGroupResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                  uint16_t groupId)
{
    ChipLogProgress(Zcl, "AddGroupResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);

    GET_CLUSTER_RESPONSE_CALLBACKS("GroupsClusterAddGroupResponseCallback");

    Callback::Callback<GroupsClusterAddGroupResponseCallback> * cb =
        Callback::Callback<GroupsClusterAddGroupResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId);
    return true;
}

bool emberAfGroupsClusterGetGroupMembershipResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t capacity,
                                                            /* TYPE WARNING: array array defaults to */ uint8_t * groupList)
{
    ChipLogProgress(Zcl, "GetGroupMembershipResponse:");
    ChipLogProgress(Zcl, "  capacity: %" PRIu8 "", capacity);
    ChipLogProgress(Zcl, "  groupList: %p", groupList);

    GET_CLUSTER_RESPONSE_CALLBACKS("GroupsClusterGetGroupMembershipResponseCallback");

    Callback::Callback<GroupsClusterGetGroupMembershipResponseCallback> * cb =
        Callback::Callback<GroupsClusterGetGroupMembershipResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, capacity, groupList);
    return true;
}

bool emberAfGroupsClusterRemoveGroupResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                     uint16_t groupId)
{
    ChipLogProgress(Zcl, "RemoveGroupResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);

    GET_CLUSTER_RESPONSE_CALLBACKS("GroupsClusterRemoveGroupResponseCallback");

    Callback::Callback<GroupsClusterRemoveGroupResponseCallback> * cb =
        Callback::Callback<GroupsClusterRemoveGroupResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId);
    return true;
}

bool emberAfGroupsClusterViewGroupResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                   uint16_t groupId, chip::CharSpan groupName)
{
    ChipLogProgress(Zcl, "ViewGroupResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);
    ChipLogProgress(Zcl, "  groupName: %.*s", static_cast<int>(groupName.size()), groupName.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("GroupsClusterViewGroupResponseCallback");

    Callback::Callback<GroupsClusterViewGroupResponseCallback> * cb =
        Callback::Callback<GroupsClusterViewGroupResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId, groupName);
    return true;
}

bool emberAfIdentifyClusterIdentifyQueryResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint16_t timeout)
{
    ChipLogProgress(Zcl, "IdentifyQueryResponse:");
    ChipLogProgress(Zcl, "  timeout: %" PRIu16 "", timeout);

    GET_CLUSTER_RESPONSE_CALLBACKS("IdentifyClusterIdentifyQueryResponseCallback");

    Callback::Callback<IdentifyClusterIdentifyQueryResponseCallback> * cb =
        Callback::Callback<IdentifyClusterIdentifyQueryResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, timeout);
    return true;
}

bool emberAfKeypadInputClusterSendKeyResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status)
{
    ChipLogProgress(Zcl, "SendKeyResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);

    GET_CLUSTER_RESPONSE_CALLBACKS("KeypadInputClusterSendKeyResponseCallback");

    Callback::Callback<KeypadInputClusterSendKeyResponseCallback> * cb =
        Callback::Callback<KeypadInputClusterSendKeyResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status);
    return true;
}

bool emberAfMediaPlaybackClusterMediaFastForwardResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                 uint8_t mediaPlaybackStatus)
{
    ChipLogProgress(Zcl, "MediaFastForwardResponse:");
    ChipLogProgress(Zcl, "  mediaPlaybackStatus: %" PRIu8 "", mediaPlaybackStatus);

    GET_CLUSTER_RESPONSE_CALLBACKS("MediaPlaybackClusterMediaFastForwardResponseCallback");

    Callback::Callback<MediaPlaybackClusterMediaFastForwardResponseCallback> * cb =
        Callback::Callback<MediaPlaybackClusterMediaFastForwardResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, mediaPlaybackStatus);
    return true;
}

bool emberAfMediaPlaybackClusterMediaNextResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                          uint8_t mediaPlaybackStatus)
{
    ChipLogProgress(Zcl, "MediaNextResponse:");
    ChipLogProgress(Zcl, "  mediaPlaybackStatus: %" PRIu8 "", mediaPlaybackStatus);

    GET_CLUSTER_RESPONSE_CALLBACKS("MediaPlaybackClusterMediaNextResponseCallback");

    Callback::Callback<MediaPlaybackClusterMediaNextResponseCallback> * cb =
        Callback::Callback<MediaPlaybackClusterMediaNextResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, mediaPlaybackStatus);
    return true;
}

bool emberAfMediaPlaybackClusterMediaPauseResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                           uint8_t mediaPlaybackStatus)
{
    ChipLogProgress(Zcl, "MediaPauseResponse:");
    ChipLogProgress(Zcl, "  mediaPlaybackStatus: %" PRIu8 "", mediaPlaybackStatus);

    GET_CLUSTER_RESPONSE_CALLBACKS("MediaPlaybackClusterMediaPauseResponseCallback");

    Callback::Callback<MediaPlaybackClusterMediaPauseResponseCallback> * cb =
        Callback::Callback<MediaPlaybackClusterMediaPauseResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, mediaPlaybackStatus);
    return true;
}

bool emberAfMediaPlaybackClusterMediaPlayResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                          uint8_t mediaPlaybackStatus)
{
    ChipLogProgress(Zcl, "MediaPlayResponse:");
    ChipLogProgress(Zcl, "  mediaPlaybackStatus: %" PRIu8 "", mediaPlaybackStatus);

    GET_CLUSTER_RESPONSE_CALLBACKS("MediaPlaybackClusterMediaPlayResponseCallback");

    Callback::Callback<MediaPlaybackClusterMediaPlayResponseCallback> * cb =
        Callback::Callback<MediaPlaybackClusterMediaPlayResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, mediaPlaybackStatus);
    return true;
}

bool emberAfMediaPlaybackClusterMediaPreviousResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                              uint8_t mediaPlaybackStatus)
{
    ChipLogProgress(Zcl, "MediaPreviousResponse:");
    ChipLogProgress(Zcl, "  mediaPlaybackStatus: %" PRIu8 "", mediaPlaybackStatus);

    GET_CLUSTER_RESPONSE_CALLBACKS("MediaPlaybackClusterMediaPreviousResponseCallback");

    Callback::Callback<MediaPlaybackClusterMediaPreviousResponseCallback> * cb =
        Callback::Callback<MediaPlaybackClusterMediaPreviousResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, mediaPlaybackStatus);
    return true;
}

bool emberAfMediaPlaybackClusterMediaRewindResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                            uint8_t mediaPlaybackStatus)
{
    ChipLogProgress(Zcl, "MediaRewindResponse:");
    ChipLogProgress(Zcl, "  mediaPlaybackStatus: %" PRIu8 "", mediaPlaybackStatus);

    GET_CLUSTER_RESPONSE_CALLBACKS("MediaPlaybackClusterMediaRewindResponseCallback");

    Callback::Callback<MediaPlaybackClusterMediaRewindResponseCallback> * cb =
        Callback::Callback<MediaPlaybackClusterMediaRewindResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, mediaPlaybackStatus);
    return true;
}

bool emberAfMediaPlaybackClusterMediaSeekResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                          uint8_t mediaPlaybackStatus)
{
    ChipLogProgress(Zcl, "MediaSeekResponse:");
    ChipLogProgress(Zcl, "  mediaPlaybackStatus: %" PRIu8 "", mediaPlaybackStatus);

    GET_CLUSTER_RESPONSE_CALLBACKS("MediaPlaybackClusterMediaSeekResponseCallback");

    Callback::Callback<MediaPlaybackClusterMediaSeekResponseCallback> * cb =
        Callback::Callback<MediaPlaybackClusterMediaSeekResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, mediaPlaybackStatus);
    return true;
}

bool emberAfMediaPlaybackClusterMediaSkipBackwardResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                  uint8_t mediaPlaybackStatus)
{
    ChipLogProgress(Zcl, "MediaSkipBackwardResponse:");
    ChipLogProgress(Zcl, "  mediaPlaybackStatus: %" PRIu8 "", mediaPlaybackStatus);

    GET_CLUSTER_RESPONSE_CALLBACKS("MediaPlaybackClusterMediaSkipBackwardResponseCallback");

    Callback::Callback<MediaPlaybackClusterMediaSkipBackwardResponseCallback> * cb =
        Callback::Callback<MediaPlaybackClusterMediaSkipBackwardResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, mediaPlaybackStatus);
    return true;
}

bool emberAfMediaPlaybackClusterMediaSkipForwardResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                 uint8_t mediaPlaybackStatus)
{
    ChipLogProgress(Zcl, "MediaSkipForwardResponse:");
    ChipLogProgress(Zcl, "  mediaPlaybackStatus: %" PRIu8 "", mediaPlaybackStatus);

    GET_CLUSTER_RESPONSE_CALLBACKS("MediaPlaybackClusterMediaSkipForwardResponseCallback");

    Callback::Callback<MediaPlaybackClusterMediaSkipForwardResponseCallback> * cb =
        Callback::Callback<MediaPlaybackClusterMediaSkipForwardResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, mediaPlaybackStatus);
    return true;
}

bool emberAfMediaPlaybackClusterMediaStartOverResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                               uint8_t mediaPlaybackStatus)
{
    ChipLogProgress(Zcl, "MediaStartOverResponse:");
    ChipLogProgress(Zcl, "  mediaPlaybackStatus: %" PRIu8 "", mediaPlaybackStatus);

    GET_CLUSTER_RESPONSE_CALLBACKS("MediaPlaybackClusterMediaStartOverResponseCallback");

    Callback::Callback<MediaPlaybackClusterMediaStartOverResponseCallback> * cb =
        Callback::Callback<MediaPlaybackClusterMediaStartOverResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, mediaPlaybackStatus);
    return true;
}

bool emberAfMediaPlaybackClusterMediaStopResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                          uint8_t mediaPlaybackStatus)
{
    ChipLogProgress(Zcl, "MediaStopResponse:");
    ChipLogProgress(Zcl, "  mediaPlaybackStatus: %" PRIu8 "", mediaPlaybackStatus);

    GET_CLUSTER_RESPONSE_CALLBACKS("MediaPlaybackClusterMediaStopResponseCallback");

    Callback::Callback<MediaPlaybackClusterMediaStopResponseCallback> * cb =
        Callback::Callback<MediaPlaybackClusterMediaStopResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, mediaPlaybackStatus);
    return true;
}

bool emberAfNetworkCommissioningClusterAddThreadNetworkResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                        uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "AddThreadNetworkResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterAddThreadNetworkResponseCallback");

    Callback::Callback<NetworkCommissioningClusterAddThreadNetworkResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterAddThreadNetworkResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfNetworkCommissioningClusterAddWiFiNetworkResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                      uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "AddWiFiNetworkResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterAddWiFiNetworkResponseCallback");

    Callback::Callback<NetworkCommissioningClusterAddWiFiNetworkResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterAddWiFiNetworkResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfNetworkCommissioningClusterDisableNetworkResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                      uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "DisableNetworkResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterDisableNetworkResponseCallback");

    Callback::Callback<NetworkCommissioningClusterDisableNetworkResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterDisableNetworkResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfNetworkCommissioningClusterEnableNetworkResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                     uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "EnableNetworkResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterEnableNetworkResponseCallback");

    Callback::Callback<NetworkCommissioningClusterEnableNetworkResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterEnableNetworkResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfNetworkCommissioningClusterRemoveNetworkResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                     uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "RemoveNetworkResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterRemoveNetworkResponseCallback");

    Callback::Callback<NetworkCommissioningClusterRemoveNetworkResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterRemoveNetworkResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfNetworkCommissioningClusterScanNetworksResponseCallback(
    EndpointId endpoint, app::CommandSender * commandObj, uint8_t errorCode, chip::CharSpan debugText,
    /* TYPE WARNING: array array defaults to */ uint8_t * wifiScanResults,
    /* TYPE WARNING: array array defaults to */ uint8_t * threadScanResults)
{
    ChipLogProgress(Zcl, "ScanNetworksResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());
    ChipLogProgress(Zcl, "  wifiScanResults: %p", wifiScanResults);
    ChipLogProgress(Zcl, "  threadScanResults: %p", threadScanResults);

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterScanNetworksResponseCallback");

    Callback::Callback<NetworkCommissioningClusterScanNetworksResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterScanNetworksResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText, wifiScanResults, threadScanResults);
    return true;
}

bool emberAfNetworkCommissioningClusterUpdateThreadNetworkResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                           uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "UpdateThreadNetworkResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterUpdateThreadNetworkResponseCallback");

    Callback::Callback<NetworkCommissioningClusterUpdateThreadNetworkResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterUpdateThreadNetworkResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                         uint8_t errorCode, chip::CharSpan debugText)
{
    ChipLogProgress(Zcl, "UpdateWiFiNetworkResponse:");
    ChipLogProgress(Zcl, "  errorCode: %" PRIu8 "", errorCode);
    ChipLogProgress(Zcl, "  debugText: %.*s", static_cast<int>(debugText.size()), debugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("NetworkCommissioningClusterUpdateWiFiNetworkResponseCallback");

    Callback::Callback<NetworkCommissioningClusterUpdateWiFiNetworkResponseCallback> * cb =
        Callback::Callback<NetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, errorCode, debugText);
    return true;
}

bool emberAfOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                        uint8_t action, uint32_t delayedActionTime)
{
    ChipLogProgress(Zcl, "ApplyUpdateResponse:");
    ChipLogProgress(Zcl, "  action: %" PRIu8 "", action);
    ChipLogProgress(Zcl, "  delayedActionTime: %" PRIu32 "", delayedActionTime);

    GET_CLUSTER_RESPONSE_CALLBACKS("OtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback");

    Callback::Callback<OtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback> * cb =
        Callback::Callback<OtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, action, delayedActionTime);
    return true;
}

bool emberAfOtaSoftwareUpdateProviderClusterQueryImageResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                       uint8_t status, uint32_t delayedActionTime,
                                                                       chip::CharSpan imageURI, uint32_t softwareVersion,
                                                                       chip::CharSpan softwareVersionString,
                                                                       chip::ByteSpan updateToken, bool userConsentNeeded,
                                                                       chip::ByteSpan metadataForRequestor)
{
    ChipLogProgress(Zcl, "QueryImageResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  delayedActionTime: %" PRIu32 "", delayedActionTime);
    ChipLogProgress(Zcl, "  imageURI: %.*s", static_cast<int>(imageURI.size()), imageURI.data());
    ChipLogProgress(Zcl, "  softwareVersion: %" PRIu32 "", softwareVersion);
    ChipLogProgress(Zcl, "  softwareVersionString: %.*s", static_cast<int>(softwareVersionString.size()),
                    softwareVersionString.data());
    ChipLogProgress(Zcl, "  updateToken: %zu", updateToken.size());
    ChipLogProgress(Zcl, "  userConsentNeeded: %d", userConsentNeeded);
    ChipLogProgress(Zcl, "  metadataForRequestor: %zu", metadataForRequestor.size());

    GET_CLUSTER_RESPONSE_CALLBACKS("OtaSoftwareUpdateProviderClusterQueryImageResponseCallback");

    Callback::Callback<OtaSoftwareUpdateProviderClusterQueryImageResponseCallback> * cb =
        Callback::Callback<OtaSoftwareUpdateProviderClusterQueryImageResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, delayedActionTime, imageURI, softwareVersion, softwareVersionString, updateToken,
              userConsentNeeded, metadataForRequestor);
    return true;
}

bool emberAfOperationalCredentialsClusterAttestationResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                     chip::ByteSpan AttestationElements, chip::ByteSpan Signature)
{
    ChipLogProgress(Zcl, "AttestationResponse:");
    ChipLogProgress(Zcl, "  AttestationElements: %zu", AttestationElements.size());
    ChipLogProgress(Zcl, "  Signature: %zu", Signature.size());

    GET_CLUSTER_RESPONSE_CALLBACKS("OperationalCredentialsClusterAttestationResponseCallback");

    Callback::Callback<OperationalCredentialsClusterAttestationResponseCallback> * cb =
        Callback::Callback<OperationalCredentialsClusterAttestationResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, AttestationElements, Signature);
    return true;
}

bool emberAfOperationalCredentialsClusterCertificateChainResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                          chip::ByteSpan Certificate)
{
    ChipLogProgress(Zcl, "CertificateChainResponse:");
    ChipLogProgress(Zcl, "  Certificate: %zu", Certificate.size());

    GET_CLUSTER_RESPONSE_CALLBACKS("OperationalCredentialsClusterCertificateChainResponseCallback");

    Callback::Callback<OperationalCredentialsClusterCertificateChainResponseCallback> * cb =
        Callback::Callback<OperationalCredentialsClusterCertificateChainResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, Certificate);
    return true;
}

bool emberAfOperationalCredentialsClusterNOCResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                             uint8_t StatusCode, uint8_t FabricIndex, chip::CharSpan DebugText)
{
    ChipLogProgress(Zcl, "NOCResponse:");
    ChipLogProgress(Zcl, "  StatusCode: %" PRIu8 "", StatusCode);
    ChipLogProgress(Zcl, "  FabricIndex: %" PRIu8 "", FabricIndex);
    ChipLogProgress(Zcl, "  DebugText: %.*s", static_cast<int>(DebugText.size()), DebugText.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("OperationalCredentialsClusterNOCResponseCallback");

    Callback::Callback<OperationalCredentialsClusterNOCResponseCallback> * cb =
        Callback::Callback<OperationalCredentialsClusterNOCResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, StatusCode, FabricIndex, DebugText);
    return true;
}

bool emberAfOperationalCredentialsClusterOpCSRResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                               chip::ByteSpan NOCSRElements, chip::ByteSpan AttestationSignature)
{
    ChipLogProgress(Zcl, "OpCSRResponse:");
    ChipLogProgress(Zcl, "  NOCSRElements: %zu", NOCSRElements.size());
    ChipLogProgress(Zcl, "  AttestationSignature: %zu", AttestationSignature.size());

    GET_CLUSTER_RESPONSE_CALLBACKS("OperationalCredentialsClusterOpCSRResponseCallback");

    Callback::Callback<OperationalCredentialsClusterOpCSRResponseCallback> * cb =
        Callback::Callback<OperationalCredentialsClusterOpCSRResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, NOCSRElements, AttestationSignature);
    return true;
}

bool emberAfScenesClusterAddSceneResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                  uint16_t groupId, uint8_t sceneId)
{
    ChipLogProgress(Zcl, "AddSceneResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);
    ChipLogProgress(Zcl, "  sceneId: %" PRIu8 "", sceneId);

    GET_CLUSTER_RESPONSE_CALLBACKS("ScenesClusterAddSceneResponseCallback");

    Callback::Callback<ScenesClusterAddSceneResponseCallback> * cb =
        Callback::Callback<ScenesClusterAddSceneResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId, sceneId);
    return true;
}

bool emberAfScenesClusterGetSceneMembershipResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                            uint8_t capacity, uint16_t groupId, uint8_t sceneCount,
                                                            /* TYPE WARNING: array array defaults to */ uint8_t * sceneList)
{
    ChipLogProgress(Zcl, "GetSceneMembershipResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  capacity: %" PRIu8 "", capacity);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);
    ChipLogProgress(Zcl, "  sceneCount: %" PRIu8 "", sceneCount);
    ChipLogProgress(Zcl, "  sceneList: %p", sceneList);

    GET_CLUSTER_RESPONSE_CALLBACKS("ScenesClusterGetSceneMembershipResponseCallback");

    Callback::Callback<ScenesClusterGetSceneMembershipResponseCallback> * cb =
        Callback::Callback<ScenesClusterGetSceneMembershipResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, capacity, groupId, sceneCount, sceneList);
    return true;
}

bool emberAfScenesClusterRemoveAllScenesResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                         uint16_t groupId)
{
    ChipLogProgress(Zcl, "RemoveAllScenesResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);

    GET_CLUSTER_RESPONSE_CALLBACKS("ScenesClusterRemoveAllScenesResponseCallback");

    Callback::Callback<ScenesClusterRemoveAllScenesResponseCallback> * cb =
        Callback::Callback<ScenesClusterRemoveAllScenesResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId);
    return true;
}

bool emberAfScenesClusterRemoveSceneResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                     uint16_t groupId, uint8_t sceneId)
{
    ChipLogProgress(Zcl, "RemoveSceneResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);
    ChipLogProgress(Zcl, "  sceneId: %" PRIu8 "", sceneId);

    GET_CLUSTER_RESPONSE_CALLBACKS("ScenesClusterRemoveSceneResponseCallback");

    Callback::Callback<ScenesClusterRemoveSceneResponseCallback> * cb =
        Callback::Callback<ScenesClusterRemoveSceneResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId, sceneId);
    return true;
}

bool emberAfScenesClusterStoreSceneResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                    uint16_t groupId, uint8_t sceneId)
{
    ChipLogProgress(Zcl, "StoreSceneResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);
    ChipLogProgress(Zcl, "  sceneId: %" PRIu8 "", sceneId);

    GET_CLUSTER_RESPONSE_CALLBACKS("ScenesClusterStoreSceneResponseCallback");

    Callback::Callback<ScenesClusterStoreSceneResponseCallback> * cb =
        Callback::Callback<ScenesClusterStoreSceneResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId, sceneId);
    return true;
}

bool emberAfScenesClusterViewSceneResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, uint8_t status,
                                                   uint16_t groupId, uint8_t sceneId, uint16_t transitionTime,
                                                   chip::CharSpan sceneName,
                                                   /* TYPE WARNING: array array defaults to */ uint8_t * extensionFieldSets)
{
    ChipLogProgress(Zcl, "ViewSceneResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  groupId: %" PRIu16 "", groupId);
    ChipLogProgress(Zcl, "  sceneId: %" PRIu8 "", sceneId);
    ChipLogProgress(Zcl, "  transitionTime: %" PRIu16 "", transitionTime);
    ChipLogProgress(Zcl, "  sceneName: %.*s", static_cast<int>(sceneName.size()), sceneName.data());
    ChipLogProgress(Zcl, "  extensionFieldSets: %p", extensionFieldSets);

    GET_CLUSTER_RESPONSE_CALLBACKS("ScenesClusterViewSceneResponseCallback");

    Callback::Callback<ScenesClusterViewSceneResponseCallback> * cb =
        Callback::Callback<ScenesClusterViewSceneResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, groupId, sceneId, transitionTime, sceneName, extensionFieldSets);
    return true;
}

bool emberAfTvChannelClusterChangeChannelResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                          /* TYPE WARNING: array array defaults to */ uint8_t * ChannelMatch,
                                                          uint8_t ErrorType)
{
    ChipLogProgress(Zcl, "ChangeChannelResponse:");
    ChipLogProgress(Zcl, "  ChannelMatch: %p", ChannelMatch);
    ChipLogProgress(Zcl, "  ErrorType: %" PRIu8 "", ErrorType);

    GET_CLUSTER_RESPONSE_CALLBACKS("TvChannelClusterChangeChannelResponseCallback");

    Callback::Callback<TvChannelClusterChangeChannelResponseCallback> * cb =
        Callback::Callback<TvChannelClusterChangeChannelResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, ChannelMatch, ErrorType);
    return true;
}

bool emberAfTargetNavigatorClusterNavigateTargetResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                 uint8_t status, chip::CharSpan data)
{
    ChipLogProgress(Zcl, "NavigateTargetResponse:");
    ChipLogProgress(Zcl, "  status: %" PRIu8 "", status);
    ChipLogProgress(Zcl, "  data: %.*s", static_cast<int>(data.size()), data.data());

    GET_CLUSTER_RESPONSE_CALLBACKS("TargetNavigatorClusterNavigateTargetResponseCallback");

    Callback::Callback<TargetNavigatorClusterNavigateTargetResponseCallback> * cb =
        Callback::Callback<TargetNavigatorClusterNavigateTargetResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, status, data);
    return true;
}

bool emberAfTestClusterClusterBooleanResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, bool value)
{
    ChipLogProgress(Zcl, "BooleanResponse:");
    ChipLogProgress(Zcl, "  value: %d", value);

    GET_CLUSTER_RESPONSE_CALLBACKS("TestClusterClusterBooleanResponseCallback");

    Callback::Callback<TestClusterClusterBooleanResponseCallback> * cb =
        Callback::Callback<TestClusterClusterBooleanResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, value);
    return true;
}

bool emberAfTestClusterClusterSimpleStructResponseCallback(
    EndpointId endpoint, app::CommandSender * commandObj,
    chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType arg1)
{
    ChipLogProgress(Zcl, "SimpleStructResponse:");
    ChipLogProgress(Zcl, "  arg1: Not sure how to log struct SimpleStruct");

    GET_CLUSTER_RESPONSE_CALLBACKS("TestClusterClusterSimpleStructResponseCallback");

    Callback::Callback<TestClusterClusterSimpleStructResponseCallback> * cb =
        Callback::Callback<TestClusterClusterSimpleStructResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, SimpleStruct());
    return true;
}

bool emberAfTestClusterClusterTestAddArgumentsResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                               uint8_t returnValue)
{
    ChipLogProgress(Zcl, "TestAddArgumentsResponse:");
    ChipLogProgress(Zcl, "  returnValue: %" PRIu8 "", returnValue);

    GET_CLUSTER_RESPONSE_CALLBACKS("TestClusterClusterTestAddArgumentsResponseCallback");

    Callback::Callback<TestClusterClusterTestAddArgumentsResponseCallback> * cb =
        Callback::Callback<TestClusterClusterTestAddArgumentsResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, returnValue);
    return true;
}

bool emberAfTestClusterClusterTestEnumsResponseCallback(EndpointId endpoint, app::CommandSender * commandObj, chip::VendorId arg1,
                                                        uint8_t arg2)
{
    ChipLogProgress(Zcl, "TestEnumsResponse:");
    ChipLogProgress(Zcl, "  arg1: %" PRIu16 "", arg1);
    ChipLogProgress(Zcl, "  arg2: %" PRIu8 "", arg2);

    GET_CLUSTER_RESPONSE_CALLBACKS("TestClusterClusterTestEnumsResponseCallback");

    Callback::Callback<TestClusterClusterTestEnumsResponseCallback> * cb =
        Callback::Callback<TestClusterClusterTestEnumsResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, arg1, arg2);
    return true;
}

bool emberAfTestClusterClusterTestListInt8UReverseResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                   /* TYPE WARNING: array array defaults to */ uint8_t * arg1)
{
    ChipLogProgress(Zcl, "TestListInt8UReverseResponse:");
    ChipLogProgress(Zcl, "  arg1: %p", arg1);

    GET_CLUSTER_RESPONSE_CALLBACKS("TestClusterClusterTestListInt8UReverseResponseCallback");

    Callback::Callback<TestClusterClusterTestListInt8UReverseResponseCallback> * cb =
        Callback::Callback<TestClusterClusterTestListInt8UReverseResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, arg1);
    return true;
}

bool emberAfTestClusterClusterTestNullableOptionalResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                                   bool wasPresent, bool wasNull, uint8_t value,
                                                                   uint8_t originalValue)
{
    ChipLogProgress(Zcl, "TestNullableOptionalResponse:");
    ChipLogProgress(Zcl, "  wasPresent: %d", wasPresent);
    ChipLogProgress(Zcl, "  wasNull: %d", wasNull);
    ChipLogProgress(Zcl, "  value: %" PRIu8 "", value);
    ChipLogProgress(Zcl, "  originalValue: %" PRIu8 "", originalValue);

    GET_CLUSTER_RESPONSE_CALLBACKS("TestClusterClusterTestNullableOptionalResponseCallback");

    Callback::Callback<TestClusterClusterTestNullableOptionalResponseCallback> * cb =
        Callback::Callback<TestClusterClusterTestNullableOptionalResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, wasPresent, wasNull, value, originalValue);
    return true;
}

bool emberAfTestClusterClusterTestSpecificResponseCallback(EndpointId endpoint, app::CommandSender * commandObj,
                                                           uint8_t returnValue)
{
    ChipLogProgress(Zcl, "TestSpecificResponse:");
    ChipLogProgress(Zcl, "  returnValue: %" PRIu8 "", returnValue);

    GET_CLUSTER_RESPONSE_CALLBACKS("TestClusterClusterTestSpecificResponseCallback");

    Callback::Callback<TestClusterClusterTestSpecificResponseCallback> * cb =
        Callback::Callback<TestClusterClusterTestSpecificResponseCallback>::FromCancelable(onSuccessCallback);
    cb->mCall(cb->mContext, returnValue);
    return true;
}
