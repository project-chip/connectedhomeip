/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include "CHIPClusters.h"

#include <app-common/zap-generated/ids/Attributes.h>
#include <zap-generated/CHIPClientCallbacks.h>

namespace chip {

using namespace app::Clusters;
using namespace System;
using namespace Encoding::LittleEndian;

namespace Controller {

// TODO(#4502): onCompletion is not used by IM for now.
// TODO(#4503): length should be passed to commands when byte string is in argument list.
// TODO(#4503): Commands should take group id as an argument.

// AccountLogin Cluster Commands
CHIP_ERROR AccountLoginCluster::GetSetupPIN(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                            chip::CharSpan tempAccountIdentifier)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, AccountLogin::Commands::GetSetupPIN::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // tempAccountIdentifier: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), tempAccountIdentifier));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR AccountLoginCluster::Login(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                      chip::CharSpan tempAccountIdentifier, chip::CharSpan setupPIN)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, AccountLogin::Commands::Login::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // tempAccountIdentifier: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), tempAccountIdentifier));
    // setupPIN: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), setupPIN));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// AccountLogin Cluster Attributes
CHIP_ERROR AccountLoginCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR AccountLoginCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                  uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR AccountLoginCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// AdministratorCommissioning Cluster Commands
CHIP_ERROR AdministratorCommissioningCluster::OpenBasicCommissioningWindow(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t commissioningTimeout)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // commissioningTimeout: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), commissioningTimeout));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR AdministratorCommissioningCluster::OpenCommissioningWindow(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t commissioningTimeout, chip::ByteSpan PAKEVerifier,
                                                                      uint16_t discriminator, uint32_t iterations,
                                                                      chip::ByteSpan salt, uint16_t passcodeID)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         AdministratorCommissioning::Commands::OpenCommissioningWindow::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // commissioningTimeout: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), commissioningTimeout));
    // PAKEVerifier: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), PAKEVerifier));
    // discriminator: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), discriminator));
    // iterations: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), iterations));
    // salt: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), salt));
    // passcodeID: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), passcodeID));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR AdministratorCommissioningCluster::RevokeCommissioning(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         AdministratorCommissioning::Commands::RevokeCommissioning::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// AdministratorCommissioning Cluster Attributes
CHIP_ERROR AdministratorCommissioningCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR AdministratorCommissioningCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback,
                                                                                uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR AdministratorCommissioningCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// ApplicationBasic Cluster Commands
CHIP_ERROR ApplicationBasicCluster::ChangeStatus(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 uint8_t status)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ApplicationBasic::Commands::ChangeStatus::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // status: applicationBasicStatus
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), status));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// ApplicationBasic Cluster Attributes
CHIP_ERROR ApplicationBasicCluster::ReadAttributeVendorName(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR ApplicationBasicCluster::SubscribeAttributeVendorName(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ApplicationBasic::Attributes::VendorName::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationBasicCluster::ReportAttributeVendorName(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ApplicationBasic::Attributes::VendorName::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR ApplicationBasicCluster::ReadAttributeVendorId(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ApplicationBasicCluster::SubscribeAttributeVendorId(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ApplicationBasic::Attributes::VendorId::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationBasicCluster::ReportAttributeVendorId(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ApplicationBasic::Attributes::VendorId::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ApplicationBasicCluster::ReadAttributeApplicationName(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR ApplicationBasicCluster::SubscribeAttributeApplicationName(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ApplicationBasic::Attributes::ApplicationName::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationBasicCluster::ReportAttributeApplicationName(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ApplicationBasic::Attributes::ApplicationName::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR ApplicationBasicCluster::ReadAttributeProductId(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ApplicationBasicCluster::SubscribeAttributeProductId(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ApplicationBasic::Attributes::ProductId::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationBasicCluster::ReportAttributeProductId(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ApplicationBasic::Attributes::ProductId::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ApplicationBasicCluster::ReadAttributeApplicationId(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000005;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR ApplicationBasicCluster::SubscribeAttributeApplicationId(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ApplicationBasic::Attributes::ApplicationId::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationBasicCluster::ReportAttributeApplicationId(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ApplicationBasic::Attributes::ApplicationId::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR ApplicationBasicCluster::ReadAttributeCatalogVendorId(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000006;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ApplicationBasicCluster::SubscribeAttributeCatalogVendorId(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ApplicationBasic::Attributes::CatalogVendorId::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationBasicCluster::ReportAttributeCatalogVendorId(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ApplicationBasic::Attributes::CatalogVendorId::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ApplicationBasicCluster::ReadAttributeApplicationStatus(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000007;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ApplicationBasicCluster::SubscribeAttributeApplicationStatus(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ApplicationBasic::Attributes::ApplicationStatus::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationBasicCluster::ReportAttributeApplicationStatus(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ApplicationBasic::Attributes::ApplicationStatus::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ApplicationBasicCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ApplicationBasicCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationBasicCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// ApplicationLauncher Cluster Commands
CHIP_ERROR ApplicationLauncherCluster::LaunchApp(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 chip::CharSpan data, uint16_t catalogVendorId, chip::CharSpan applicationId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ApplicationLauncher::Commands::LaunchApp::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // data: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), data));
    // catalogVendorId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), catalogVendorId));
    // applicationId: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), applicationId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// ApplicationLauncher Cluster Attributes
CHIP_ERROR ApplicationLauncherCluster::ReadAttributeApplicationLauncherList(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             ApplicationLauncherClusterApplicationLauncherListListAttributeFilter);
}

CHIP_ERROR ApplicationLauncherCluster::ReadAttributeCatalogVendorId(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ApplicationLauncherCluster::SubscribeAttributeCatalogVendorId(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ApplicationLauncher::Attributes::CatalogVendorId::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationLauncherCluster::ReportAttributeCatalogVendorId(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ApplicationLauncher::Attributes::CatalogVendorId::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ApplicationLauncherCluster::ReadAttributeApplicationId(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ApplicationLauncherCluster::SubscribeAttributeApplicationId(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback,
                                                                       uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ApplicationLauncher::Attributes::ApplicationId::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationLauncherCluster::ReportAttributeApplicationId(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ApplicationLauncher::Attributes::ApplicationId::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ApplicationLauncherCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ApplicationLauncherCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationLauncherCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// AudioOutput Cluster Commands
CHIP_ERROR AudioOutputCluster::RenameOutput(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                            uint8_t index, chip::CharSpan name)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, AudioOutput::Commands::RenameOutput::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // index: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), index));
    // name: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), name));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR AudioOutputCluster::SelectOutput(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                            uint8_t index)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, AudioOutput::Commands::SelectOutput::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // index: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), index));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// AudioOutput Cluster Attributes
CHIP_ERROR AudioOutputCluster::ReadAttributeAudioOutputList(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             AudioOutputClusterAudioOutputListListAttributeFilter);
}

CHIP_ERROR AudioOutputCluster::ReadAttributeCurrentAudioOutput(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR AudioOutputCluster::SubscribeAttributeCurrentAudioOutput(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = AudioOutput::Attributes::CurrentAudioOutput::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR AudioOutputCluster::ReportAttributeCurrentAudioOutput(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(AudioOutput::Attributes::CurrentAudioOutput::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR AudioOutputCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR AudioOutputCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR AudioOutputCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// BarrierControl Cluster Commands
CHIP_ERROR BarrierControlCluster::BarrierControlGoToPercent(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint8_t percentOpen)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         BarrierControl::Commands::BarrierControlGoToPercent::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // percentOpen: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), percentOpen));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR BarrierControlCluster::BarrierControlStop(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, BarrierControl::Commands::BarrierControlStop::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// BarrierControl Cluster Attributes
CHIP_ERROR BarrierControlCluster::ReadAttributeBarrierMovingState(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR BarrierControlCluster::SubscribeAttributeBarrierMovingState(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback,
                                                                       uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = BarrierControl::Attributes::BarrierMovingState::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BarrierControlCluster::ReportAttributeBarrierMovingState(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(BarrierControl::Attributes::BarrierMovingState::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR BarrierControlCluster::ReadAttributeBarrierSafetyStatus(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BarrierControlCluster::SubscribeAttributeBarrierSafetyStatus(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = BarrierControl::Attributes::BarrierSafetyStatus::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BarrierControlCluster::ReportAttributeBarrierSafetyStatus(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(BarrierControl::Attributes::BarrierSafetyStatus::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BarrierControlCluster::ReadAttributeBarrierCapabilities(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR BarrierControlCluster::SubscribeAttributeBarrierCapabilities(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = BarrierControl::Attributes::BarrierCapabilities::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BarrierControlCluster::ReportAttributeBarrierCapabilities(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(BarrierControl::Attributes::BarrierCapabilities::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR BarrierControlCluster::ReadAttributeBarrierPosition(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR BarrierControlCluster::SubscribeAttributeBarrierPosition(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = BarrierControl::Attributes::BarrierPosition::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BarrierControlCluster::ReportAttributeBarrierPosition(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(BarrierControl::Attributes::BarrierPosition::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR BarrierControlCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BarrierControlCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BarrierControlCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// Basic Cluster Commands
CHIP_ERROR BasicCluster::MfgSpecificPing(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Basic::Commands::MfgSpecificPing::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// Basic Cluster Attributes
CHIP_ERROR BasicCluster::ReadAttributeInteractionModelVersion(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributeInteractionModelVersion(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                   uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::InteractionModelVersion::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeInteractionModelVersion(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::InteractionModelVersion::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeVendorName(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributeVendorName(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                      uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::VendorName::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeVendorName(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::VendorName::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeVendorID(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributeVendorID(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::VendorID::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeVendorID(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::VendorID::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeProductName(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributeProductName(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                       uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::ProductName::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeProductName(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::ProductName::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeProductID(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributeProductID(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::ProductID::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeProductID(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::ProductID::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeUserLabel(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000005;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::WriteAttributeUserLabel(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 chip::CharSpan value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, Basic::Attributes::UserLabel::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::SubscribeAttributeUserLabel(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::UserLabel::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeUserLabel(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::UserLabel::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeLocation(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000006;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::WriteAttributeLocation(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                chip::CharSpan value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, Basic::Attributes::Location::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::SubscribeAttributeLocation(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::Location::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeLocation(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::Location::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeHardwareVersion(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000007;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributeHardwareVersion(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                           uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::HardwareVersion::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeHardwareVersion(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::HardwareVersion::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeHardwareVersionString(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000008;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributeHardwareVersionString(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::HardwareVersionString::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeHardwareVersionString(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::HardwareVersionString::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeSoftwareVersion(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000009;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributeSoftwareVersion(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                           uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::SoftwareVersion::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeSoftwareVersion(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::SoftwareVersion::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeSoftwareVersionString(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributeSoftwareVersionString(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::SoftwareVersionString::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeSoftwareVersionString(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::SoftwareVersionString::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeManufacturingDate(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000B;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributeManufacturingDate(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                             uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::ManufacturingDate::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeManufacturingDate(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::ManufacturingDate::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributePartNumber(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributePartNumber(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                      uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::PartNumber::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributePartNumber(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::PartNumber::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeProductURL(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000D;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributeProductURL(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                      uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::ProductURL::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeProductURL(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::ProductURL::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeProductLabel(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000E;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributeProductLabel(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::ProductLabel::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeProductLabel(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::ProductLabel::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeSerialNumber(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000F;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributeSerialNumber(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::SerialNumber::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeSerialNumber(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::SerialNumber::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeLocalConfigDisabled(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000010;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR BasicCluster::WriteAttributeLocalConfigDisabled(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, bool value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, Basic::Attributes::LocalConfigDisabled::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::SubscribeAttributeLocalConfigDisabled(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::LocalConfigDisabled::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeLocalConfigDisabled(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::LocalConfigDisabled::Id, onReportCallback,
                                     BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeReachable(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000011;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributeReachable(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Basic::Attributes::Reachable::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeReachable(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Basic::Attributes::Reachable::Id, onReportCallback,
                                     BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR BasicCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BasicCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                           uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// BinaryInputBasic Cluster Commands
// BinaryInputBasic Cluster Attributes
CHIP_ERROR BinaryInputBasicCluster::ReadAttributeOutOfService(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000051;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR BinaryInputBasicCluster::WriteAttributeOutOfService(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, bool value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, BinaryInputBasic::Attributes::OutOfService::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BinaryInputBasicCluster::SubscribeAttributeOutOfService(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                   uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = BinaryInputBasic::Attributes::OutOfService::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BinaryInputBasicCluster::ReportAttributeOutOfService(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(BinaryInputBasic::Attributes::OutOfService::Id, onReportCallback,
                                     BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR BinaryInputBasicCluster::ReadAttributePresentValue(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000055;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR BinaryInputBasicCluster::WriteAttributePresentValue(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, bool value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, BinaryInputBasic::Attributes::PresentValue::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BinaryInputBasicCluster::SubscribeAttributePresentValue(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                   uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = BinaryInputBasic::Attributes::PresentValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BinaryInputBasicCluster::ReportAttributePresentValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(BinaryInputBasic::Attributes::PresentValue::Id, onReportCallback,
                                     BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR BinaryInputBasicCluster::ReadAttributeStatusFlags(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000006F;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR BinaryInputBasicCluster::SubscribeAttributeStatusFlags(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                  uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = BinaryInputBasic::Attributes::StatusFlags::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BinaryInputBasicCluster::ReportAttributeStatusFlags(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(BinaryInputBasic::Attributes::StatusFlags::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR BinaryInputBasicCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BinaryInputBasicCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BinaryInputBasicCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// Binding Cluster Commands
CHIP_ERROR BindingCluster::Bind(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                chip::NodeId nodeId, chip::GroupId groupId, chip::EndpointId endpointId, chip::ClusterId clusterId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Binding::Commands::Bind::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // nodeId: nodeId
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), nodeId));
    // groupId: groupId
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), groupId));
    // endpointId: endpointNo
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), endpointId));
    // clusterId: clusterId
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), clusterId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR BindingCluster::Unbind(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                  chip::NodeId nodeId, chip::GroupId groupId, chip::EndpointId endpointId,
                                  chip::ClusterId clusterId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Binding::Commands::Unbind::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // nodeId: nodeId
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), nodeId));
    // groupId: groupId
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), groupId));
    // endpointId: endpointNo
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), endpointId));
    // clusterId: clusterId
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), clusterId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// Binding Cluster Attributes
CHIP_ERROR BindingCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BindingCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                             uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BindingCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// BooleanState Cluster Commands
// BooleanState Cluster Attributes
CHIP_ERROR BooleanStateCluster::ReadAttributeStateValue(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR BooleanStateCluster::SubscribeAttributeStateValue(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                             uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = BooleanState::Attributes::StateValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BooleanStateCluster::ReportAttributeStateValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(BooleanState::Attributes::StateValue::Id, onReportCallback,
                                     BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR BooleanStateCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BooleanStateCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                  uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BooleanStateCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// BridgedActions Cluster Commands
CHIP_ERROR BridgedActionsCluster::DisableAction(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                uint16_t actionID, uint32_t invokeID)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, BridgedActions::Commands::DisableAction::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // actionID: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), actionID));
    // invokeID: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), invokeID));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR BridgedActionsCluster::DisableActionWithDuration(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t actionID,
                                                            uint32_t invokeID, uint32_t duration)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         BridgedActions::Commands::DisableActionWithDuration::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // actionID: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), actionID));
    // invokeID: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), invokeID));
    // duration: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), duration));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR BridgedActionsCluster::EnableAction(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint16_t actionID, uint32_t invokeID)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, BridgedActions::Commands::EnableAction::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // actionID: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), actionID));
    // invokeID: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), invokeID));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR BridgedActionsCluster::EnableActionWithDuration(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t actionID,
                                                           uint32_t invokeID, uint32_t duration)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         BridgedActions::Commands::EnableActionWithDuration::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // actionID: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), actionID));
    // invokeID: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), invokeID));
    // duration: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), duration));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR BridgedActionsCluster::InstantAction(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                uint16_t actionID, uint32_t invokeID)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, BridgedActions::Commands::InstantAction::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // actionID: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), actionID));
    // invokeID: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), invokeID));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR BridgedActionsCluster::InstantActionWithTransition(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback, uint16_t actionID,
                                                              uint32_t invokeID, uint16_t transitionTime)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         BridgedActions::Commands::InstantActionWithTransition::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // actionID: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), actionID));
    // invokeID: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), invokeID));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR BridgedActionsCluster::PauseAction(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                              uint16_t actionID, uint32_t invokeID)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, BridgedActions::Commands::PauseAction::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // actionID: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), actionID));
    // invokeID: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), invokeID));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR BridgedActionsCluster::PauseActionWithDuration(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback, uint16_t actionID,
                                                          uint32_t invokeID, uint32_t duration)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         BridgedActions::Commands::PauseActionWithDuration::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // actionID: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), actionID));
    // invokeID: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), invokeID));
    // duration: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), duration));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR BridgedActionsCluster::ResumeAction(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint16_t actionID, uint32_t invokeID)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, BridgedActions::Commands::ResumeAction::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // actionID: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), actionID));
    // invokeID: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), invokeID));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR BridgedActionsCluster::StartAction(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                              uint16_t actionID, uint32_t invokeID)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, BridgedActions::Commands::StartAction::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // actionID: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), actionID));
    // invokeID: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), invokeID));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR BridgedActionsCluster::StartActionWithDuration(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback, uint16_t actionID,
                                                          uint32_t invokeID, uint32_t duration)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         BridgedActions::Commands::StartActionWithDuration::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // actionID: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), actionID));
    // invokeID: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), invokeID));
    // duration: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), duration));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR BridgedActionsCluster::StopAction(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                             uint16_t actionID, uint32_t invokeID)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, BridgedActions::Commands::StopAction::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // actionID: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), actionID));
    // invokeID: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), invokeID));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// BridgedActions Cluster Attributes
CHIP_ERROR BridgedActionsCluster::ReadAttributeActionList(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BridgedActionsClusterActionListListAttributeFilter);
}

CHIP_ERROR BridgedActionsCluster::ReadAttributeEndpointList(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BridgedActionsClusterEndpointListListAttributeFilter);
}

CHIP_ERROR BridgedActionsCluster::ReadAttributeSetupUrl(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BridgedActionsCluster::SubscribeAttributeSetupUrl(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                             uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = BridgedActions::Attributes::SetupUrl::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BridgedActionsCluster::ReportAttributeSetupUrl(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(BridgedActions::Attributes::SetupUrl::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR BridgedActionsCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BridgedActionsCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BridgedActionsCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// BridgedDeviceBasicInformation Cluster Commands
// BridgedDeviceBasicInformation Cluster Attributes
CHIP_ERROR BridgedDeviceBasicInformationCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR BridgedDeviceBasicInformationCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                                   Callback::Cancelable * onFailureCallback,
                                                                                   uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BridgedDeviceBasicInformationCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// ColorControl Cluster Commands
CHIP_ERROR ColorControlCluster::ColorLoopSet(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                             uint8_t updateFlags, uint8_t action, uint8_t direction, uint16_t time,
                                             uint16_t startHue, uint8_t optionsMask, uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::ColorLoopSet::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // updateFlags: colorLoopUpdateFlags
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), updateFlags));
    // action: colorLoopAction
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), action));
    // direction: colorLoopDirection
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), direction));
    // time: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), time));
    // startHue: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), startHue));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::EnhancedMoveHue(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                uint8_t moveMode, uint16_t rate, uint8_t optionsMask, uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::EnhancedMoveHue::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // moveMode: hueMoveMode
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), moveMode));
    // rate: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), rate));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::EnhancedMoveToHue(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback, uint16_t enhancedHue, uint8_t direction,
                                                  uint16_t transitionTime, uint8_t optionsMask, uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::EnhancedMoveToHue::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // enhancedHue: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), enhancedHue));
    // direction: hueDirection
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), direction));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::EnhancedMoveToHueAndSaturation(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t enhancedHue,
                                                               uint8_t saturation, uint16_t transitionTime, uint8_t optionsMask,
                                                               uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         ColorControl::Commands::EnhancedMoveToHueAndSaturation::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // enhancedHue: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), enhancedHue));
    // saturation: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), saturation));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::EnhancedStepHue(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                uint8_t stepMode, uint16_t stepSize, uint16_t transitionTime, uint8_t optionsMask,
                                                uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::EnhancedStepHue::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // stepMode: hueStepMode
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), stepMode));
    // stepSize: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), stepSize));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::MoveColor(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                          int16_t rateX, int16_t rateY, uint8_t optionsMask, uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::MoveColor::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // rateX: int16s
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), rateX));
    // rateY: int16s
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), rateY));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::MoveColorTemperature(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, uint8_t moveMode, uint16_t rate,
                                                     uint16_t colorTemperatureMinimum, uint16_t colorTemperatureMaximum,
                                                     uint8_t optionsMask, uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::MoveColorTemperature::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // moveMode: hueMoveMode
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), moveMode));
    // rate: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), rate));
    // colorTemperatureMinimum: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), colorTemperatureMinimum));
    // colorTemperatureMaximum: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), colorTemperatureMaximum));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::MoveHue(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                        uint8_t moveMode, uint8_t rate, uint8_t optionsMask, uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::MoveHue::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // moveMode: hueMoveMode
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), moveMode));
    // rate: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), rate));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::MoveSaturation(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t moveMode, uint8_t rate, uint8_t optionsMask, uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::MoveSaturation::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // moveMode: saturationMoveMode
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), moveMode));
    // rate: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), rate));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::MoveToColor(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                            uint16_t colorX, uint16_t colorY, uint16_t transitionTime, uint8_t optionsMask,
                                            uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::MoveToColor::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // colorX: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), colorX));
    // colorY: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), colorY));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::MoveToColorTemperature(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint16_t colorTemperature,
                                                       uint16_t transitionTime, uint8_t optionsMask, uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         ColorControl::Commands::MoveToColorTemperature::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // colorTemperature: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), colorTemperature));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::MoveToHue(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                          uint8_t hue, uint8_t direction, uint16_t transitionTime, uint8_t optionsMask,
                                          uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::MoveToHue::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // hue: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), hue));
    // direction: hueDirection
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), direction));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::MoveToHueAndSaturation(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint8_t hue, uint8_t saturation,
                                                       uint16_t transitionTime, uint8_t optionsMask, uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         ColorControl::Commands::MoveToHueAndSaturation::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // hue: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), hue));
    // saturation: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), saturation));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::MoveToSaturation(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 uint8_t saturation, uint16_t transitionTime, uint8_t optionsMask,
                                                 uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::MoveToSaturation::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // saturation: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), saturation));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::StepColor(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                          int16_t stepX, int16_t stepY, uint16_t transitionTime, uint8_t optionsMask,
                                          uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::StepColor::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // stepX: int16s
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), stepX));
    // stepY: int16s
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), stepY));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::StepColorTemperature(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, uint8_t stepMode, uint16_t stepSize,
                                                     uint16_t transitionTime, uint16_t colorTemperatureMinimum,
                                                     uint16_t colorTemperatureMaximum, uint8_t optionsMask, uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::StepColorTemperature::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // stepMode: hueStepMode
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), stepMode));
    // stepSize: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), stepSize));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // colorTemperatureMinimum: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), colorTemperatureMinimum));
    // colorTemperatureMaximum: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), colorTemperatureMaximum));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::StepHue(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                        uint8_t stepMode, uint8_t stepSize, uint8_t transitionTime, uint8_t optionsMask,
                                        uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::StepHue::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // stepMode: hueStepMode
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), stepMode));
    // stepSize: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), stepSize));
    // transitionTime: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::StepSaturation(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t stepMode, uint8_t stepSize, uint8_t transitionTime, uint8_t optionsMask,
                                               uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::StepSaturation::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // stepMode: saturationStepMode
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), stepMode));
    // stepSize: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), stepSize));
    // transitionTime: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ColorControlCluster::StopMoveStep(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                             uint8_t optionsMask, uint8_t optionsOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ColorControl::Commands::StopMoveStep::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // optionsMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// ColorControl Cluster Attributes
CHIP_ERROR ColorControlCluster::ReadAttributeCurrentHue(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeCurrentHue(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                             uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::CurrentHue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeCurrentHue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::CurrentHue::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeCurrentSaturation(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeCurrentSaturation(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::CurrentSaturation::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeCurrentSaturation(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::CurrentSaturation::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeRemainingTime(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeRemainingTime(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::RemainingTime::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeRemainingTime(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::RemainingTime::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeCurrentX(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeCurrentX(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                           uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::CurrentX::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeCurrentX(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::CurrentX::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeCurrentY(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeCurrentY(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                           uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::CurrentY::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeCurrentY(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::CurrentY::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeDriftCompensation(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000005;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeDriftCompensation(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::DriftCompensation::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeDriftCompensation(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::DriftCompensation::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeCompensationText(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000006;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeCompensationText(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                   uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::CompensationText::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeCompensationText(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::CompensationText::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorTemperature(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000007;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorTemperature(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                   uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorTemperature::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorTemperature(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorTemperature::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorMode(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000008;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorMode(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorMode::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorMode(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorMode::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorControlOptions(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000F;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorControlOptions(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, ColorControl::Attributes::ColorControlOptions::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorControlOptions(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorControlOptions::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorControlOptions(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorControlOptions::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeNumberOfPrimaries(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000010;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeNumberOfPrimaries(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::NumberOfPrimaries::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeNumberOfPrimaries(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::NumberOfPrimaries::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary1X(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000011;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary1X(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary1X::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary1X(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary1X::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary1Y(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000012;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary1Y(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary1Y::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary1Y(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary1Y::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary1Intensity(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000013;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary1Intensity(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary1Intensity::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary1Intensity(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary1Intensity::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary2X(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000015;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary2X(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary2X::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary2X(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary2X::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary2Y(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000016;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary2Y(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary2Y::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary2Y(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary2Y::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary2Intensity(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000017;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary2Intensity(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary2Intensity::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary2Intensity(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary2Intensity::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary3X(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000019;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary3X(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary3X::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary3X(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary3X::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary3Y(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary3Y(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary3Y::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary3Y(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary3Y::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary3Intensity(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001B;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary3Intensity(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary3Intensity::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary3Intensity(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary3Intensity::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary4X(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000020;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary4X(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary4X::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary4X(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary4X::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary4Y(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000021;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary4Y(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary4Y::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary4Y(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary4Y::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary4Intensity(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000022;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary4Intensity(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary4Intensity::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary4Intensity(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary4Intensity::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary5X(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000024;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary5X(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary5X::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary5X(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary5X::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary5Y(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000025;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary5Y(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary5Y::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary5Y(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary5Y::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary5Intensity(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000026;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary5Intensity(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary5Intensity::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary5Intensity(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary5Intensity::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary6X(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000028;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary6X(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary6X::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary6X(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary6X::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary6Y(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000029;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary6Y(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary6Y::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary6Y(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary6Y::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary6Intensity(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000002A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributePrimary6Intensity(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::Primary6Intensity::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributePrimary6Intensity(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::Primary6Intensity::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeWhitePointX(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000030;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::WriteAttributeWhitePointX(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, ColorControl::Attributes::WhitePointX::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeWhitePointX(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                              uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::WhitePointX::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeWhitePointX(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::WhitePointX::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeWhitePointY(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000031;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::WriteAttributeWhitePointY(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, ColorControl::Attributes::WhitePointY::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeWhitePointY(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                              uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::WhitePointY::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeWhitePointY(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::WhitePointY::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointRX(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000032;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointRX(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, ColorControl::Attributes::ColorPointRX::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorPointRX(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorPointRX::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorPointRX(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorPointRX::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointRY(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000033;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointRY(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, ColorControl::Attributes::ColorPointRY::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorPointRY(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorPointRY::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorPointRY(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorPointRY::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointRIntensity(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000034;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointRIntensity(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, ColorControl::Attributes::ColorPointRIntensity::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorPointRIntensity(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback,
                                                                       uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorPointRIntensity::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorPointRIntensity(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorPointRIntensity::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointGX(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000036;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointGX(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, ColorControl::Attributes::ColorPointGX::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorPointGX(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorPointGX::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorPointGX(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorPointGX::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointGY(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000037;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointGY(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, ColorControl::Attributes::ColorPointGY::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorPointGY(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorPointGY::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorPointGY(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorPointGY::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointGIntensity(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000038;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointGIntensity(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, ColorControl::Attributes::ColorPointGIntensity::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorPointGIntensity(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback,
                                                                       uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorPointGIntensity::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorPointGIntensity(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorPointGIntensity::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointBX(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000003A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointBX(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, ColorControl::Attributes::ColorPointBX::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorPointBX(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorPointBX::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorPointBX(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorPointBX::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointBY(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000003B;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointBY(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, ColorControl::Attributes::ColorPointBY::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorPointBY(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorPointBY::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorPointBY(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorPointBY::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointBIntensity(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000003C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointBIntensity(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, ColorControl::Attributes::ColorPointBIntensity::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorPointBIntensity(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback,
                                                                       uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorPointBIntensity::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorPointBIntensity(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorPointBIntensity::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeEnhancedCurrentHue(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00004000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeEnhancedCurrentHue(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::EnhancedCurrentHue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeEnhancedCurrentHue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::EnhancedCurrentHue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeEnhancedColorMode(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00004001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeEnhancedColorMode(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::EnhancedColorMode::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeEnhancedColorMode(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::EnhancedColorMode::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorLoopActive(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00004002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorLoopActive(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                  uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorLoopActive::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorLoopActive(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorLoopActive::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorLoopDirection(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00004003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorLoopDirection(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorLoopDirection::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorLoopDirection(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorLoopDirection::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorLoopTime(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00004004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorLoopTime(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorLoopTime::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorLoopTime(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorLoopTime::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorLoopStartEnhancedHue(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00004005;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorLoopStartEnhancedHue(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorLoopStartEnhancedHue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorLoopStartEnhancedHue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorLoopStartEnhancedHue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorLoopStoredEnhancedHue(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00004006;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorLoopStoredEnhancedHue(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback,
                                                                             uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorLoopStoredEnhancedHue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorCapabilities(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000400A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorCapabilities(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorCapabilities::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorCapabilities(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorCapabilities::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorTempPhysicalMin(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000400B;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorTempPhysicalMin(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback,
                                                                       uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorTempPhysicalMin::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorTempPhysicalMin(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorTempPhysicalMin::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorTempPhysicalMax(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000400C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeColorTempPhysicalMax(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback,
                                                                       uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::ColorTempPhysicalMax::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorTempPhysicalMax(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::ColorTempPhysicalMax::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeCoupleColorTempToLevelMinMireds(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000400D;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeCoupleColorTempToLevelMinMireds(Callback::Cancelable * onSuccessCallback,
                                                                                  Callback::Cancelable * onFailureCallback,
                                                                                  uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::CoupleColorTempToLevelMinMireds::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeCoupleColorTempToLevelMinMireds(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::CoupleColorTempToLevelMinMireds::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeStartUpColorTemperatureMireds(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00004010;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::WriteAttributeStartUpColorTemperatureMireds(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, ColorControl::Attributes::StartUpColorTemperatureMireds::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeStartUpColorTemperatureMireds(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback,
                                                                                uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ColorControl::Attributes::StartUpColorTemperatureMireds::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeStartUpColorTemperatureMireds(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ColorControl::Attributes::StartUpColorTemperatureMireds::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ColorControlCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                  uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// ContentLauncher Cluster Commands
CHIP_ERROR ContentLauncherCluster::LaunchContent(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 bool autoPlay, chip::CharSpan data)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ContentLauncher::Commands::LaunchContent::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // autoPlay: boolean
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), autoPlay));
    // data: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), data));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ContentLauncherCluster::LaunchURL(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                             chip::CharSpan contentURL, chip::CharSpan displayString)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ContentLauncher::Commands::LaunchURL::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // contentURL: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), contentURL));
    // displayString: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), displayString));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// ContentLauncher Cluster Attributes
CHIP_ERROR ContentLauncherCluster::ReadAttributeAcceptsHeaderList(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             ContentLauncherClusterAcceptsHeaderListListAttributeFilter);
}

CHIP_ERROR ContentLauncherCluster::ReadAttributeSupportedStreamingTypes(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             ContentLauncherClusterSupportedStreamingTypesListAttributeFilter);
}

CHIP_ERROR ContentLauncherCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ContentLauncherCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ContentLauncherCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// Descriptor Cluster Commands
// Descriptor Cluster Attributes
CHIP_ERROR DescriptorCluster::ReadAttributeDeviceList(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             DescriptorClusterDeviceListListAttributeFilter);
}

CHIP_ERROR DescriptorCluster::ReadAttributeServerList(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             DescriptorClusterServerListListAttributeFilter);
}

CHIP_ERROR DescriptorCluster::ReadAttributeClientList(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             DescriptorClusterClientListListAttributeFilter);
}

CHIP_ERROR DescriptorCluster::ReadAttributePartsList(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             DescriptorClusterPartsListListAttributeFilter);
}

CHIP_ERROR DescriptorCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR DescriptorCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR DescriptorCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// DiagnosticLogs Cluster Commands
CHIP_ERROR DiagnosticLogsCluster::RetrieveLogsRequest(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback, uint8_t intent,
                                                      uint8_t requestedProtocol, chip::ByteSpan transferFileDesignator)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DiagnosticLogs::Commands::RetrieveLogsRequest::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // intent: logsIntent
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), intent));
    // requestedProtocol: logsTransferProtocol
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), requestedProtocol));
    // transferFileDesignator: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transferFileDesignator));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// DiagnosticLogs Cluster Attributes

// DoorLock Cluster Commands
CHIP_ERROR DoorLockCluster::ClearAllPins(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::ClearAllPins::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::ClearAllRfids(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::ClearAllRfids::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::ClearHolidaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 uint8_t scheduleId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::ClearHolidaySchedule::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // scheduleId: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), scheduleId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::ClearPin(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                     uint16_t userId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::ClearPin::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // userId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::ClearRfid(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                      uint16_t userId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::ClearRfid::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // userId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::ClearWeekdaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 uint8_t scheduleId, uint16_t userId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::ClearWeekdaySchedule::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // scheduleId: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), scheduleId));
    // userId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::ClearYeardaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 uint8_t scheduleId, uint16_t userId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::ClearYeardaySchedule::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // scheduleId: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), scheduleId));
    // userId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::GetHolidaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t scheduleId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::GetHolidaySchedule::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // scheduleId: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), scheduleId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::GetLogRecord(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                         uint16_t logIndex)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::GetLogRecord::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // logIndex: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), logIndex));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::GetPin(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                   uint16_t userId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::GetPin::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // userId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::GetRfid(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                    uint16_t userId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::GetRfid::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // userId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::GetUserType(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                        uint16_t userId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::GetUserType::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // userId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::GetWeekdaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t scheduleId, uint16_t userId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::GetWeekdaySchedule::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // scheduleId: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), scheduleId));
    // userId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::GetYeardaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t scheduleId, uint16_t userId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::GetYeardaySchedule::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // scheduleId: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), scheduleId));
    // userId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::LockDoor(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                     chip::ByteSpan pin)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::LockDoor::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // pin: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), pin));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::SetHolidaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t scheduleId, uint32_t localStartTime, uint32_t localEndTime,
                                               uint8_t operatingModeDuringHoliday)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::SetHolidaySchedule::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // scheduleId: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), scheduleId));
    // localStartTime: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), localStartTime));
    // localEndTime: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), localEndTime));
    // operatingModeDuringHoliday: enum8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), operatingModeDuringHoliday));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::SetPin(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                   uint16_t userId, uint8_t userStatus, uint8_t userType, chip::ByteSpan pin)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::SetPin::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // userId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userId));
    // userStatus: doorLockUserStatus
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userStatus));
    // userType: doorLockUserType
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userType));
    // pin: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), pin));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::SetRfid(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                    uint16_t userId, uint8_t userStatus, uint8_t userType, chip::ByteSpan id)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::SetRfid::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // userId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userId));
    // userStatus: doorLockUserStatus
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userStatus));
    // userType: doorLockUserType
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userType));
    // id: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), id));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::SetUserType(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                        uint16_t userId, uint8_t userType)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::SetUserType::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // userId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userId));
    // userType: doorLockUserType
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userType));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::SetWeekdaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t scheduleId, uint16_t userId, uint8_t daysMask, uint8_t startHour,
                                               uint8_t startMinute, uint8_t endHour, uint8_t endMinute)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::SetWeekdaySchedule::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // scheduleId: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), scheduleId));
    // userId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userId));
    // daysMask: doorLockDayOfWeek
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), daysMask));
    // startHour: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), startHour));
    // startMinute: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), startMinute));
    // endHour: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), endHour));
    // endMinute: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), endMinute));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::SetYeardaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t scheduleId, uint16_t userId, uint32_t localStartTime, uint32_t localEndTime)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::SetYeardaySchedule::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // scheduleId: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), scheduleId));
    // userId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), userId));
    // localStartTime: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), localStartTime));
    // localEndTime: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), localEndTime));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::UnlockDoor(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                       chip::ByteSpan pin)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::UnlockDoor::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // pin: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), pin));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR DoorLockCluster::UnlockWithTimeout(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                              uint16_t timeoutInSeconds, chip::ByteSpan pin)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, DoorLock::Commands::UnlockWithTimeout::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // timeoutInSeconds: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), timeoutInSeconds));
    // pin: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), pin));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// DoorLock Cluster Attributes
CHIP_ERROR DoorLockCluster::ReadAttributeLockState(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR DoorLockCluster::SubscribeAttributeLockState(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = DoorLock::Attributes::LockState::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR DoorLockCluster::ReportAttributeLockState(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(DoorLock::Attributes::LockState::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR DoorLockCluster::ReadAttributeLockType(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR DoorLockCluster::SubscribeAttributeLockType(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                       uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = DoorLock::Attributes::LockType::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR DoorLockCluster::ReportAttributeLockType(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(DoorLock::Attributes::LockType::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR DoorLockCluster::ReadAttributeActuatorEnabled(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR DoorLockCluster::SubscribeAttributeActuatorEnabled(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                              uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = DoorLock::Attributes::ActuatorEnabled::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR DoorLockCluster::ReportAttributeActuatorEnabled(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(DoorLock::Attributes::ActuatorEnabled::Id, onReportCallback,
                                     BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR DoorLockCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR DoorLockCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                              uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR DoorLockCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// ElectricalMeasurement Cluster Commands
// ElectricalMeasurement Cluster Attributes
CHIP_ERROR ElectricalMeasurementCluster::ReadAttributeMeasurementType(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::SubscribeAttributeMeasurementType(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ElectricalMeasurement::Attributes::MeasurementType::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ElectricalMeasurementCluster::ReportAttributeMeasurementType(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ElectricalMeasurement::Attributes::MeasurementType::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::ReadAttributeTotalActivePower(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000304;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32sAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::SubscribeAttributeTotalActivePower(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ElectricalMeasurement::Attributes::TotalActivePower::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ElectricalMeasurementCluster::ReportAttributeTotalActivePower(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ElectricalMeasurement::Attributes::TotalActivePower::Id, onReportCallback,
                                     BasicAttributeFilter<Int32sAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::ReadAttributeRmsVoltage(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000505;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::SubscribeAttributeRmsVoltage(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ElectricalMeasurement::Attributes::RmsVoltage::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ElectricalMeasurementCluster::ReportAttributeRmsVoltage(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ElectricalMeasurement::Attributes::RmsVoltage::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::ReadAttributeRmsVoltageMin(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000506;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::SubscribeAttributeRmsVoltageMin(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ElectricalMeasurement::Attributes::RmsVoltageMin::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ElectricalMeasurementCluster::ReportAttributeRmsVoltageMin(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ElectricalMeasurement::Attributes::RmsVoltageMin::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::ReadAttributeRmsVoltageMax(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000507;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::SubscribeAttributeRmsVoltageMax(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ElectricalMeasurement::Attributes::RmsVoltageMax::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ElectricalMeasurementCluster::ReportAttributeRmsVoltageMax(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ElectricalMeasurement::Attributes::RmsVoltageMax::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::ReadAttributeRmsCurrent(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000508;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::SubscribeAttributeRmsCurrent(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ElectricalMeasurement::Attributes::RmsCurrent::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ElectricalMeasurementCluster::ReportAttributeRmsCurrent(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ElectricalMeasurement::Attributes::RmsCurrent::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::ReadAttributeRmsCurrentMin(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000509;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::SubscribeAttributeRmsCurrentMin(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ElectricalMeasurement::Attributes::RmsCurrentMin::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ElectricalMeasurementCluster::ReportAttributeRmsCurrentMin(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ElectricalMeasurement::Attributes::RmsCurrentMin::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::ReadAttributeRmsCurrentMax(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000050A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::SubscribeAttributeRmsCurrentMax(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ElectricalMeasurement::Attributes::RmsCurrentMax::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ElectricalMeasurementCluster::ReportAttributeRmsCurrentMax(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ElectricalMeasurement::Attributes::RmsCurrentMax::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::ReadAttributeActivePower(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000050B;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::SubscribeAttributeActivePower(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback,
                                                                       uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ElectricalMeasurement::Attributes::ActivePower::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ElectricalMeasurementCluster::ReportAttributeActivePower(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ElectricalMeasurement::Attributes::ActivePower::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::ReadAttributeActivePowerMin(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000050C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::SubscribeAttributeActivePowerMin(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ElectricalMeasurement::Attributes::ActivePowerMin::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ElectricalMeasurementCluster::ReportAttributeActivePowerMin(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ElectricalMeasurement::Attributes::ActivePowerMin::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::ReadAttributeActivePowerMax(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000050D;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::SubscribeAttributeActivePowerMax(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ElectricalMeasurement::Attributes::ActivePowerMax::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ElectricalMeasurementCluster::ReportAttributeActivePowerMax(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ElectricalMeasurement::Attributes::ActivePowerMax::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ElectricalMeasurementCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ElectricalMeasurementCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// EthernetNetworkDiagnostics Cluster Commands
CHIP_ERROR EthernetNetworkDiagnosticsCluster::ResetCounts(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         EthernetNetworkDiagnostics::Commands::ResetCounts::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// EthernetNetworkDiagnostics Cluster Attributes
CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReadAttributePHYRate(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::SubscribeAttributePHYRate(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = EthernetNetworkDiagnostics::Attributes::PHYRate::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReportAttributePHYRate(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(EthernetNetworkDiagnostics::Attributes::PHYRate::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReadAttributeFullDuplex(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::SubscribeAttributeFullDuplex(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = EthernetNetworkDiagnostics::Attributes::FullDuplex::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReportAttributeFullDuplex(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(EthernetNetworkDiagnostics::Attributes::FullDuplex::Id, onReportCallback,
                                     BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReadAttributePacketRxCount(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::SubscribeAttributePacketRxCount(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = EthernetNetworkDiagnostics::Attributes::PacketRxCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReportAttributePacketRxCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(EthernetNetworkDiagnostics::Attributes::PacketRxCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReadAttributePacketTxCount(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::SubscribeAttributePacketTxCount(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = EthernetNetworkDiagnostics::Attributes::PacketTxCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReportAttributePacketTxCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(EthernetNetworkDiagnostics::Attributes::PacketTxCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReadAttributeTxErrCount(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::SubscribeAttributeTxErrCount(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = EthernetNetworkDiagnostics::Attributes::TxErrCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReportAttributeTxErrCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(EthernetNetworkDiagnostics::Attributes::TxErrCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReadAttributeCollisionCount(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000005;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::SubscribeAttributeCollisionCount(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback,
                                                                               uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = EthernetNetworkDiagnostics::Attributes::CollisionCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReportAttributeCollisionCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(EthernetNetworkDiagnostics::Attributes::CollisionCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReadAttributeOverrunCount(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000006;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::SubscribeAttributeOverrunCount(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback,
                                                                             uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = EthernetNetworkDiagnostics::Attributes::OverrunCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReportAttributeOverrunCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(EthernetNetworkDiagnostics::Attributes::OverrunCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReadAttributeCarrierDetect(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000007;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::SubscribeAttributeCarrierDetect(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = EthernetNetworkDiagnostics::Attributes::CarrierDetect::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReportAttributeCarrierDetect(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(EthernetNetworkDiagnostics::Attributes::CarrierDetect::Id, onReportCallback,
                                     BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReadAttributeTimeSinceReset(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000008;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::SubscribeAttributeTimeSinceReset(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback,
                                                                               uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = EthernetNetworkDiagnostics::Attributes::TimeSinceReset::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReportAttributeTimeSinceReset(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(EthernetNetworkDiagnostics::Attributes::TimeSinceReset::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback,
                                                                                uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR EthernetNetworkDiagnosticsCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// FixedLabel Cluster Commands
// FixedLabel Cluster Attributes
CHIP_ERROR FixedLabelCluster::ReadAttributeLabelList(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             FixedLabelClusterLabelListListAttributeFilter);
}

CHIP_ERROR FixedLabelCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR FixedLabelCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR FixedLabelCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// FlowMeasurement Cluster Commands
// FlowMeasurement Cluster Attributes
CHIP_ERROR FlowMeasurementCluster::ReadAttributeMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR FlowMeasurementCluster::SubscribeAttributeMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                   uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = FlowMeasurement::Attributes::MeasuredValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR FlowMeasurementCluster::ReportAttributeMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(FlowMeasurement::Attributes::MeasuredValue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR FlowMeasurementCluster::ReadAttributeMinMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR FlowMeasurementCluster::SubscribeAttributeMinMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = FlowMeasurement::Attributes::MinMeasuredValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR FlowMeasurementCluster::ReportAttributeMinMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(FlowMeasurement::Attributes::MinMeasuredValue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR FlowMeasurementCluster::ReadAttributeMaxMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR FlowMeasurementCluster::SubscribeAttributeMaxMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = FlowMeasurement::Attributes::MaxMeasuredValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR FlowMeasurementCluster::ReportAttributeMaxMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(FlowMeasurement::Attributes::MaxMeasuredValue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR FlowMeasurementCluster::ReadAttributeTolerance(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR FlowMeasurementCluster::SubscribeAttributeTolerance(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = FlowMeasurement::Attributes::Tolerance::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR FlowMeasurementCluster::ReportAttributeTolerance(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(FlowMeasurement::Attributes::Tolerance::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR FlowMeasurementCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR FlowMeasurementCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR FlowMeasurementCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// GeneralCommissioning Cluster Commands
CHIP_ERROR GeneralCommissioningCluster::ArmFailSafe(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback, uint16_t expiryLengthSeconds,
                                                    uint64_t breadcrumb, uint32_t timeoutMs)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, GeneralCommissioning::Commands::ArmFailSafe::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // expiryLengthSeconds: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), expiryLengthSeconds));
    // breadcrumb: int64u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR GeneralCommissioningCluster::CommissioningComplete(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         GeneralCommissioning::Commands::CommissioningComplete::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR GeneralCommissioningCluster::SetRegulatoryConfig(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint8_t location,
                                                            chip::CharSpan countryCode, uint64_t breadcrumb, uint32_t timeoutMs)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         GeneralCommissioning::Commands::SetRegulatoryConfig::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // location: regulatoryLocationType
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), location));
    // countryCode: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), countryCode));
    // breadcrumb: int64u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// GeneralCommissioning Cluster Attributes
CHIP_ERROR GeneralCommissioningCluster::ReadAttributeBreadcrumb(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR GeneralCommissioningCluster::WriteAttributeBreadcrumb(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint64_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, GeneralCommissioning::Attributes::Breadcrumb::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR GeneralCommissioningCluster::SubscribeAttributeBreadcrumb(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = GeneralCommissioning::Attributes::Breadcrumb::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR GeneralCommissioningCluster::ReportAttributeBreadcrumb(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(GeneralCommissioning::Attributes::Breadcrumb::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR GeneralCommissioningCluster::ReadAttributeBasicCommissioningInfoList(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             GeneralCommissioningClusterBasicCommissioningInfoListListAttributeFilter);
}

CHIP_ERROR GeneralCommissioningCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR GeneralCommissioningCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR GeneralCommissioningCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// GeneralDiagnostics Cluster Commands
// GeneralDiagnostics Cluster Attributes
CHIP_ERROR GeneralDiagnosticsCluster::ReadAttributeNetworkInterfaces(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             GeneralDiagnosticsClusterNetworkInterfacesListAttributeFilter);
}

CHIP_ERROR GeneralDiagnosticsCluster::ReadAttributeRebootCount(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR GeneralDiagnosticsCluster::SubscribeAttributeRebootCount(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = GeneralDiagnostics::Attributes::RebootCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR GeneralDiagnosticsCluster::ReportAttributeRebootCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(GeneralDiagnostics::Attributes::RebootCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR GeneralDiagnosticsCluster::ReadAttributeUpTime(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR GeneralDiagnosticsCluster::SubscribeAttributeUpTime(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = GeneralDiagnostics::Attributes::UpTime::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR GeneralDiagnosticsCluster::ReportAttributeUpTime(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(GeneralDiagnostics::Attributes::UpTime::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR GeneralDiagnosticsCluster::ReadAttributeTotalOperationalHours(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR GeneralDiagnosticsCluster::SubscribeAttributeTotalOperationalHours(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = GeneralDiagnostics::Attributes::TotalOperationalHours::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR GeneralDiagnosticsCluster::ReportAttributeTotalOperationalHours(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(GeneralDiagnostics::Attributes::TotalOperationalHours::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR GeneralDiagnosticsCluster::ReadAttributeBootReasons(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR GeneralDiagnosticsCluster::SubscribeAttributeBootReasons(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = GeneralDiagnostics::Attributes::BootReasons::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR GeneralDiagnosticsCluster::ReportAttributeBootReasons(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(GeneralDiagnostics::Attributes::BootReasons::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR GeneralDiagnosticsCluster::ReadAttributeActiveHardwareFaults(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000005;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             GeneralDiagnosticsClusterActiveHardwareFaultsListAttributeFilter);
}

CHIP_ERROR GeneralDiagnosticsCluster::ReadAttributeActiveRadioFaults(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000006;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             GeneralDiagnosticsClusterActiveRadioFaultsListAttributeFilter);
}

CHIP_ERROR GeneralDiagnosticsCluster::ReadAttributeActiveNetworkFaults(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000007;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             GeneralDiagnosticsClusterActiveNetworkFaultsListAttributeFilter);
}

CHIP_ERROR GeneralDiagnosticsCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR GeneralDiagnosticsCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR GeneralDiagnosticsCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// GroupKeyManagement Cluster Commands
// GroupKeyManagement Cluster Attributes
CHIP_ERROR GroupKeyManagementCluster::ReadAttributeGroups(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             GroupKeyManagementClusterGroupsListAttributeFilter);
}

CHIP_ERROR GroupKeyManagementCluster::ReadAttributeGroupKeys(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             GroupKeyManagementClusterGroupKeysListAttributeFilter);
}

CHIP_ERROR GroupKeyManagementCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR GroupKeyManagementCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR GroupKeyManagementCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// Groups Cluster Commands
CHIP_ERROR GroupsCluster::AddGroup(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                   uint16_t groupId, chip::CharSpan groupName)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Groups::Commands::AddGroup::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // groupId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), groupId));
    // groupName: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), groupName));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR GroupsCluster::AddGroupIfIdentifying(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                uint16_t groupId, chip::CharSpan groupName)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Groups::Commands::AddGroupIfIdentifying::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // groupId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), groupId));
    // groupName: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), groupName));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR GroupsCluster::GetGroupMembership(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                             uint16_t groupList)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Groups::Commands::GetGroupMembership::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // groupList: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), groupList));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR GroupsCluster::RemoveAllGroups(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Groups::Commands::RemoveAllGroups::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR GroupsCluster::RemoveGroup(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                      uint16_t groupId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Groups::Commands::RemoveGroup::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // groupId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), groupId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR GroupsCluster::ViewGroup(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                    uint16_t groupId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Groups::Commands::ViewGroup::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // groupId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), groupId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// Groups Cluster Attributes
CHIP_ERROR GroupsCluster::ReadAttributeNameSupport(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR GroupsCluster::SubscribeAttributeNameSupport(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Groups::Attributes::NameSupport::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR GroupsCluster::ReportAttributeNameSupport(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Groups::Attributes::NameSupport::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR GroupsCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR GroupsCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR GroupsCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// Identify Cluster Commands
CHIP_ERROR IdentifyCluster::Identify(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                     uint16_t identifyTime)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Identify::Commands::Identify::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // identifyTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), identifyTime));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR IdentifyCluster::IdentifyQuery(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Identify::Commands::IdentifyQuery::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR IdentifyCluster::TriggerEffect(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                          uint8_t effectIdentifier, uint8_t effectVariant)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Identify::Commands::TriggerEffect::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // effectIdentifier: identifyEffectIdentifier
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), effectIdentifier));
    // effectVariant: identifyEffectVariant
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), effectVariant));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// Identify Cluster Attributes
CHIP_ERROR IdentifyCluster::ReadAttributeIdentifyTime(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR IdentifyCluster::WriteAttributeIdentifyTime(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, Identify::Attributes::IdentifyTime::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IdentifyCluster::SubscribeAttributeIdentifyTime(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                           uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Identify::Attributes::IdentifyTime::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IdentifyCluster::ReportAttributeIdentifyTime(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Identify::Attributes::IdentifyTime::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR IdentifyCluster::ReadAttributeIdentifyType(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR IdentifyCluster::SubscribeAttributeIdentifyType(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                           uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Identify::Attributes::IdentifyType::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IdentifyCluster::ReportAttributeIdentifyType(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Identify::Attributes::IdentifyType::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR IdentifyCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR IdentifyCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                              uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IdentifyCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// IlluminanceMeasurement Cluster Commands
// IlluminanceMeasurement Cluster Attributes
CHIP_ERROR IlluminanceMeasurementCluster::ReadAttributeMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR IlluminanceMeasurementCluster::SubscribeAttributeMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = IlluminanceMeasurement::Attributes::MeasuredValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IlluminanceMeasurementCluster::ReportAttributeMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(IlluminanceMeasurement::Attributes::MeasuredValue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR IlluminanceMeasurementCluster::ReadAttributeMinMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR IlluminanceMeasurementCluster::SubscribeAttributeMinMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback,
                                                                             uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = IlluminanceMeasurement::Attributes::MinMeasuredValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IlluminanceMeasurementCluster::ReportAttributeMinMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(IlluminanceMeasurement::Attributes::MinMeasuredValue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR IlluminanceMeasurementCluster::ReadAttributeMaxMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR IlluminanceMeasurementCluster::SubscribeAttributeMaxMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback,
                                                                             uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = IlluminanceMeasurement::Attributes::MaxMeasuredValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IlluminanceMeasurementCluster::ReportAttributeMaxMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(IlluminanceMeasurement::Attributes::MaxMeasuredValue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR IlluminanceMeasurementCluster::ReadAttributeTolerance(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR IlluminanceMeasurementCluster::SubscribeAttributeTolerance(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = IlluminanceMeasurement::Attributes::Tolerance::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IlluminanceMeasurementCluster::ReportAttributeTolerance(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(IlluminanceMeasurement::Attributes::Tolerance::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR IlluminanceMeasurementCluster::ReadAttributeLightSensorType(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR IlluminanceMeasurementCluster::SubscribeAttributeLightSensorType(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = IlluminanceMeasurement::Attributes::LightSensorType::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IlluminanceMeasurementCluster::ReportAttributeLightSensorType(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(IlluminanceMeasurement::Attributes::LightSensorType::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR IlluminanceMeasurementCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR IlluminanceMeasurementCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IlluminanceMeasurementCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// KeypadInput Cluster Commands
CHIP_ERROR KeypadInputCluster::SendKey(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                       uint8_t keyCode)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, KeypadInput::Commands::SendKey::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // keyCode: keypadInputCecKeyCode
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), keyCode));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// KeypadInput Cluster Attributes
CHIP_ERROR KeypadInputCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR KeypadInputCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR KeypadInputCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// LevelControl Cluster Commands
CHIP_ERROR LevelControlCluster::Move(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                     uint8_t moveMode, uint8_t rate, uint8_t optionMask, uint8_t optionOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, LevelControl::Commands::Move::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // moveMode: moveMode
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), moveMode));
    // rate: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), rate));
    // optionMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionMask));
    // optionOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR LevelControlCluster::MoveToLevel(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                            uint8_t level, uint16_t transitionTime, uint8_t optionMask, uint8_t optionOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, LevelControl::Commands::MoveToLevel::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // level: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), level));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionMask));
    // optionOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR LevelControlCluster::MoveToLevelWithOnOff(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, uint8_t level,
                                                     uint16_t transitionTime)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, LevelControl::Commands::MoveToLevelWithOnOff::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // level: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), level));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR LevelControlCluster::MoveWithOnOff(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                              uint8_t moveMode, uint8_t rate)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, LevelControl::Commands::MoveWithOnOff::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // moveMode: moveMode
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), moveMode));
    // rate: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), rate));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR LevelControlCluster::Step(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                     uint8_t stepMode, uint8_t stepSize, uint16_t transitionTime, uint8_t optionMask,
                                     uint8_t optionOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, LevelControl::Commands::Step::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // stepMode: stepMode
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), stepMode));
    // stepSize: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), stepSize));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionMask));
    // optionOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR LevelControlCluster::StepWithOnOff(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                              uint8_t stepMode, uint8_t stepSize, uint16_t transitionTime)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, LevelControl::Commands::StepWithOnOff::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // stepMode: stepMode
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), stepMode));
    // stepSize: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), stepSize));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR LevelControlCluster::Stop(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                     uint8_t optionMask, uint8_t optionOverride)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, LevelControl::Commands::Stop::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // optionMask: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionMask));
    // optionOverride: bitmap8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), optionOverride));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR LevelControlCluster::StopWithOnOff(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, LevelControl::Commands::StopWithOnOff::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// LevelControl Cluster Attributes
CHIP_ERROR LevelControlCluster::ReadAttributeCurrentLevel(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::SubscribeAttributeCurrentLevel(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = LevelControl::Attributes::CurrentLevel::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeCurrentLevel(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(LevelControl::Attributes::CurrentLevel::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::ReadAttributeRemainingTime(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::SubscribeAttributeRemainingTime(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = LevelControl::Attributes::RemainingTime::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeRemainingTime(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(LevelControl::Attributes::RemainingTime::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::ReadAttributeMinLevel(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::SubscribeAttributeMinLevel(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                           uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = LevelControl::Attributes::MinLevel::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeMinLevel(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(LevelControl::Attributes::MinLevel::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::ReadAttributeMaxLevel(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::SubscribeAttributeMaxLevel(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                           uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = LevelControl::Attributes::MaxLevel::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeMaxLevel(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(LevelControl::Attributes::MaxLevel::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::ReadAttributeCurrentFrequency(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::SubscribeAttributeCurrentFrequency(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                   uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = LevelControl::Attributes::CurrentFrequency::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeCurrentFrequency(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(LevelControl::Attributes::CurrentFrequency::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::ReadAttributeMinFrequency(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000005;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::SubscribeAttributeMinFrequency(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = LevelControl::Attributes::MinFrequency::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeMinFrequency(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(LevelControl::Attributes::MinFrequency::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::ReadAttributeMaxFrequency(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000006;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::SubscribeAttributeMaxFrequency(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = LevelControl::Attributes::MaxFrequency::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeMaxFrequency(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(LevelControl::Attributes::MaxFrequency::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::ReadAttributeOptions(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000F;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::WriteAttributeOptions(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, LevelControl::Attributes::Options::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::SubscribeAttributeOptions(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                          uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = LevelControl::Attributes::Options::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeOptions(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(LevelControl::Attributes::Options::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::ReadAttributeOnOffTransitionTime(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000010;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::WriteAttributeOnOffTransitionTime(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, LevelControl::Attributes::OnOffTransitionTime::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::SubscribeAttributeOnOffTransitionTime(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = LevelControl::Attributes::OnOffTransitionTime::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeOnOffTransitionTime(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(LevelControl::Attributes::OnOffTransitionTime::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::ReadAttributeOnLevel(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000011;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::WriteAttributeOnLevel(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, LevelControl::Attributes::OnLevel::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::SubscribeAttributeOnLevel(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                          uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = LevelControl::Attributes::OnLevel::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeOnLevel(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(LevelControl::Attributes::OnLevel::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::ReadAttributeOnTransitionTime(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000012;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::WriteAttributeOnTransitionTime(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, LevelControl::Attributes::OnTransitionTime::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::SubscribeAttributeOnTransitionTime(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                   uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = LevelControl::Attributes::OnTransitionTime::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeOnTransitionTime(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(LevelControl::Attributes::OnTransitionTime::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::ReadAttributeOffTransitionTime(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000013;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::WriteAttributeOffTransitionTime(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, LevelControl::Attributes::OffTransitionTime::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::SubscribeAttributeOffTransitionTime(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = LevelControl::Attributes::OffTransitionTime::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeOffTransitionTime(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(LevelControl::Attributes::OffTransitionTime::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::ReadAttributeDefaultMoveRate(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000014;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::WriteAttributeDefaultMoveRate(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, LevelControl::Attributes::DefaultMoveRate::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::SubscribeAttributeDefaultMoveRate(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                  uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = LevelControl::Attributes::DefaultMoveRate::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeDefaultMoveRate(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(LevelControl::Attributes::DefaultMoveRate::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::ReadAttributeStartUpCurrentLevel(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00004000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::WriteAttributeStartUpCurrentLevel(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, LevelControl::Attributes::StartUpCurrentLevel::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::SubscribeAttributeStartUpCurrentLevel(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = LevelControl::Attributes::StartUpCurrentLevel::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeStartUpCurrentLevel(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(LevelControl::Attributes::StartUpCurrentLevel::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LevelControlCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                  uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// LowPower Cluster Commands
CHIP_ERROR LowPowerCluster::Sleep(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, LowPower::Commands::Sleep::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// LowPower Cluster Attributes
CHIP_ERROR LowPowerCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR LowPowerCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                              uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LowPowerCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// MediaInput Cluster Commands
CHIP_ERROR MediaInputCluster::HideInputStatus(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, MediaInput::Commands::HideInputStatus::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR MediaInputCluster::RenameInput(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                          uint8_t index, chip::CharSpan name)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, MediaInput::Commands::RenameInput::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // index: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), index));
    // name: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), name));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR MediaInputCluster::SelectInput(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                          uint8_t index)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, MediaInput::Commands::SelectInput::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // index: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), index));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR MediaInputCluster::ShowInputStatus(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, MediaInput::Commands::ShowInputStatus::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// MediaInput Cluster Attributes
CHIP_ERROR MediaInputCluster::ReadAttributeMediaInputList(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             MediaInputClusterMediaInputListListAttributeFilter);
}

CHIP_ERROR MediaInputCluster::ReadAttributeCurrentMediaInput(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR MediaInputCluster::SubscribeAttributeCurrentMediaInput(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                  uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = MediaInput::Attributes::CurrentMediaInput::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR MediaInputCluster::ReportAttributeCurrentMediaInput(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(MediaInput::Attributes::CurrentMediaInput::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR MediaInputCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR MediaInputCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR MediaInputCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// MediaPlayback Cluster Commands
CHIP_ERROR MediaPlaybackCluster::MediaFastForward(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, MediaPlayback::Commands::MediaFastForward::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR MediaPlaybackCluster::MediaNext(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, MediaPlayback::Commands::MediaNext::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR MediaPlaybackCluster::MediaPause(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, MediaPlayback::Commands::MediaPause::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR MediaPlaybackCluster::MediaPlay(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, MediaPlayback::Commands::MediaPlay::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR MediaPlaybackCluster::MediaPrevious(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, MediaPlayback::Commands::MediaPrevious::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR MediaPlaybackCluster::MediaRewind(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, MediaPlayback::Commands::MediaRewind::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR MediaPlaybackCluster::MediaSeek(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                           uint64_t position)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, MediaPlayback::Commands::MediaSeek::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // position: int64u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), position));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR MediaPlaybackCluster::MediaSkipBackward(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback, uint64_t deltaPositionMilliseconds)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, MediaPlayback::Commands::MediaSkipBackward::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // deltaPositionMilliseconds: int64u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), deltaPositionMilliseconds));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR MediaPlaybackCluster::MediaSkipForward(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback, uint64_t deltaPositionMilliseconds)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, MediaPlayback::Commands::MediaSkipForward::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // deltaPositionMilliseconds: int64u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), deltaPositionMilliseconds));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR MediaPlaybackCluster::MediaStartOver(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, MediaPlayback::Commands::MediaStartOver::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR MediaPlaybackCluster::MediaStop(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, MediaPlayback::Commands::MediaStop::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// MediaPlayback Cluster Attributes
CHIP_ERROR MediaPlaybackCluster::ReadAttributePlaybackState(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::SubscribeAttributePlaybackState(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = MediaPlayback::Attributes::PlaybackState::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR MediaPlaybackCluster::ReportAttributePlaybackState(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(MediaPlayback::Attributes::PlaybackState::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::ReadAttributeStartTime(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::SubscribeAttributeStartTime(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                             uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = MediaPlayback::Attributes::StartTime::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR MediaPlaybackCluster::ReportAttributeStartTime(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(MediaPlayback::Attributes::StartTime::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::ReadAttributeDuration(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::SubscribeAttributeDuration(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = MediaPlayback::Attributes::Duration::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR MediaPlaybackCluster::ReportAttributeDuration(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(MediaPlayback::Attributes::Duration::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::ReadAttributePositionUpdatedAt(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::SubscribeAttributePositionUpdatedAt(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = MediaPlayback::Attributes::PositionUpdatedAt::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR MediaPlaybackCluster::ReportAttributePositionUpdatedAt(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(MediaPlayback::Attributes::PositionUpdatedAt::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::ReadAttributePosition(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::SubscribeAttributePosition(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = MediaPlayback::Attributes::Position::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR MediaPlaybackCluster::ReportAttributePosition(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(MediaPlayback::Attributes::Position::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::ReadAttributePlaybackSpeed(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000005;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::SubscribeAttributePlaybackSpeed(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = MediaPlayback::Attributes::PlaybackSpeed::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR MediaPlaybackCluster::ReportAttributePlaybackSpeed(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(MediaPlayback::Attributes::PlaybackSpeed::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::ReadAttributeSeekRangeEnd(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000006;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::SubscribeAttributeSeekRangeEnd(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = MediaPlayback::Attributes::SeekRangeEnd::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR MediaPlaybackCluster::ReportAttributeSeekRangeEnd(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(MediaPlayback::Attributes::SeekRangeEnd::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::ReadAttributeSeekRangeStart(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000007;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::SubscribeAttributeSeekRangeStart(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                  uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = MediaPlayback::Attributes::SeekRangeStart::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR MediaPlaybackCluster::ReportAttributeSeekRangeStart(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(MediaPlayback::Attributes::SeekRangeStart::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR MediaPlaybackCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                   uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR MediaPlaybackCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// ModeSelect Cluster Commands
CHIP_ERROR ModeSelectCluster::ChangeToMode(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                           uint8_t newMode)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, ModeSelect::Commands::ChangeToMode::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // newMode: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), newMode));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// ModeSelect Cluster Attributes
CHIP_ERROR ModeSelectCluster::ReadAttributeCurrentMode(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ModeSelectCluster::SubscribeAttributeCurrentMode(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ModeSelect::Attributes::CurrentMode::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ModeSelectCluster::ReportAttributeCurrentMode(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ModeSelect::Attributes::CurrentMode::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ModeSelectCluster::ReadAttributeSupportedModes(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             ModeSelectClusterSupportedModesListAttributeFilter);
}

CHIP_ERROR ModeSelectCluster::ReadAttributeOnMode(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ModeSelectCluster::WriteAttributeOnMode(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, ModeSelect::Attributes::OnMode::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ModeSelectCluster::SubscribeAttributeOnMode(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                       uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ModeSelect::Attributes::OnMode::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ModeSelectCluster::ReportAttributeOnMode(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ModeSelect::Attributes::OnMode::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ModeSelectCluster::ReadAttributeStartUpMode(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ModeSelectCluster::SubscribeAttributeStartUpMode(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ModeSelect::Attributes::StartUpMode::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ModeSelectCluster::ReportAttributeStartUpMode(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ModeSelect::Attributes::StartUpMode::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ModeSelectCluster::ReadAttributeDescription(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR ModeSelectCluster::SubscribeAttributeDescription(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ModeSelect::Attributes::Description::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ModeSelectCluster::ReportAttributeDescription(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ModeSelect::Attributes::Description::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR ModeSelectCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ModeSelectCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ModeSelectCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// NetworkCommissioning Cluster Commands
CHIP_ERROR NetworkCommissioningCluster::AddThreadNetwork(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback,
                                                         chip::ByteSpan operationalDataset, uint64_t breadcrumb, uint32_t timeoutMs)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         NetworkCommissioning::Commands::AddThreadNetwork::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // operationalDataset: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), operationalDataset));
    // breadcrumb: int64u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR NetworkCommissioningCluster::AddWiFiNetwork(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, chip::ByteSpan ssid,
                                                       chip::ByteSpan credentials, uint64_t breadcrumb, uint32_t timeoutMs)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         NetworkCommissioning::Commands::AddWiFiNetwork::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // ssid: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), ssid));
    // credentials: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), credentials));
    // breadcrumb: int64u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR NetworkCommissioningCluster::DisableNetwork(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, chip::ByteSpan networkID,
                                                       uint64_t breadcrumb, uint32_t timeoutMs)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         NetworkCommissioning::Commands::DisableNetwork::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // networkID: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), networkID));
    // breadcrumb: int64u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR NetworkCommissioningCluster::EnableNetwork(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback, chip::ByteSpan networkID,
                                                      uint64_t breadcrumb, uint32_t timeoutMs)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, NetworkCommissioning::Commands::EnableNetwork::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // networkID: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), networkID));
    // breadcrumb: int64u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR NetworkCommissioningCluster::RemoveNetwork(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback, chip::ByteSpan networkID,
                                                      uint64_t breadcrumb, uint32_t timeoutMs)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, NetworkCommissioning::Commands::RemoveNetwork::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // networkID: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), networkID));
    // breadcrumb: int64u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR NetworkCommissioningCluster::ScanNetworks(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, chip::ByteSpan ssid,
                                                     uint64_t breadcrumb, uint32_t timeoutMs)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, NetworkCommissioning::Commands::ScanNetworks::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // ssid: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), ssid));
    // breadcrumb: int64u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR NetworkCommissioningCluster::UpdateThreadNetwork(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback,
                                                            chip::ByteSpan operationalDataset, uint64_t breadcrumb,
                                                            uint32_t timeoutMs)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         NetworkCommissioning::Commands::UpdateThreadNetwork::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // operationalDataset: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), operationalDataset));
    // breadcrumb: int64u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR NetworkCommissioningCluster::UpdateWiFiNetwork(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback, chip::ByteSpan ssid,
                                                          chip::ByteSpan credentials, uint64_t breadcrumb, uint32_t timeoutMs)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         NetworkCommissioning::Commands::UpdateWiFiNetwork::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // ssid: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), ssid));
    // credentials: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), credentials));
    // breadcrumb: int64u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// NetworkCommissioning Cluster Attributes
CHIP_ERROR NetworkCommissioningCluster::ReadAttributeFeatureMap(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFC;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR NetworkCommissioningCluster::SubscribeAttributeFeatureMap(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::FeatureMap::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR NetworkCommissioningCluster::ReportAttributeFeatureMap(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::FeatureMap::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR NetworkCommissioningCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR NetworkCommissioningCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR NetworkCommissioningCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// OtaSoftwareUpdateProvider Cluster Commands
CHIP_ERROR OtaSoftwareUpdateProviderCluster::ApplyUpdateRequest(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback,
                                                                chip::ByteSpan updateToken, uint32_t newVersion)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         OtaSoftwareUpdateProvider::Commands::ApplyUpdateRequest::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // updateToken: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), updateToken));
    // newVersion: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), newVersion));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR OtaSoftwareUpdateProviderCluster::NotifyUpdateApplied(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback,
                                                                 chip::ByteSpan updateToken, uint32_t softwareVersion)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         OtaSoftwareUpdateProvider::Commands::NotifyUpdateApplied::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // updateToken: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), updateToken));
    // softwareVersion: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), softwareVersion));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR OtaSoftwareUpdateProviderCluster::QueryImage(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, chip::VendorId vendorId,
                                                        uint16_t productId, uint32_t softwareVersion, uint8_t protocolsSupported,
                                                        uint16_t hardwareVersion, chip::CharSpan location, bool requestorCanConsent,
                                                        chip::ByteSpan metadataForProvider)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         OtaSoftwareUpdateProvider::Commands::QueryImage::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // vendorId: vendorId
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), vendorId));
    // productId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), productId));
    // softwareVersion: int32u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), softwareVersion));
    // protocolsSupported: OTADownloadProtocol
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), protocolsSupported));
    // hardwareVersion: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), hardwareVersion));
    // location: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), location));
    // requestorCanConsent: boolean
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), requestorCanConsent));
    // metadataForProvider: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), metadataForProvider));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// OtaSoftwareUpdateProvider Cluster Attributes
CHIP_ERROR OtaSoftwareUpdateProviderCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR OtaSoftwareUpdateProviderCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback,
                                                                               uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OtaSoftwareUpdateProviderCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// OtaSoftwareUpdateRequestor Cluster Commands
CHIP_ERROR OtaSoftwareUpdateRequestorCluster::AnnounceOtaProvider(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback,
                                                                  chip::NodeId providerLocation, chip::VendorId vendorId,
                                                                  uint8_t announcementReason, chip::ByteSpan metadataForNode)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         OtaSoftwareUpdateRequestor::Commands::AnnounceOtaProvider::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // providerLocation: nodeId
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), providerLocation));
    // vendorId: vendorId
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), vendorId));
    // announcementReason: OTAAnnouncementReason
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), announcementReason));
    // metadataForNode: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), metadataForNode));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// OtaSoftwareUpdateRequestor Cluster Attributes
CHIP_ERROR OtaSoftwareUpdateRequestorCluster::ReadAttributeDefaultOtaProvider(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR OtaSoftwareUpdateRequestorCluster::WriteAttributeDefaultOtaProvider(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback,
                                                                               chip::ByteSpan value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, OtaSoftwareUpdateRequestor::Attributes::DefaultOtaProvider::Id),
        value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OtaSoftwareUpdateRequestorCluster::SubscribeAttributeDefaultOtaProvider(Callback::Cancelable * onSuccessCallback,
                                                                                   Callback::Cancelable * onFailureCallback,
                                                                                   uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = OtaSoftwareUpdateRequestor::Attributes::DefaultOtaProvider::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OtaSoftwareUpdateRequestorCluster::ReportAttributeDefaultOtaProvider(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(OtaSoftwareUpdateRequestor::Attributes::DefaultOtaProvider::Id, onReportCallback,
                                     BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR OtaSoftwareUpdateRequestorCluster::ReadAttributeUpdatePossible(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR OtaSoftwareUpdateRequestorCluster::SubscribeAttributeUpdatePossible(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback,
                                                                               uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = OtaSoftwareUpdateRequestor::Attributes::UpdatePossible::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OtaSoftwareUpdateRequestorCluster::ReportAttributeUpdatePossible(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(OtaSoftwareUpdateRequestor::Attributes::UpdatePossible::Id, onReportCallback,
                                     BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR OtaSoftwareUpdateRequestorCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR OtaSoftwareUpdateRequestorCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback,
                                                                                uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OtaSoftwareUpdateRequestorCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// OccupancySensing Cluster Commands
// OccupancySensing Cluster Attributes
CHIP_ERROR OccupancySensingCluster::ReadAttributeOccupancy(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OccupancySensingCluster::SubscribeAttributeOccupancy(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = OccupancySensing::Attributes::Occupancy::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OccupancySensingCluster::ReportAttributeOccupancy(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(OccupancySensing::Attributes::Occupancy::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OccupancySensingCluster::ReadAttributeOccupancySensorType(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OccupancySensingCluster::SubscribeAttributeOccupancySensorType(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = OccupancySensing::Attributes::OccupancySensorType::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OccupancySensingCluster::ReportAttributeOccupancySensorType(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(OccupancySensing::Attributes::OccupancySensorType::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OccupancySensingCluster::ReadAttributeOccupancySensorTypeBitmap(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OccupancySensingCluster::SubscribeAttributeOccupancySensorTypeBitmap(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback,
                                                                                uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = OccupancySensing::Attributes::OccupancySensorTypeBitmap::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OccupancySensingCluster::ReportAttributeOccupancySensorTypeBitmap(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(OccupancySensing::Attributes::OccupancySensorTypeBitmap::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OccupancySensingCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR OccupancySensingCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OccupancySensingCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// OnOff Cluster Commands
CHIP_ERROR OnOffCluster::Off(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, OnOff::Commands::Off::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR OnOffCluster::OffWithEffect(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                       uint8_t effectId, uint8_t effectVariant)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, OnOff::Commands::OffWithEffect::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // effectId: onOffEffectIdentifier
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), effectId));
    // effectVariant: onOffDelayedAllOffEffectVariant
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), effectVariant));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR OnOffCluster::On(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, OnOff::Commands::On::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR OnOffCluster::OnWithRecallGlobalScene(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, OnOff::Commands::OnWithRecallGlobalScene::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR OnOffCluster::OnWithTimedOff(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                        uint8_t onOffControl, uint16_t onTime, uint16_t offWaitTime)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, OnOff::Commands::OnWithTimedOff::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // onOffControl: onOffControl
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), onOffControl));
    // onTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), onTime));
    // offWaitTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), offWaitTime));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR OnOffCluster::Toggle(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, OnOff::Commands::Toggle::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// OnOff Cluster Attributes
CHIP_ERROR OnOffCluster::ReadAttributeOnOff(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR OnOffCluster::SubscribeAttributeOnOff(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = OnOff::Attributes::OnOff::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffCluster::ReportAttributeOnOff(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(OnOff::Attributes::OnOff::Id, onReportCallback,
                                     BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR OnOffCluster::ReadAttributeGlobalSceneControl(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00004000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR OnOffCluster::SubscribeAttributeGlobalSceneControl(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                              uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = OnOff::Attributes::GlobalSceneControl::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffCluster::ReportAttributeGlobalSceneControl(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(OnOff::Attributes::GlobalSceneControl::Id, onReportCallback,
                                     BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR OnOffCluster::ReadAttributeOnTime(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00004001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR OnOffCluster::WriteAttributeOnTime(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                              uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, OnOff::Attributes::OnTime::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffCluster::SubscribeAttributeOnTime(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                  uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = OnOff::Attributes::OnTime::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffCluster::ReportAttributeOnTime(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(OnOff::Attributes::OnTime::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR OnOffCluster::ReadAttributeOffWaitTime(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00004002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR OnOffCluster::WriteAttributeOffWaitTime(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, OnOff::Attributes::OffWaitTime::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffCluster::SubscribeAttributeOffWaitTime(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                       uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = OnOff::Attributes::OffWaitTime::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffCluster::ReportAttributeOffWaitTime(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(OnOff::Attributes::OffWaitTime::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR OnOffCluster::ReadAttributeStartUpOnOff(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00004003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OnOffCluster::WriteAttributeStartUpOnOff(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, OnOff::Attributes::StartUpOnOff::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffCluster::SubscribeAttributeStartUpOnOff(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = OnOff::Attributes::StartUpOnOff::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffCluster::ReportAttributeStartUpOnOff(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(OnOff::Attributes::StartUpOnOff::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OnOffCluster::ReadAttributeFeatureMap(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFC;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR OnOffCluster::SubscribeAttributeFeatureMap(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                      uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::FeatureMap::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffCluster::ReportAttributeFeatureMap(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::FeatureMap::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR OnOffCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR OnOffCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                           uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// OnOffSwitchConfiguration Cluster Commands
// OnOffSwitchConfiguration Cluster Attributes
CHIP_ERROR OnOffSwitchConfigurationCluster::ReadAttributeSwitchType(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OnOffSwitchConfigurationCluster::SubscribeAttributeSwitchType(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = OnOffSwitchConfiguration::Attributes::SwitchType::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffSwitchConfigurationCluster::ReportAttributeSwitchType(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(OnOffSwitchConfiguration::Attributes::SwitchType::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OnOffSwitchConfigurationCluster::ReadAttributeSwitchActions(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000010;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OnOffSwitchConfigurationCluster::WriteAttributeSwitchActions(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, OnOffSwitchConfiguration::Attributes::SwitchActions::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffSwitchConfigurationCluster::SubscribeAttributeSwitchActions(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = OnOffSwitchConfiguration::Attributes::SwitchActions::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffSwitchConfigurationCluster::ReportAttributeSwitchActions(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(OnOffSwitchConfiguration::Attributes::SwitchActions::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OnOffSwitchConfigurationCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR OnOffSwitchConfigurationCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffSwitchConfigurationCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// OperationalCredentials Cluster Commands
CHIP_ERROR OperationalCredentialsCluster::AddNOC(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 chip::ByteSpan NOCValue, chip::ByteSpan ICACValue, chip::ByteSpan IPKValue,
                                                 chip::NodeId caseAdminNode, uint16_t adminVendorId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, OperationalCredentials::Commands::AddNOC::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // NOCValue: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), NOCValue));
    // ICACValue: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), ICACValue));
    // IPKValue: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), IPKValue));
    // caseAdminNode: nodeId
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), caseAdminNode));
    // adminVendorId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), adminVendorId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR OperationalCredentialsCluster::AddTrustedRootCertificate(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback,
                                                                    chip::ByteSpan rootCertificate)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         OperationalCredentials::Commands::AddTrustedRootCertificate::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // rootCertificate: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), rootCertificate));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR OperationalCredentialsCluster::AttestationRequest(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback,
                                                             chip::ByteSpan attestationNonce)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         OperationalCredentials::Commands::AttestationRequest::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // attestationNonce: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), attestationNonce));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR OperationalCredentialsCluster::CertificateChainRequest(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint8_t certificateType)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         OperationalCredentials::Commands::CertificateChainRequest::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // certificateType: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), certificateType));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR OperationalCredentialsCluster::OpCSRRequest(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, chip::ByteSpan CSRNonce)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         OperationalCredentials::Commands::OpCSRRequest::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // CSRNonce: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), CSRNonce));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR OperationalCredentialsCluster::RemoveFabric(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint8_t fabricIndex)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         OperationalCredentials::Commands::RemoveFabric::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // fabricIndex: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), fabricIndex));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR OperationalCredentialsCluster::RemoveTrustedRootCertificate(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback,
                                                                       chip::ByteSpan trustedRootIdentifier)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         OperationalCredentials::Commands::RemoveTrustedRootCertificate::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // trustedRootIdentifier: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), trustedRootIdentifier));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR OperationalCredentialsCluster::UpdateFabricLabel(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, chip::CharSpan label)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         OperationalCredentials::Commands::UpdateFabricLabel::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // label: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), label));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR OperationalCredentialsCluster::UpdateNOC(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback, chip::ByteSpan NOCValue,
                                                    chip::ByteSpan ICACValue)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, OperationalCredentials::Commands::UpdateNOC::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // NOCValue: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), NOCValue));
    // ICACValue: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), ICACValue));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// OperationalCredentials Cluster Attributes
CHIP_ERROR OperationalCredentialsCluster::ReadAttributeFabricsList(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             OperationalCredentialsClusterFabricsListListAttributeFilter);
}

CHIP_ERROR OperationalCredentialsCluster::ReadAttributeSupportedFabrics(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OperationalCredentialsCluster::SubscribeAttributeSupportedFabrics(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback,
                                                                             uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = OperationalCredentials::Attributes::SupportedFabrics::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OperationalCredentialsCluster::ReportAttributeSupportedFabrics(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(OperationalCredentials::Attributes::SupportedFabrics::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OperationalCredentialsCluster::ReadAttributeCommissionedFabrics(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OperationalCredentialsCluster::SubscribeAttributeCommissionedFabrics(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback,
                                                                                uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = OperationalCredentials::Attributes::CommissionedFabrics::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OperationalCredentialsCluster::ReportAttributeCommissionedFabrics(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(OperationalCredentials::Attributes::CommissionedFabrics::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OperationalCredentialsCluster::ReadAttributeTrustedRootCertificates(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             OperationalCredentialsClusterTrustedRootCertificatesListAttributeFilter);
}

CHIP_ERROR OperationalCredentialsCluster::ReadAttributeCurrentFabricIndex(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000005;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OperationalCredentialsCluster::SubscribeAttributeCurrentFabricIndex(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback,
                                                                               uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = OperationalCredentials::Attributes::CurrentFabricIndex::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OperationalCredentialsCluster::ReportAttributeCurrentFabricIndex(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(OperationalCredentials::Attributes::CurrentFabricIndex::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR OperationalCredentialsCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR OperationalCredentialsCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OperationalCredentialsCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// PowerSource Cluster Commands
// PowerSource Cluster Attributes
CHIP_ERROR PowerSourceCluster::ReadAttributeStatus(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::SubscribeAttributeStatus(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PowerSource::Attributes::Status::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PowerSourceCluster::ReportAttributeStatus(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PowerSource::Attributes::Status::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::ReadAttributeOrder(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::SubscribeAttributeOrder(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                       uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PowerSource::Attributes::Order::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PowerSourceCluster::ReportAttributeOrder(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PowerSource::Attributes::Order::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::ReadAttributeDescription(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::SubscribeAttributeDescription(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                             uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PowerSource::Attributes::Description::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PowerSourceCluster::ReportAttributeDescription(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PowerSource::Attributes::Description::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::ReadAttributeBatteryVoltage(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000B;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::SubscribeAttributeBatteryVoltage(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PowerSource::Attributes::BatteryVoltage::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PowerSourceCluster::ReportAttributeBatteryVoltage(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PowerSource::Attributes::BatteryVoltage::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::ReadAttributeBatteryPercentRemaining(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::SubscribeAttributeBatteryPercentRemaining(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PowerSource::Attributes::BatteryPercentRemaining::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PowerSourceCluster::ReportAttributeBatteryPercentRemaining(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PowerSource::Attributes::BatteryPercentRemaining::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::ReadAttributeBatteryTimeRemaining(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000D;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::SubscribeAttributeBatteryTimeRemaining(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PowerSource::Attributes::BatteryTimeRemaining::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PowerSourceCluster::ReportAttributeBatteryTimeRemaining(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PowerSource::Attributes::BatteryTimeRemaining::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::ReadAttributeBatteryChargeLevel(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000E;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::SubscribeAttributeBatteryChargeLevel(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PowerSource::Attributes::BatteryChargeLevel::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PowerSourceCluster::ReportAttributeBatteryChargeLevel(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PowerSource::Attributes::BatteryChargeLevel::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::ReadAttributeActiveBatteryFaults(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000012;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             PowerSourceClusterActiveBatteryFaultsListAttributeFilter);
}

CHIP_ERROR PowerSourceCluster::ReadAttributeBatteryChargeState(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::SubscribeAttributeBatteryChargeState(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PowerSource::Attributes::BatteryChargeState::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PowerSourceCluster::ReportAttributeBatteryChargeState(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PowerSource::Attributes::BatteryChargeState::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::ReadAttributeFeatureMap(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFC;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::SubscribeAttributeFeatureMap(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::FeatureMap::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PowerSourceCluster::ReportAttributeFeatureMap(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::FeatureMap::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PowerSourceCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PowerSourceCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// PressureMeasurement Cluster Commands
// PressureMeasurement Cluster Attributes
CHIP_ERROR PressureMeasurementCluster::ReadAttributeMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PressureMeasurementCluster::SubscribeAttributeMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback,
                                                                       uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PressureMeasurement::Attributes::MeasuredValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PressureMeasurementCluster::ReportAttributeMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PressureMeasurement::Attributes::MeasuredValue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PressureMeasurementCluster::ReadAttributeMinMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PressureMeasurementCluster::SubscribeAttributeMinMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PressureMeasurement::Attributes::MinMeasuredValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PressureMeasurementCluster::ReportAttributeMinMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PressureMeasurement::Attributes::MinMeasuredValue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PressureMeasurementCluster::ReadAttributeMaxMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PressureMeasurementCluster::SubscribeAttributeMaxMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PressureMeasurement::Attributes::MaxMeasuredValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PressureMeasurementCluster::ReportAttributeMaxMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PressureMeasurement::Attributes::MaxMeasuredValue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PressureMeasurementCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PressureMeasurementCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PressureMeasurementCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// PumpConfigurationAndControl Cluster Commands
// PumpConfigurationAndControl Cluster Attributes
CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeMaxPressure(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeMaxPressure(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback,
                                                                             uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::MaxPressure::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeMaxPressure(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::MaxPressure::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeMaxSpeed(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeMaxSpeed(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::MaxSpeed::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeMaxSpeed(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::MaxSpeed::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeMaxFlow(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeMaxFlow(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::MaxFlow::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeMaxFlow(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::MaxFlow::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeMinConstPressure(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeMinConstPressure(Callback::Cancelable * onSuccessCallback,
                                                                                  Callback::Cancelable * onFailureCallback,
                                                                                  uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::MinConstPressure::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeMinConstPressure(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::MinConstPressure::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeMaxConstPressure(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeMaxConstPressure(Callback::Cancelable * onSuccessCallback,
                                                                                  Callback::Cancelable * onFailureCallback,
                                                                                  uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::MaxConstPressure::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeMaxConstPressure(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::MaxConstPressure::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeMinCompPressure(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000005;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeMinCompPressure(Callback::Cancelable * onSuccessCallback,
                                                                                 Callback::Cancelable * onFailureCallback,
                                                                                 uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::MinCompPressure::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeMinCompPressure(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::MinCompPressure::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeMaxCompPressure(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000006;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeMaxCompPressure(Callback::Cancelable * onSuccessCallback,
                                                                                 Callback::Cancelable * onFailureCallback,
                                                                                 uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::MaxCompPressure::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeMaxCompPressure(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::MaxCompPressure::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeMinConstSpeed(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000007;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeMinConstSpeed(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback,
                                                                               uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::MinConstSpeed::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeMinConstSpeed(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::MinConstSpeed::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeMaxConstSpeed(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000008;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeMaxConstSpeed(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback,
                                                                               uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::MaxConstSpeed::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeMaxConstSpeed(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::MaxConstSpeed::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeMinConstFlow(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000009;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeMinConstFlow(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::MinConstFlow::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeMinConstFlow(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::MinConstFlow::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeMaxConstFlow(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeMaxConstFlow(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::MaxConstFlow::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeMaxConstFlow(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::MaxConstFlow::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeMinConstTemp(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000B;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeMinConstTemp(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::MinConstTemp::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeMinConstTemp(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::MinConstTemp::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeMaxConstTemp(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeMaxConstTemp(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::MaxConstTemp::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeMaxConstTemp(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::MaxConstTemp::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributePumpStatus(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000010;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributePumpStatus(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::PumpStatus::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributePumpStatus(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::PumpStatus::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeEffectiveOperationMode(Callback::Cancelable * onSuccessCallback,
                                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000011;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeEffectiveOperationMode(Callback::Cancelable * onSuccessCallback,
                                                                                        Callback::Cancelable * onFailureCallback,
                                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::EffectiveOperationMode::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeEffectiveOperationMode(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::EffectiveOperationMode::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeEffectiveControlMode(Callback::Cancelable * onSuccessCallback,
                                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000012;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeEffectiveControlMode(Callback::Cancelable * onSuccessCallback,
                                                                                      Callback::Cancelable * onFailureCallback,
                                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::EffectiveControlMode::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeEffectiveControlMode(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::EffectiveControlMode::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeCapacity(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000013;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeCapacity(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::Capacity::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeCapacity(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::Capacity::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeSpeed(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000014;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeSpeed(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback,
                                                                       uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::Speed::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeSpeed(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::Speed::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeLifetimeEnergyConsumed(Callback::Cancelable * onSuccessCallback,
                                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000017;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeLifetimeEnergyConsumed(Callback::Cancelable * onSuccessCallback,
                                                                                        Callback::Cancelable * onFailureCallback,
                                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeLifetimeEnergyConsumed(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeOperationMode(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000020;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::WriteAttributeOperationMode(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, PumpConfigurationAndControl::Attributes::OperationMode::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeOperationMode(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback,
                                                                               uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::OperationMode::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeOperationMode(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::OperationMode::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeControlMode(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000021;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::WriteAttributeControlMode(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, PumpConfigurationAndControl::Attributes::ControlMode::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeControlMode(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback,
                                                                             uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::ControlMode::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeControlMode(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::ControlMode::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeAlarmMask(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000022;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeAlarmMask(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = PumpConfigurationAndControl::Attributes::AlarmMask::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeAlarmMask(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(PumpConfigurationAndControl::Attributes::AlarmMask::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeFeatureMap(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFC;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeFeatureMap(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::FeatureMap::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeFeatureMap(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::FeatureMap::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR PumpConfigurationAndControlCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                                 Callback::Cancelable * onFailureCallback,
                                                                                 uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR PumpConfigurationAndControlCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// RelativeHumidityMeasurement Cluster Commands
// RelativeHumidityMeasurement Cluster Attributes
CHIP_ERROR RelativeHumidityMeasurementCluster::ReadAttributeMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR RelativeHumidityMeasurementCluster::SubscribeAttributeMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback,
                                                                               uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = RelativeHumidityMeasurement::Attributes::MeasuredValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR RelativeHumidityMeasurementCluster::ReportAttributeMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(RelativeHumidityMeasurement::Attributes::MeasuredValue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR RelativeHumidityMeasurementCluster::ReadAttributeMinMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR RelativeHumidityMeasurementCluster::SubscribeAttributeMinMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                                  Callback::Cancelable * onFailureCallback,
                                                                                  uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = RelativeHumidityMeasurement::Attributes::MinMeasuredValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR RelativeHumidityMeasurementCluster::ReportAttributeMinMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(RelativeHumidityMeasurement::Attributes::MinMeasuredValue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR RelativeHumidityMeasurementCluster::ReadAttributeMaxMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR RelativeHumidityMeasurementCluster::SubscribeAttributeMaxMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                                  Callback::Cancelable * onFailureCallback,
                                                                                  uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = RelativeHumidityMeasurement::Attributes::MaxMeasuredValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR RelativeHumidityMeasurementCluster::ReportAttributeMaxMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(RelativeHumidityMeasurement::Attributes::MaxMeasuredValue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR RelativeHumidityMeasurementCluster::ReadAttributeTolerance(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR RelativeHumidityMeasurementCluster::SubscribeAttributeTolerance(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = RelativeHumidityMeasurement::Attributes::Tolerance::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR RelativeHumidityMeasurementCluster::ReportAttributeTolerance(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(RelativeHumidityMeasurement::Attributes::Tolerance::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR RelativeHumidityMeasurementCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR RelativeHumidityMeasurementCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                                 Callback::Cancelable * onFailureCallback,
                                                                                 uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR RelativeHumidityMeasurementCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// Scenes Cluster Commands
CHIP_ERROR ScenesCluster::AddScene(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                   uint16_t groupId, uint8_t sceneId, uint16_t transitionTime, chip::CharSpan sceneName,
                                   chip::ClusterId clusterId, uint8_t length, uint8_t value)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Scenes::Commands::AddScene::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // groupId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), groupId));
    // sceneId: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), sceneId));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // sceneName: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), sceneName));
    // clusterId: clusterId
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), clusterId));
    // length: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), length));
    // value: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), value));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ScenesCluster::GetSceneMembership(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                             uint16_t groupId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Scenes::Commands::GetSceneMembership::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // groupId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), groupId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ScenesCluster::RecallScene(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                      uint16_t groupId, uint8_t sceneId, uint16_t transitionTime)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Scenes::Commands::RecallScene::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // groupId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), groupId));
    // sceneId: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), sceneId));
    // transitionTime: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), transitionTime));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ScenesCluster::RemoveAllScenes(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                          uint16_t groupId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Scenes::Commands::RemoveAllScenes::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // groupId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), groupId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ScenesCluster::RemoveScene(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                      uint16_t groupId, uint8_t sceneId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Scenes::Commands::RemoveScene::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // groupId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), groupId));
    // sceneId: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), sceneId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ScenesCluster::StoreScene(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                     uint16_t groupId, uint8_t sceneId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Scenes::Commands::StoreScene::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // groupId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), groupId));
    // sceneId: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), sceneId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ScenesCluster::ViewScene(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                    uint16_t groupId, uint8_t sceneId)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Scenes::Commands::ViewScene::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // groupId: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), groupId));
    // sceneId: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), sceneId));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// Scenes Cluster Attributes
CHIP_ERROR ScenesCluster::ReadAttributeSceneCount(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ScenesCluster::SubscribeAttributeSceneCount(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                       uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Scenes::Attributes::SceneCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ScenesCluster::ReportAttributeSceneCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Scenes::Attributes::SceneCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ScenesCluster::ReadAttributeCurrentScene(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ScenesCluster::SubscribeAttributeCurrentScene(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                         uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Scenes::Attributes::CurrentScene::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ScenesCluster::ReportAttributeCurrentScene(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Scenes::Attributes::CurrentScene::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ScenesCluster::ReadAttributeCurrentGroup(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ScenesCluster::SubscribeAttributeCurrentGroup(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                         uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Scenes::Attributes::CurrentGroup::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ScenesCluster::ReportAttributeCurrentGroup(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Scenes::Attributes::CurrentGroup::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ScenesCluster::ReadAttributeSceneValid(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR ScenesCluster::SubscribeAttributeSceneValid(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                       uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Scenes::Attributes::SceneValid::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ScenesCluster::ReportAttributeSceneValid(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Scenes::Attributes::SceneValid::Id, onReportCallback,
                                     BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR ScenesCluster::ReadAttributeNameSupport(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ScenesCluster::SubscribeAttributeNameSupport(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Scenes::Attributes::NameSupport::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ScenesCluster::ReportAttributeNameSupport(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Scenes::Attributes::NameSupport::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ScenesCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ScenesCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ScenesCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// SoftwareDiagnostics Cluster Commands
CHIP_ERROR SoftwareDiagnosticsCluster::ResetWatermarks(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         SoftwareDiagnostics::Commands::ResetWatermarks::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// SoftwareDiagnostics Cluster Attributes
CHIP_ERROR SoftwareDiagnosticsCluster::ReadAttributeThreadMetrics(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             SoftwareDiagnosticsClusterThreadMetricsListAttributeFilter);
}

CHIP_ERROR SoftwareDiagnosticsCluster::ReadAttributeCurrentHeapFree(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR SoftwareDiagnosticsCluster::SubscribeAttributeCurrentHeapFree(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = SoftwareDiagnostics::Attributes::CurrentHeapFree::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR SoftwareDiagnosticsCluster::ReportAttributeCurrentHeapFree(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(SoftwareDiagnostics::Attributes::CurrentHeapFree::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR SoftwareDiagnosticsCluster::ReadAttributeCurrentHeapUsed(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR SoftwareDiagnosticsCluster::SubscribeAttributeCurrentHeapUsed(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = SoftwareDiagnostics::Attributes::CurrentHeapUsed::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR SoftwareDiagnosticsCluster::ReportAttributeCurrentHeapUsed(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(SoftwareDiagnostics::Attributes::CurrentHeapUsed::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR SoftwareDiagnosticsCluster::ReadAttributeCurrentHeapHighWatermark(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR SoftwareDiagnosticsCluster::SubscribeAttributeCurrentHeapHighWatermark(Callback::Cancelable * onSuccessCallback,
                                                                                  Callback::Cancelable * onFailureCallback,
                                                                                  uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = SoftwareDiagnostics::Attributes::CurrentHeapHighWatermark::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR SoftwareDiagnosticsCluster::ReportAttributeCurrentHeapHighWatermark(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(SoftwareDiagnostics::Attributes::CurrentHeapHighWatermark::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR SoftwareDiagnosticsCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR SoftwareDiagnosticsCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR SoftwareDiagnosticsCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// Switch Cluster Commands
// Switch Cluster Attributes
CHIP_ERROR SwitchCluster::ReadAttributeNumberOfPositions(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR SwitchCluster::SubscribeAttributeNumberOfPositions(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                              uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Switch::Attributes::NumberOfPositions::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR SwitchCluster::ReportAttributeNumberOfPositions(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Switch::Attributes::NumberOfPositions::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR SwitchCluster::ReadAttributeCurrentPosition(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR SwitchCluster::SubscribeAttributeCurrentPosition(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Switch::Attributes::CurrentPosition::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR SwitchCluster::ReportAttributeCurrentPosition(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Switch::Attributes::CurrentPosition::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR SwitchCluster::ReadAttributeMultiPressMax(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR SwitchCluster::SubscribeAttributeMultiPressMax(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                          uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Switch::Attributes::MultiPressMax::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR SwitchCluster::ReportAttributeMultiPressMax(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Switch::Attributes::MultiPressMax::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR SwitchCluster::ReadAttributeFeatureMap(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFC;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR SwitchCluster::SubscribeAttributeFeatureMap(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                       uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::FeatureMap::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR SwitchCluster::ReportAttributeFeatureMap(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::FeatureMap::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR SwitchCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR SwitchCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR SwitchCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// TvChannel Cluster Commands
CHIP_ERROR TvChannelCluster::ChangeChannel(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                           chip::CharSpan match)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, TvChannel::Commands::ChangeChannel::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // match: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), match));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR TvChannelCluster::ChangeChannelByNumber(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback, uint16_t majorNumber,
                                                   uint16_t minorNumber)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, TvChannel::Commands::ChangeChannelByNumber::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // majorNumber: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), majorNumber));
    // minorNumber: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), minorNumber));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR TvChannelCluster::SkipChannel(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                         uint16_t count)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, TvChannel::Commands::SkipChannel::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // count: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), count));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// TvChannel Cluster Attributes
CHIP_ERROR TvChannelCluster::ReadAttributeTvChannelList(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             TvChannelClusterTvChannelListListAttributeFilter);
}

CHIP_ERROR TvChannelCluster::ReadAttributeTvChannelLineup(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR TvChannelCluster::SubscribeAttributeTvChannelLineup(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TvChannel::Attributes::TvChannelLineup::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TvChannelCluster::ReportAttributeTvChannelLineup(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TvChannel::Attributes::TvChannelLineup::Id, onReportCallback,
                                     BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR TvChannelCluster::ReadAttributeCurrentTvChannel(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR TvChannelCluster::SubscribeAttributeCurrentTvChannel(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TvChannel::Attributes::CurrentTvChannel::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TvChannelCluster::ReportAttributeCurrentTvChannel(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TvChannel::Attributes::CurrentTvChannel::Id, onReportCallback,
                                     BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR TvChannelCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TvChannelCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TvChannelCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// TargetNavigator Cluster Commands
CHIP_ERROR TargetNavigatorCluster::NavigateTarget(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback, uint8_t target, chip::CharSpan data)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, TargetNavigator::Commands::NavigateTarget::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // target: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), target));
    // data: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), data));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// TargetNavigator Cluster Attributes
CHIP_ERROR TargetNavigatorCluster::ReadAttributeTargetNavigatorList(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             TargetNavigatorClusterTargetNavigatorListListAttributeFilter);
}

CHIP_ERROR TargetNavigatorCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TargetNavigatorCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TargetNavigatorCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// TemperatureMeasurement Cluster Commands
// TemperatureMeasurement Cluster Attributes
CHIP_ERROR TemperatureMeasurementCluster::ReadAttributeMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR TemperatureMeasurementCluster::SubscribeAttributeMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TemperatureMeasurement::Attributes::MeasuredValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TemperatureMeasurementCluster::ReportAttributeMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TemperatureMeasurement::Attributes::MeasuredValue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR TemperatureMeasurementCluster::ReadAttributeMinMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR TemperatureMeasurementCluster::SubscribeAttributeMinMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback,
                                                                             uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TemperatureMeasurement::Attributes::MinMeasuredValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TemperatureMeasurementCluster::ReportAttributeMinMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TemperatureMeasurement::Attributes::MinMeasuredValue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR TemperatureMeasurementCluster::ReadAttributeMaxMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR TemperatureMeasurementCluster::SubscribeAttributeMaxMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback,
                                                                             uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TemperatureMeasurement::Attributes::MaxMeasuredValue::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TemperatureMeasurementCluster::ReportAttributeMaxMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TemperatureMeasurement::Attributes::MaxMeasuredValue::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR TemperatureMeasurementCluster::ReadAttributeTolerance(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TemperatureMeasurementCluster::SubscribeAttributeTolerance(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TemperatureMeasurement::Attributes::Tolerance::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TemperatureMeasurementCluster::ReportAttributeTolerance(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TemperatureMeasurement::Attributes::Tolerance::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TemperatureMeasurementCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TemperatureMeasurementCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TemperatureMeasurementCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// TestCluster Cluster Commands
CHIP_ERROR TestClusterCluster::Test(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, TestCluster::Commands::Test::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR TestClusterCluster::TestAddArguments(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                uint8_t arg1, uint8_t arg2)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, TestCluster::Commands::TestAddArguments::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // arg1: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), arg1));
    // arg2: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), arg2));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR TestClusterCluster::TestEnumsRequest(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                chip::VendorId arg1, uint8_t arg2)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, TestCluster::Commands::TestEnumsRequest::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // arg1: vendorId
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), arg1));
    // arg2: simpleEnum
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), arg2));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR TestClusterCluster::TestListInt8UArgumentRequest(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint8_t arg1)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         TestCluster::Commands::TestListInt8UArgumentRequest::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // arg1: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), arg1));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR TestClusterCluster::TestListInt8UReverseRequest(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint8_t arg1)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         TestCluster::Commands::TestListInt8UReverseRequest::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // arg1: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), arg1));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR TestClusterCluster::TestListStructArgumentRequest(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback, uint8_t a, bool b, uint8_t c,
                                                             chip::ByteSpan d, chip::CharSpan e, uint8_t f)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         TestCluster::Commands::TestListStructArgumentRequest::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // a: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), a));
    // b: boolean
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), b));
    // c: simpleEnum
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), c));
    // d: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), d));
    // e: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), e));
    // f: simpleBitmap
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), f));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR TestClusterCluster::TestNotHandled(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, TestCluster::Commands::TestNotHandled::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR TestClusterCluster::TestNullableOptionalRequest(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint8_t arg1)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         TestCluster::Commands::TestNullableOptionalRequest::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // arg1: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), arg1));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR TestClusterCluster::TestSpecific(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, TestCluster::Commands::TestSpecific::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR TestClusterCluster::TestStructArgumentRequest(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback, uint8_t a, bool b, uint8_t c,
                                                         chip::ByteSpan d, chip::CharSpan e, uint8_t f)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         TestCluster::Commands::TestStructArgumentRequest::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // a: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), a));
    // b: boolean
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), b));
    // c: simpleEnum
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), c));
    // d: octetString
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), d));
    // e: charString
    SuccessOrExit(err = writer->PutString(TLV::ContextTag(argSeqNumber++), e));
    // f: simpleBitmap
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), f));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR TestClusterCluster::TestUnknownCommand(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, TestCluster::Commands::TestUnknownCommand::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// TestCluster Cluster Attributes
CHIP_ERROR TestClusterCluster::ReadAttributeBoolean(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeBoolean(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, bool value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Boolean::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeBoolean(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                         uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Boolean::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeBoolean(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Boolean::Id, onReportCallback,
                                     BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeBitmap8(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeBitmap8(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Bitmap8::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeBitmap8(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                         uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Bitmap8::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeBitmap8(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Bitmap8::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeBitmap16(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeBitmap16(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Bitmap16::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeBitmap16(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                          uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Bitmap16::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeBitmap16(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Bitmap16::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeBitmap32(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeBitmap32(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback, uint32_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Bitmap32::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeBitmap32(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                          uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Bitmap32::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeBitmap32(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Bitmap32::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeBitmap64(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeBitmap64(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback, uint64_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Bitmap64::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeBitmap64(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                          uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Bitmap64::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeBitmap64(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Bitmap64::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeInt8u(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000005;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeInt8u(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Int8u::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeInt8u(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                       uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Int8u::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeInt8u(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Int8u::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeInt16u(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000006;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeInt16u(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Int16u::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeInt16u(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Int16u::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeInt16u(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Int16u::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeInt32u(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000008;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeInt32u(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback, uint32_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Int32u::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeInt32u(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Int32u::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeInt32u(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Int32u::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeInt64u(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeInt64u(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback, uint64_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Int64u::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeInt64u(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Int64u::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeInt64u(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Int64u::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeInt8s(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000D;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeInt8s(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback, int8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Int8s::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeInt8s(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                       uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Int8s::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeInt8s(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Int8s::Id, onReportCallback,
                                     BasicAttributeFilter<Int8sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeInt16s(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000E;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeInt16s(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback, int16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Int16s::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeInt16s(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Int16s::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeInt16s(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Int16s::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeInt32s(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000010;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeInt32s(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback, int32_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Int32s::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeInt32s(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Int32s::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeInt32s(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Int32s::Id, onReportCallback,
                                     BasicAttributeFilter<Int32sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeInt64s(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000014;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeInt64s(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback, int64_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Int64s::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeInt64s(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Int64s::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeInt64s(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Int64s::Id, onReportCallback,
                                     BasicAttributeFilter<Int64sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeEnum8(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000015;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeEnum8(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Enum8::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeEnum8(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                       uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Enum8::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeEnum8(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Enum8::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeEnum16(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000016;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeEnum16(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Enum16::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeEnum16(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Enum16::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeEnum16(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Enum16::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeOctetString(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000019;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeOctetString(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback, chip::ByteSpan value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::OctetString::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeOctetString(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                             uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::OctetString::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeOctetString(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::OctetString::Id, onReportCallback,
                                     BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeListInt8u(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             TestClusterClusterListInt8uListAttributeFilter);
}

CHIP_ERROR TestClusterCluster::ReadAttributeListOctetString(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001B;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             TestClusterClusterListOctetStringListAttributeFilter);
}

CHIP_ERROR TestClusterCluster::ReadAttributeListStructOctetString(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             TestClusterClusterListStructOctetStringListAttributeFilter);
}

CHIP_ERROR TestClusterCluster::ReadAttributeLongOctetString(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001D;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeLongOctetString(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback, chip::ByteSpan value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::LongOctetString::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeLongOctetString(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::LongOctetString::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeLongOctetString(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::LongOctetString::Id, onReportCallback,
                                     BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeCharString(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001E;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeCharString(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, chip::CharSpan value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::CharString::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeCharString(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::CharString::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeCharString(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::CharString::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeLongCharString(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001F;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeLongCharString(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, chip::CharSpan value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::LongCharString::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeLongCharString(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::LongCharString::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeLongCharString(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::LongCharString::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeEpochUs(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000020;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeEpochUs(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, uint64_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::EpochUs::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeEpochUs(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                         uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::EpochUs::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeEpochUs(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::EpochUs::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeEpochS(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000021;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeEpochS(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback, uint32_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::EpochS::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeEpochS(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::EpochS::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeEpochS(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::EpochS::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeVendorId(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000022;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeVendorId(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback, chip::VendorId value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::VendorId::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeVendorId(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                          uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::VendorId::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeVendorId(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::VendorId::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeListNullablesAndOptionalsStruct(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000023;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             TestClusterClusterListNullablesAndOptionalsStructListAttributeFilter);
}

CHIP_ERROR TestClusterCluster::ReadAttributeUnsupported(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x000000FF;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeUnsupported(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback, bool value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::Unsupported::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeUnsupported(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                             uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::Unsupported::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeUnsupported(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::Unsupported::Id, onReportCallback,
                                     BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableBoolean(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00008000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableBoolean(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback, bool value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableBoolean::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableBoolean(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableBoolean::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableBoolean(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableBoolean::Id, onReportCallback,
                                     BasicAttributeFilter<BooleanAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableBitmap8(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00008001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableBitmap8(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableBitmap8::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableBitmap8(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableBitmap8::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableBitmap8(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableBitmap8::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableBitmap16(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00008002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableBitmap16(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableBitmap16::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableBitmap16(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                  uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableBitmap16::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableBitmap16(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableBitmap16::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableBitmap32(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00008003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableBitmap32(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback, uint32_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableBitmap32::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableBitmap32(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                  uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableBitmap32::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableBitmap32(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableBitmap32::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableBitmap64(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00008004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableBitmap64(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback, uint64_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableBitmap64::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableBitmap64(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                  uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableBitmap64::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableBitmap64(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableBitmap64::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableInt8u(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00008005;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableInt8u(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableInt8u::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableInt8u(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableInt8u::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableInt8u(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableInt8u::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableInt16u(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00008006;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableInt16u(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableInt16u::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableInt16u(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableInt16u::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableInt16u(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableInt16u::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableInt32u(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00008008;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableInt32u(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint32_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableInt32u::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableInt32u(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableInt32u::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableInt32u(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableInt32u::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableInt64u(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000800C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableInt64u(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint64_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableInt64u::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableInt64u(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableInt64u::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableInt64u(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableInt64u::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableInt8s(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000800D;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableInt8s(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, int8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableInt8s::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableInt8s(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableInt8s::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableInt8s(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableInt8s::Id, onReportCallback,
                                     BasicAttributeFilter<Int8sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableInt16s(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000800E;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableInt16s(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, int16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableInt16s::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableInt16s(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableInt16s::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableInt16s(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableInt16s::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableInt32s(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00008010;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableInt32s(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, int32_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableInt32s::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableInt32s(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableInt32s::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableInt32s(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableInt32s::Id, onReportCallback,
                                     BasicAttributeFilter<Int32sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableInt64s(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00008014;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableInt64s(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, int64_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableInt64s::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableInt64s(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableInt64s::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableInt64s(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableInt64s::Id, onReportCallback,
                                     BasicAttributeFilter<Int64sAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableEnum8(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00008015;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableEnum8(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableEnum8::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableEnum8(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableEnum8::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableEnum8(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableEnum8::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableEnum16(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00008016;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableEnum16(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableEnum16::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableEnum16(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableEnum16::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableEnum16(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableEnum16::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableOctetString(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00008019;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableOctetString(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, chip::ByteSpan value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableOctetString::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableOctetString(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableOctetString::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableOctetString(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableOctetString::Id, onReportCallback,
                                     BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeNullableCharString(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000801E;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::WriteAttributeNullableCharString(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, chip::CharSpan value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, TestCluster::Attributes::NullableCharString::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeNullableCharString(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = TestCluster::Attributes::NullableCharString::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeNullableCharString(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(TestCluster::Attributes::NullableCharString::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR TestClusterCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TestClusterCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// Thermostat Cluster Commands
CHIP_ERROR ThermostatCluster::ClearWeeklySchedule(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Thermostat::Commands::ClearWeeklySchedule::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ThermostatCluster::GetRelayStatusLog(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Thermostat::Commands::GetRelayStatusLog::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ThermostatCluster::GetWeeklySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                uint8_t daysToReturn, uint8_t modeToReturn)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Thermostat::Commands::GetWeeklySchedule::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // daysToReturn: dayOfWeek
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), daysToReturn));
    // modeToReturn: modeForSequence
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), modeToReturn));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ThermostatCluster::SetWeeklySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                uint8_t numberOfTransitionsForSequence, uint8_t dayOfWeekForSequence,
                                                uint8_t modeForSequence, uint8_t payload)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Thermostat::Commands::SetWeeklySchedule::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // numberOfTransitionsForSequence: enum8
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), numberOfTransitionsForSequence));
    // dayOfWeekForSequence: dayOfWeek
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), dayOfWeekForSequence));
    // modeForSequence: modeForSequence
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), modeForSequence));
    // payload: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), payload));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR ThermostatCluster::SetpointRaiseLower(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 uint8_t mode, int8_t amount)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, Thermostat::Commands::SetpointRaiseLower::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // mode: setpointAdjustMode
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), mode));
    // amount: int8s
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), amount));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// Thermostat Cluster Attributes
CHIP_ERROR ThermostatCluster::ReadAttributeLocalTemperature(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeLocalTemperature(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::LocalTemperature::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeLocalTemperature(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::LocalTemperature::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeAbsMinHeatSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeAbsMinHeatSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::AbsMinHeatSetpointLimit::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeAbsMinHeatSetpointLimit(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::AbsMinHeatSetpointLimit::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeAbsMaxHeatSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeAbsMaxHeatSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::AbsMaxHeatSetpointLimit::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeAbsMaxHeatSetpointLimit(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::AbsMaxHeatSetpointLimit::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeAbsMinCoolSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000005;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeAbsMinCoolSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::AbsMinCoolSetpointLimit::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeAbsMinCoolSetpointLimit(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::AbsMinCoolSetpointLimit::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeAbsMaxCoolSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000006;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeAbsMaxCoolSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::AbsMaxCoolSetpointLimit::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeAbsMaxCoolSetpointLimit(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::AbsMaxCoolSetpointLimit::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeOccupiedCoolingSetpoint(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000011;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::WriteAttributeOccupiedCoolingSetpoint(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, int16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, Thermostat::Attributes::OccupiedCoolingSetpoint::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeOccupiedCoolingSetpoint(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::OccupiedCoolingSetpoint::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeOccupiedCoolingSetpoint(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::OccupiedCoolingSetpoint::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeOccupiedHeatingSetpoint(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000012;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::WriteAttributeOccupiedHeatingSetpoint(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, int16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, Thermostat::Attributes::OccupiedHeatingSetpoint::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeOccupiedHeatingSetpoint(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::OccupiedHeatingSetpoint::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeOccupiedHeatingSetpoint(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::OccupiedHeatingSetpoint::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeMinHeatSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000015;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::WriteAttributeMinHeatSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, int16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, Thermostat::Attributes::MinHeatSetpointLimit::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeMinHeatSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::MinHeatSetpointLimit::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeMinHeatSetpointLimit(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::MinHeatSetpointLimit::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeMaxHeatSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000016;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::WriteAttributeMaxHeatSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, int16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, Thermostat::Attributes::MaxHeatSetpointLimit::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeMaxHeatSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::MaxHeatSetpointLimit::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeMaxHeatSetpointLimit(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::MaxHeatSetpointLimit::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeMinCoolSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000017;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::WriteAttributeMinCoolSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, int16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, Thermostat::Attributes::MinCoolSetpointLimit::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeMinCoolSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::MinCoolSetpointLimit::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeMinCoolSetpointLimit(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::MinCoolSetpointLimit::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeMaxCoolSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000018;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::WriteAttributeMaxCoolSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, int16_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, Thermostat::Attributes::MaxCoolSetpointLimit::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeMaxCoolSetpointLimit(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                     uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::MaxCoolSetpointLimit::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeMaxCoolSetpointLimit(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::MaxCoolSetpointLimit::Id, onReportCallback,
                                     BasicAttributeFilter<Int16sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeMinSetpointDeadBand(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000019;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::WriteAttributeMinSetpointDeadBand(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, int8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, Thermostat::Attributes::MinSetpointDeadBand::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeMinSetpointDeadBand(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::MinSetpointDeadBand::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeMinSetpointDeadBand(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::MinSetpointDeadBand::Id, onReportCallback,
                                     BasicAttributeFilter<Int8sAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeControlSequenceOfOperation(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001B;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::WriteAttributeControlSequenceOfOperation(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, Thermostat::Attributes::ControlSequenceOfOperation::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeControlSequenceOfOperation(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::ControlSequenceOfOperation::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeControlSequenceOfOperation(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::ControlSequenceOfOperation::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeSystemMode(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::WriteAttributeSystemMode(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, Thermostat::Attributes::SystemMode::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeSystemMode(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                           uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::SystemMode::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeSystemMode(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::SystemMode::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeStartOfWeek(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000020;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeStartOfWeek(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                            uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::StartOfWeek::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeStartOfWeek(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::StartOfWeek::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeNumberOfWeeklyTransitions(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000021;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeNumberOfWeeklyTransitions(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::NumberOfWeeklyTransitions::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeNumberOfWeeklyTransitions(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::NumberOfWeeklyTransitions::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeNumberOfDailyTransitions(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000022;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeNumberOfDailyTransitions(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Thermostat::Attributes::NumberOfDailyTransitions::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeNumberOfDailyTransitions(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Thermostat::Attributes::NumberOfDailyTransitions::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeFeatureMap(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFC;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeFeatureMap(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                           uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::FeatureMap::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeFeatureMap(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::FeatureMap::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThermostatCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// ThermostatUserInterfaceConfiguration Cluster Commands
// ThermostatUserInterfaceConfiguration Cluster Attributes
CHIP_ERROR
ThermostatUserInterfaceConfigurationCluster::ReadAttributeTemperatureDisplayMode(Callback::Cancelable * onSuccessCallback,
                                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThermostatUserInterfaceConfigurationCluster::WriteAttributeTemperatureDisplayMode(
    Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId,
                                       ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Id),
        value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatUserInterfaceConfigurationCluster::SubscribeAttributeTemperatureDisplayMode(
    Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback, uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR
ThermostatUserInterfaceConfigurationCluster::ReportAttributeTemperatureDisplayMode(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThermostatUserInterfaceConfigurationCluster::ReadAttributeKeypadLockout(Callback::Cancelable * onSuccessCallback,
                                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThermostatUserInterfaceConfigurationCluster::WriteAttributeKeypadLockout(Callback::Cancelable * onSuccessCallback,
                                                                                    Callback::Cancelable * onFailureCallback,
                                                                                    uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id),
        value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatUserInterfaceConfigurationCluster::SubscribeAttributeKeypadLockout(Callback::Cancelable * onSuccessCallback,
                                                                                        Callback::Cancelable * onFailureCallback,
                                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatUserInterfaceConfigurationCluster::ReportAttributeKeypadLockout(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR
ThermostatUserInterfaceConfigurationCluster::ReadAttributeScheduleProgrammingVisibility(Callback::Cancelable * onSuccessCallback,
                                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThermostatUserInterfaceConfigurationCluster::WriteAttributeScheduleProgrammingVisibility(
    Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId,
                                       ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Id),
        value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatUserInterfaceConfigurationCluster::SubscribeAttributeScheduleProgrammingVisibility(
    Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback, uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR
ThermostatUserInterfaceConfigurationCluster::ReportAttributeScheduleProgrammingVisibility(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Id,
                                     onReportCallback, BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThermostatUserInterfaceConfigurationCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThermostatUserInterfaceConfigurationCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                                          Callback::Cancelable * onFailureCallback,
                                                                                          uint16_t minInterval,
                                                                                          uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThermostatUserInterfaceConfigurationCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// ThreadNetworkDiagnostics Cluster Commands
CHIP_ERROR ThreadNetworkDiagnosticsCluster::ResetCounts(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId,
                                         ThreadNetworkDiagnostics::Commands::ResetCounts::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// ThreadNetworkDiagnostics Cluster Attributes
CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeChannel(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeChannel(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::Channel::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeChannel(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::Channel::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRoutingRole(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRoutingRole(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RoutingRole::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRoutingRole(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RoutingRole::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeNetworkName(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeNetworkName(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::NetworkName::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeNetworkName(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::NetworkName::Id, onReportCallback,
                                     BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributePanId(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributePanId(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::PanId::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributePanId(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::PanId::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeExtendedPanId(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeExtendedPanId(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::ExtendedPanId::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeExtendedPanId(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::ExtendedPanId::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeMeshLocalPrefix(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000005;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeMeshLocalPrefix(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::MeshLocalPrefix::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeMeshLocalPrefix(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::MeshLocalPrefix::Id, onReportCallback,
                                     BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeOverrunCount(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000006;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeOverrunCount(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::OverrunCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeOverrunCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::OverrunCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeNeighborTableList(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000007;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             ThreadNetworkDiagnosticsClusterNeighborTableListListAttributeFilter);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRouteTableList(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000008;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             ThreadNetworkDiagnosticsClusterRouteTableListListAttributeFilter);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributePartitionId(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000009;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributePartitionId(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::PartitionId::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributePartitionId(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::PartitionId::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeWeighting(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeWeighting(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::Weighting::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeWeighting(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::Weighting::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeDataVersion(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000B;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeDataVersion(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::DataVersion::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeDataVersion(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::DataVersion::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeStableDataVersion(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeStableDataVersion(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback,
                                                                                uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::StableDataVersion::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeStableDataVersion(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::StableDataVersion::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeLeaderRouterId(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000D;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeLeaderRouterId(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback,
                                                                             uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::LeaderRouterId::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeLeaderRouterId(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::LeaderRouterId::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeDetachedRoleCount(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000E;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeDetachedRoleCount(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback,
                                                                                uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::DetachedRoleCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeDetachedRoleCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::DetachedRoleCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeChildRoleCount(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000F;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeChildRoleCount(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback,
                                                                             uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::ChildRoleCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeChildRoleCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::ChildRoleCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRouterRoleCount(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000010;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRouterRoleCount(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RouterRoleCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRouterRoleCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RouterRoleCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeLeaderRoleCount(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000011;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeLeaderRoleCount(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::LeaderRoleCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeLeaderRoleCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::LeaderRoleCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeAttachAttemptCount(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000012;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeAttachAttemptCount(Callback::Cancelable * onSuccessCallback,
                                                                                 Callback::Cancelable * onFailureCallback,
                                                                                 uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::AttachAttemptCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeAttachAttemptCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::AttachAttemptCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributePartitionIdChangeCount(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000013;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributePartitionIdChangeCount(Callback::Cancelable * onSuccessCallback,
                                                                                     Callback::Cancelable * onFailureCallback,
                                                                                     uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::PartitionIdChangeCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributePartitionIdChangeCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::PartitionIdChangeCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeBetterPartitionAttachAttemptCount(Callback::Cancelable * onSuccessCallback,
                                                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000014;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeBetterPartitionAttachAttemptCount(
    Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback, uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::BetterPartitionAttachAttemptCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR
ThreadNetworkDiagnosticsCluster::ReportAttributeBetterPartitionAttachAttemptCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::BetterPartitionAttachAttemptCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeParentChangeCount(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000015;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeParentChangeCount(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback,
                                                                                uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::ParentChangeCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeParentChangeCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::ParentChangeCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxTotalCount(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000016;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxTotalCount(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxTotalCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxTotalCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxTotalCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxUnicastCount(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000017;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxUnicastCount(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback,
                                                                             uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxUnicastCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxUnicastCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxUnicastCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxBroadcastCount(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000018;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxBroadcastCount(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback,
                                                                               uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxBroadcastCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxBroadcastCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxBroadcastCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxAckRequestedCount(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000019;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxAckRequestedCount(Callback::Cancelable * onSuccessCallback,
                                                                                  Callback::Cancelable * onFailureCallback,
                                                                                  uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxAckRequestedCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxAckRequestedCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxAckRequestedCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxAckedCount(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxAckedCount(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxAckedCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxAckedCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxAckedCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxNoAckRequestedCount(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001B;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxNoAckRequestedCount(Callback::Cancelable * onSuccessCallback,
                                                                                    Callback::Cancelable * onFailureCallback,
                                                                                    uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxNoAckRequestedCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxNoAckRequestedCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxNoAckRequestedCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxDataCount(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxDataCount(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxDataCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxDataCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxDataCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxDataPollCount(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001D;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxDataPollCount(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxDataPollCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxDataPollCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxDataPollCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxBeaconCount(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001E;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxBeaconCount(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxBeaconCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxBeaconCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxBeaconCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxBeaconRequestCount(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001F;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxBeaconRequestCount(Callback::Cancelable * onSuccessCallback,
                                                                                   Callback::Cancelable * onFailureCallback,
                                                                                   uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxBeaconRequestCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxBeaconRequestCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxBeaconRequestCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxOtherCount(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000020;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxOtherCount(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxOtherCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxOtherCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxOtherCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxRetryCount(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000021;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxRetryCount(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxRetryCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxRetryCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxRetryCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxDirectMaxRetryExpiryCount(Callback::Cancelable * onSuccessCallback,
                                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000022;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxDirectMaxRetryExpiryCount(Callback::Cancelable * onSuccessCallback,
                                                                                          Callback::Cancelable * onFailureCallback,
                                                                                          uint16_t minInterval,
                                                                                          uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxDirectMaxRetryExpiryCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxDirectMaxRetryExpiryCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxDirectMaxRetryExpiryCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxIndirectMaxRetryExpiryCount(Callback::Cancelable * onSuccessCallback,
                                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000023;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxIndirectMaxRetryExpiryCount(
    Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback, uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxIndirectMaxRetryExpiryCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxIndirectMaxRetryExpiryCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxIndirectMaxRetryExpiryCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxErrCcaCount(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000024;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxErrCcaCount(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxErrCcaCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxErrCcaCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxErrCcaCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxErrAbortCount(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000025;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxErrAbortCount(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxErrAbortCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxErrAbortCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxErrAbortCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeTxErrBusyChannelCount(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000026;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeTxErrBusyChannelCount(Callback::Cancelable * onSuccessCallback,
                                                                                    Callback::Cancelable * onFailureCallback,
                                                                                    uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::TxErrBusyChannelCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeTxErrBusyChannelCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::TxErrBusyChannelCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxTotalCount(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000027;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxTotalCount(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxTotalCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxTotalCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxTotalCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxUnicastCount(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000028;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxUnicastCount(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback,
                                                                             uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxUnicastCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxUnicastCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxUnicastCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxBroadcastCount(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000029;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxBroadcastCount(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback,
                                                                               uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxBroadcastCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxBroadcastCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxBroadcastCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxDataCount(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000002A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxDataCount(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxDataCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxDataCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxDataCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxDataPollCount(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000002B;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxDataPollCount(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxDataPollCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxDataPollCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxDataPollCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxBeaconCount(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000002C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxBeaconCount(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxBeaconCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxBeaconCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxBeaconCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxBeaconRequestCount(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000002D;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxBeaconRequestCount(Callback::Cancelable * onSuccessCallback,
                                                                                   Callback::Cancelable * onFailureCallback,
                                                                                   uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxBeaconRequestCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxBeaconRequestCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxBeaconRequestCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxOtherCount(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000002E;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxOtherCount(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxOtherCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxOtherCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxOtherCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxAddressFilteredCount(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000002F;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxAddressFilteredCount(Callback::Cancelable * onSuccessCallback,
                                                                                     Callback::Cancelable * onFailureCallback,
                                                                                     uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxAddressFilteredCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxAddressFilteredCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxAddressFilteredCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxDestAddrFilteredCount(Callback::Cancelable * onSuccessCallback,
                                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000030;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxDestAddrFilteredCount(Callback::Cancelable * onSuccessCallback,
                                                                                      Callback::Cancelable * onFailureCallback,
                                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxDestAddrFilteredCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxDestAddrFilteredCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxDestAddrFilteredCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxDuplicatedCount(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000031;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxDuplicatedCount(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback,
                                                                                uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxDuplicatedCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxDuplicatedCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxDuplicatedCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxErrNoFrameCount(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000032;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxErrNoFrameCount(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback,
                                                                                uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxErrNoFrameCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxErrNoFrameCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxErrNoFrameCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxErrUnknownNeighborCount(Callback::Cancelable * onSuccessCallback,
                                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000033;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxErrUnknownNeighborCount(Callback::Cancelable * onSuccessCallback,
                                                                                        Callback::Cancelable * onFailureCallback,
                                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxErrUnknownNeighborCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxErrUnknownNeighborCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxErrUnknownNeighborCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxErrInvalidSrcAddrCount(Callback::Cancelable * onSuccessCallback,
                                                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000034;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxErrInvalidSrcAddrCount(Callback::Cancelable * onSuccessCallback,
                                                                                       Callback::Cancelable * onFailureCallback,
                                                                                       uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxErrInvalidSrcAddrCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxErrInvalidSrcAddrCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxErrInvalidSrcAddrCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxErrSecCount(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000035;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxErrSecCount(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxErrSecCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxErrSecCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxErrSecCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxErrFcsCount(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000036;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxErrFcsCount(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxErrFcsCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxErrFcsCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxErrFcsCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeRxErrOtherCount(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000037;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeRxErrOtherCount(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::RxErrOtherCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeRxErrOtherCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::RxErrOtherCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeActiveTimestamp(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000038;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeActiveTimestamp(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::ActiveTimestamp::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeActiveTimestamp(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::ActiveTimestamp::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributePendingTimestamp(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000039;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributePendingTimestamp(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback,
                                                                               uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::PendingTimestamp::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributePendingTimestamp(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::PendingTimestamp::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeDelay(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000003A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeDelay(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::Delay::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeDelay(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::Delay::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeSecurityPolicy(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000003B;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             ThreadNetworkDiagnosticsClusterSecurityPolicyListAttributeFilter);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeChannelMask(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000003C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeChannelMask(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = ThreadNetworkDiagnostics::Attributes::ChannelMask::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeChannelMask(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(ThreadNetworkDiagnostics::Attributes::ChannelMask::Id, onReportCallback,
                                     BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeOperationalDatasetComponents(Callback::Cancelable * onSuccessCallback,
                                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000003D;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             ThreadNetworkDiagnosticsClusterOperationalDatasetComponentsListAttributeFilter);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeActiveNetworkFaultsList(Callback::Cancelable * onSuccessCallback,
                                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000003E;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             ThreadNetworkDiagnosticsClusterActiveNetworkFaultsListListAttributeFilter);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback,
                                                                              uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ThreadNetworkDiagnosticsCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// WakeOnLan Cluster Commands
// WakeOnLan Cluster Attributes
CHIP_ERROR WakeOnLanCluster::ReadAttributeWakeOnLanMacAddress(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR WakeOnLanCluster::SubscribeAttributeWakeOnLanMacAddress(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                   uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WakeOnLan::Attributes::WakeOnLanMacAddress::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WakeOnLanCluster::ReportAttributeWakeOnLanMacAddress(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WakeOnLan::Attributes::WakeOnLanMacAddress::Id, onReportCallback,
                                     BasicAttributeFilter<CharStringAttributeCallback>);
}

CHIP_ERROR WakeOnLanCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WakeOnLanCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WakeOnLanCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// WiFiNetworkDiagnostics Cluster Commands
CHIP_ERROR WiFiNetworkDiagnosticsCluster::ResetCounts(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, WiFiNetworkDiagnostics::Commands::ResetCounts::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// WiFiNetworkDiagnostics Cluster Attributes
CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReadAttributeBssid(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::SubscribeAttributeBssid(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                  uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WiFiNetworkDiagnostics::Attributes::Bssid::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReportAttributeBssid(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WiFiNetworkDiagnostics::Attributes::Bssid::Id, onReportCallback,
                                     BasicAttributeFilter<OctetStringAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReadAttributeSecurityType(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000001;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::SubscribeAttributeSecurityType(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WiFiNetworkDiagnostics::Attributes::SecurityType::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReportAttributeSecurityType(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WiFiNetworkDiagnostics::Attributes::SecurityType::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReadAttributeWiFiVersion(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000002;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::SubscribeAttributeWiFiVersion(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WiFiNetworkDiagnostics::Attributes::WiFiVersion::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReportAttributeWiFiVersion(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WiFiNetworkDiagnostics::Attributes::WiFiVersion::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReadAttributeChannelNumber(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::SubscribeAttributeChannelNumber(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WiFiNetworkDiagnostics::Attributes::ChannelNumber::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReportAttributeChannelNumber(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WiFiNetworkDiagnostics::Attributes::ChannelNumber::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReadAttributeRssi(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8sAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::SubscribeAttributeRssi(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WiFiNetworkDiagnostics::Attributes::Rssi::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReportAttributeRssi(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WiFiNetworkDiagnostics::Attributes::Rssi::Id, onReportCallback,
                                     BasicAttributeFilter<Int8sAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReadAttributeBeaconLostCount(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000005;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::SubscribeAttributeBeaconLostCount(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WiFiNetworkDiagnostics::Attributes::BeaconLostCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReportAttributeBeaconLostCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WiFiNetworkDiagnostics::Attributes::BeaconLostCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReadAttributeBeaconRxCount(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000006;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::SubscribeAttributeBeaconRxCount(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WiFiNetworkDiagnostics::Attributes::BeaconRxCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReportAttributeBeaconRxCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WiFiNetworkDiagnostics::Attributes::BeaconRxCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReadAttributePacketMulticastRxCount(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000007;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::SubscribeAttributePacketMulticastRxCount(Callback::Cancelable * onSuccessCallback,
                                                                                   Callback::Cancelable * onFailureCallback,
                                                                                   uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WiFiNetworkDiagnostics::Attributes::PacketMulticastRxCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReportAttributePacketMulticastRxCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WiFiNetworkDiagnostics::Attributes::PacketMulticastRxCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReadAttributePacketMulticastTxCount(Callback::Cancelable * onSuccessCallback,
                                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000008;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::SubscribeAttributePacketMulticastTxCount(Callback::Cancelable * onSuccessCallback,
                                                                                   Callback::Cancelable * onFailureCallback,
                                                                                   uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WiFiNetworkDiagnostics::Attributes::PacketMulticastTxCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReportAttributePacketMulticastTxCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WiFiNetworkDiagnostics::Attributes::PacketMulticastTxCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReadAttributePacketUnicastRxCount(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000009;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::SubscribeAttributePacketUnicastRxCount(Callback::Cancelable * onSuccessCallback,
                                                                                 Callback::Cancelable * onFailureCallback,
                                                                                 uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WiFiNetworkDiagnostics::Attributes::PacketUnicastRxCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReportAttributePacketUnicastRxCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WiFiNetworkDiagnostics::Attributes::PacketUnicastRxCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReadAttributePacketUnicastTxCount(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::SubscribeAttributePacketUnicastTxCount(Callback::Cancelable * onSuccessCallback,
                                                                                 Callback::Cancelable * onFailureCallback,
                                                                                 uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WiFiNetworkDiagnostics::Attributes::PacketUnicastTxCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReportAttributePacketUnicastTxCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WiFiNetworkDiagnostics::Attributes::PacketUnicastTxCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReadAttributeCurrentMaxRate(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000B;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::SubscribeAttributeCurrentMaxRate(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WiFiNetworkDiagnostics::Attributes::CurrentMaxRate::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReportAttributeCurrentMaxRate(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WiFiNetworkDiagnostics::Attributes::CurrentMaxRate::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReadAttributeOverrunCount(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::SubscribeAttributeOverrunCount(Callback::Cancelable * onSuccessCallback,
                                                                         Callback::Cancelable * onFailureCallback,
                                                                         uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WiFiNetworkDiagnostics::Attributes::OverrunCount::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReportAttributeOverrunCount(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WiFiNetworkDiagnostics::Attributes::OverrunCount::Id, onReportCallback,
                                     BasicAttributeFilter<Int64uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReadAttributeFeatureMap(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFC;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WiFiNetworkDiagnosticsCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

// WindowCovering Cluster Commands
CHIP_ERROR WindowCoveringCluster::DownOrClose(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, WindowCovering::Commands::DownOrClose::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR WindowCoveringCluster::GoToLiftPercentage(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, uint8_t liftPercentageValue,
                                                     uint16_t liftPercent100thsValue)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, WindowCovering::Commands::GoToLiftPercentage::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // liftPercentageValue: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), liftPercentageValue));
    // liftPercent100thsValue: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), liftPercent100thsValue));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR WindowCoveringCluster::GoToLiftValue(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                uint16_t liftValue)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, WindowCovering::Commands::GoToLiftValue::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // liftValue: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), liftValue));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR WindowCoveringCluster::GoToTiltPercentage(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, uint8_t tiltPercentageValue,
                                                     uint16_t tiltPercent100thsValue)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, WindowCovering::Commands::GoToTiltPercentage::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // tiltPercentageValue: int8u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), tiltPercentageValue));
    // tiltPercent100thsValue: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), tiltPercent100thsValue));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR WindowCoveringCluster::GoToTiltValue(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                uint16_t tiltValue)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, WindowCovering::Commands::GoToTiltValue::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    VerifyOrExit((writer = sender->GetCommandDataIBTLVWriter()) != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    // tiltValue: int16u
    SuccessOrExit(err = writer->Put(TLV::ContextTag(argSeqNumber++), tiltValue));

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR WindowCoveringCluster::StopMotion(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, WindowCovering::Commands::StopMotion::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

CHIP_ERROR WindowCoveringCluster::UpOrOpen(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    CHIP_ERROR err          = CHIP_NO_ERROR;
    TLV::TLVWriter * writer = nullptr;
    uint8_t argSeqNumber    = 0;

    // Used when encoding non-empty command. Suppress error message when encoding empty commands.
    (void) writer;
    (void) argSeqNumber;

    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);

    app::CommandPathParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, WindowCovering::Commands::UpOrOpen::Id,
                                         (app::CommandPathFlags::kEndpointIdValid) };

    CommandSenderHandle sender(
        Platform::New<app::CommandSender>(mDevice->GetInteractionModelDelegate(), mDevice->GetExchangeManager()));

    VerifyOrReturnError(sender != nullptr, CHIP_ERROR_NO_MEMORY);

    SuccessOrExit(err = sender->PrepareCommand(cmdParams));

    // Command takes no arguments.

    SuccessOrExit(err = sender->FinishCommand());

    // #6308: This is a temporary solution before we fully support IM on application side and should be replaced by IMDelegate.
    mDevice->AddIMResponseHandler(sender.get(), onSuccessCallback, onFailureCallback);

    SuccessOrExit(err = mDevice->SendCommands(sender.get()));

    // We have successfully sent the command, and the callback handler will be responsible to free the object, release the object
    // now.
    sender.release();
exit:
    return err;
}

// WindowCovering Cluster Attributes
CHIP_ERROR WindowCoveringCluster::ReadAttributeType(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000000;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeType(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                         uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::Type::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeType(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::Type::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeCurrentPositionLift(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000003;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeCurrentPositionLift(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::CurrentPositionLift::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeCurrentPositionLift(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::CurrentPositionLift::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeCurrentPositionTilt(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000004;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeCurrentPositionTilt(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback,
                                                                        uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::CurrentPositionTilt::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeCurrentPositionTilt(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::CurrentPositionTilt::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeConfigStatus(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000007;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeConfigStatus(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::ConfigStatus::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeConfigStatus(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::ConfigStatus::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeCurrentPositionLiftPercentage(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000008;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeCurrentPositionLiftPercentage(Callback::Cancelable * onSuccessCallback,
                                                                                  Callback::Cancelable * onFailureCallback,
                                                                                  uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::CurrentPositionLiftPercentage::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeCurrentPositionLiftPercentage(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::CurrentPositionLiftPercentage::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeCurrentPositionTiltPercentage(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000009;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeCurrentPositionTiltPercentage(Callback::Cancelable * onSuccessCallback,
                                                                                  Callback::Cancelable * onFailureCallback,
                                                                                  uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::CurrentPositionTiltPercentage::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeCurrentPositionTiltPercentage(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::CurrentPositionTiltPercentage::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeOperationalStatus(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeOperationalStatus(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback,
                                                                      uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::OperationalStatus::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeOperationalStatus(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::OperationalStatus::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeTargetPositionLiftPercent100ths(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000B;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeTargetPositionLiftPercent100ths(Callback::Cancelable * onSuccessCallback,
                                                                                    Callback::Cancelable * onFailureCallback,
                                                                                    uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeTargetPositionLiftPercent100ths(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeTargetPositionTiltPercent100ths(Callback::Cancelable * onSuccessCallback,
                                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000C;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeTargetPositionTiltPercent100ths(Callback::Cancelable * onSuccessCallback,
                                                                                    Callback::Cancelable * onFailureCallback,
                                                                                    uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::TargetPositionTiltPercent100ths::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeTargetPositionTiltPercent100ths(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::TargetPositionTiltPercent100ths::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeEndProductType(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000D;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeEndProductType(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                   uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::EndProductType::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeEndProductType(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::EndProductType::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeCurrentPositionLiftPercent100ths(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000E;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeCurrentPositionLiftPercent100ths(Callback::Cancelable * onSuccessCallback,
                                                                                     Callback::Cancelable * onFailureCallback,
                                                                                     uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeCurrentPositionLiftPercent100ths(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeCurrentPositionTiltPercent100ths(Callback::Cancelable * onSuccessCallback,
                                                                                Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000000F;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeCurrentPositionTiltPercent100ths(Callback::Cancelable * onSuccessCallback,
                                                                                     Callback::Cancelable * onFailureCallback,
                                                                                     uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeCurrentPositionTiltPercent100ths(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeInstalledOpenLimitLift(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000010;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeInstalledOpenLimitLift(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::InstalledOpenLimitLift::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeInstalledOpenLimitLift(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::InstalledOpenLimitLift::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeInstalledClosedLimitLift(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000011;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeInstalledClosedLimitLift(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback,
                                                                             uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::InstalledClosedLimitLift::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeInstalledClosedLimitLift(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::InstalledClosedLimitLift::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeInstalledOpenLimitTilt(Callback::Cancelable * onSuccessCallback,
                                                                      Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000012;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeInstalledOpenLimitTilt(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback,
                                                                           uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::InstalledOpenLimitTilt::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeInstalledOpenLimitTilt(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::InstalledOpenLimitTilt::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeInstalledClosedLimitTilt(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000013;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeInstalledClosedLimitTilt(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback,
                                                                             uint16_t minInterval, uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::InstalledClosedLimitTilt::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeInstalledClosedLimitTilt(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::InstalledClosedLimitTilt::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeMode(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x00000017;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::WriteAttributeMode(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, uint8_t value)
{
    app::WriteClientHandle handle;
    ReturnErrorOnFailure(
        app::InteractionModelEngine::GetInstance()->NewWriteClient(handle, mDevice->GetInteractionModelDelegate()));
    ReturnErrorOnFailure(handle.EncodeAttributeWritePayload(
        chip::app::AttributePathParams(mEndpoint, mClusterId, WindowCovering::Attributes::Mode::Id), value));
    return mDevice->SendWriteAttributeRequest(std::move(handle), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeMode(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                         uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::Mode::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeMode(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::Mode::Id, onReportCallback,
                                     BasicAttributeFilter<Int8uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeSafetyStatus(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000001A;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeSafetyStatus(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                 uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = WindowCovering::Attributes::SafetyStatus::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeSafetyStatus(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(WindowCovering::Attributes::SafetyStatus::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeFeatureMap(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFC;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeFeatureMap(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::FeatureMap::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeFeatureMap(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::FeatureMap::Id, onReportCallback,
                                     BasicAttributeFilter<Int32uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = 0x0000FFFD;
    return mDevice->SendReadAttributeRequest(attributePath, onSuccessCallback, onFailureCallback,
                                             BasicAttributeFilter<Int16uAttributeCallback>);
}

CHIP_ERROR WindowCoveringCluster::SubscribeAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval)
{
    chip::app::AttributePathParams attributePath;
    attributePath.mEndpointId  = mEndpoint;
    attributePath.mClusterId   = mClusterId;
    attributePath.mAttributeId = Globals::Attributes::ClusterRevision::Id;
    return mDevice->SendSubscribeAttributeRequest(attributePath, minInterval, maxInterval, onSuccessCallback, onFailureCallback);
}

CHIP_ERROR WindowCoveringCluster::ReportAttributeClusterRevision(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(Globals::Attributes::ClusterRevision::Id, onReportCallback,
                                     BasicAttributeFilter<Int16uAttributeCallback>);
}

} // namespace Controller
} // namespace chip
