#!/bin/bash -e

# Copyright (c) 2023 Project CHIP Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Usage: configure [OPTIONS] [--project=... [PROJECT OPTIONS]]
#
# Configures a stand-alone build for a CHIP application in the current
# directory and creates a `ninja` wrapper script to build it. Should
# generally be run from an empty build directory (i.e. out-of-tree).
#
# This is intended to be used in the context of an external build system and
# represents a light-weight alternative to bootstrapping the full Pigweed build
# environment (via scripts/activate.sh). The pigweed git sub-module must still
# be present though.
#
# Host tool dependencies: python3, gn, ninja
#
# The zap-cli code generator and a small number of Python modules are
# downloaded if necessary (see scripts/setup/requirements.build.txt) and
# installed in a build environment directory. By default this is local to
# the build directory, but an external directory can be specified using the
# --build-env-dir option. The build environment directory can be shared by any
# number of build directories, independently of target / tool chain.
#
# Project options can be passed in the usual GNU configure style (--enable-foo,
# --foo-bar=value) and are translated into GN build arguments. By default,
# configure will override the toolchain for the GN build using a 'custom'
# toolchain assembled from the usual environment variables (CC, CXX, AR, CFLAGS,
# CXXFLAGS, ...).

function usage() {
    info "Usage: $0 [OPTIONS] [--project=... [PROJECT OPTIONS]]"
    info "Options:"
    info "  --build-env-dir=DIR     Directory to create (host) build environment in"
    info "  --project=DIR           Sub-directory to build, e.g. examples/lighting-app/linux"
    exit 0
}

function main() { # ...
    set -o pipefail
    CHIP_ROOT=$(cd "$(dirname "$0")/.." && pwd)
    if [[ "$PWD" == "$CHIP_ROOT" ]]; then
        BUILD_DIR="out/configured"
        BUILD_ROOT="${CHIP_ROOT}/${BUILD_DIR}"
        BUILD_ENV_DIR=".venv"
        info "Configuring in-tree, will build in $BUILD_DIR using environment $BUILD_ENV_DIR"
    else
        BUILD_DIR="."
        BUILD_ROOT="$PWD"
        BUILD_ENV_DIR="build-env"
    fi
    PROJECT=

    # Parse main options but leave project options in $@
    while [[ $# -gt 0 && -z "$PROJECT" ]]; do
        case "$1" in
        --help) usage ;;
        --build-env-dir=*) BUILD_ENV_DIR="${1#*=}" ;;
        --project=*) PROJECT="${1#*=}" ;;
        *) fail "Invalid argument: '$1'" ;;
        esac
        shift
    done

    if [[ -n "$PROJECT" ]]; then
        local subdir="$(cd "${CHIP_ROOT}/${PROJECT}" 2>/dev/null && pwd)"
        [[ -n "$subdir" && -r "${subdir}/.gn" ]] || fail "Invalid project '${PROJECT}'"
        PROJECT="${subdir#${CHIP_ROOT}/}"
        [[ "$subdir" == "${CHIP_ROOT}/${PROJECT}" ]] || fail "Unable to determine project path"
    fi

    check_binary gn GN
    check_binary ninja NINJA
    if ! activate_build_env; then
        check_python
        configure_python_env
        if ! check_binary zap-cli; then
            download_zap
        fi
        finalize_build_env
    fi

    if [[ -z "$PROJECT" ]]; then
        info "Build environment created. (Specify --project=DIR to configure a build.)"
        return
    fi

    gn_generate "$@"
    create_ninja_wrapper
    info "You can now run ./ninja"
}

function gn_generate() { # [project options]
    mkdir -p "${BUILD_ROOT}"
    ensure_no_clobber "${BUILD_ROOT}/args.gn"
    (
        cd "${CHIP_ROOT}/${PROJECT}" # --root= doesn't work for gn args!

        # Run gn gen with an empty args.gn first so we can list all arguments
        info "Configuring gn build arguments"
        echo "# ${CONFIGURE_MARKER}" >"${BUILD_ROOT}/args.gn"
        gn -q gen "$BUILD_ROOT"
        gn args "$BUILD_ROOT" --list --json | process_args "$@" >>"${BUILD_ROOT}/args.gn"

        # Now gn gen with the arguments we have configured.
        info "Running gn gen to generate ninja files"
        gn -q gen "$BUILD_ROOT"
    )
}

function process_args() { # [project options]
    "$PYTHON" - "$@" 3<&0 <<'END'
import collections, json, os, re, sys

def info(message):
    print(message, file=sys.stderr)
def fail(message):
    info("Error: " + message)
    sys.exit(1)

# Parse `gn args --list --json` output from FD 3, derive type from default value
argtype = str.maketrans('"tf0123456789', 'sbbiiiiiiiiii') # first char of value -> type
gn_args = { arg['name']: arg['default']['value'][0].translate(argtype) for arg in json.load(os.fdopen(3)) }
def gn_arg(name, prefixes=(), type=None):
    arg = name.translate(str.maketrans('-', '_'))
    candidates = [p + arg for p in (('',) + prefixes) if (p + arg) in gn_args]
    preferred = [c for c in candidates if gn_args[c] == type] if type else []
    if not (match := next(iter(preferred + candidates), None)):
        info("Warning: Project has no option '%s'" % arg)
    return match

args = collections.OrderedDict()
def add_arg(arg, value):
    # format strings and bools as JSON, otherwise pass through as is
    args[arg] = (json.dumps(value) if gn_args.get(arg, 's') in 'sb' else value)

def add_default(arg, value):
    if arg in gn_args:
        add_arg(arg, value)

def add_env_arg(arg, envvar, default=None, list=False):
    value = os.environ.get(envvar, default)
    if not value:
        return
    if not (type := gn_args.get(arg, None)):
        info("Warning: Not propagating %s, project does not have '%s' option" % (envvar, arg))
        return
    args[arg] = json.dumps(value if type != '[' else value.split() if list else [value])

# Defaults
add_default('chip_build_tests', False)
add_default('custom_toolchain', 'custom')

# Configure toolchain binaries and flags from environment
add_env_arg('target_cc', 'CC', 'cc')
add_env_arg('target_cxx', 'CXX', 'cxx')
add_env_arg('target_ar', 'AR', 'ar')
add_env_arg('target_cflags', 'CPPFLAGS', list=True)
add_env_arg('target_cflags_c', 'CFLAGS', list=True)
add_env_arg('target_cflags_cc', 'CXXFLAGS', list=True)
add_env_arg('target_cflags_objc', 'OBJCFLAGS', list=True)
add_env_arg('target_ldflags', 'LDFLAGS', list=True)

# Parse GNU configure style options
for arg in sys.argv[1:]:
    if not (m := re.fullmatch(r'--([a-z][a-z0-9-]*)(?:=(.*))?', arg)):
        fail("Invalid argument: '%s'" % arg)
    name, value = m.group(1, 2)
    if name in ('build', 'host', 'target'):
        if value == None:
            fail("Project option '%s' requires an argument" % arg)
        triplet = value.split('-')
        if len(triplet) not in (2, 3, 4):
            fail("Project option '%s' argument must be a cpu-vendor-os[-abi] triplet" % arg)
        prefix = 'host_' if name == 'build' else 'target_' # "host" has different meanings in GNU and GN!
        add_arg(prefix + 'cpu', triplet[0])
        add_arg(prefix + 'os', triplet[1 if len(triplet) == 2 else 2])
    elif name.startswith('enable-'):
        if not (arg := gn_arg(name[len('enable-'):], ('is_', 'use_', 'chip_', 'chip_use_', 'chip_config_'), 'b')):
            continue
        if gn_args[arg] != 'b':
            fail("Project option '%s' is not a boolean" % arg)
        if value != 'no' and value != None:
            fail("Invalid argument for --%s, must be absent or 'no'" % name)
        add_arg(arg, value == None)
    else:
        if not (arg := gn_arg(name, ('chip_', 'chip_config_'))):
            continue
        if gn_args[arg] == 'b':
            fail("Project option '%s' is a boolean, use --enable-..." % arg)
        if value == None:
            fail("Project option '%s' requires an argument" % arg)
        add_arg(arg, value)

for arg, value in args.items():
    info(" - %s = %s" % (arg, value))
    print("%s = %s" % (arg, value))
END
}

function create_ninja_wrapper() {
    # Note: "." != $BUILD_DIR for in-tree builds
    ensure_no_clobber "ninja"
    cat >"ninja" <<END
#!/bin/bash -e
# ${CONFIGURE_MARKER}
cd "\$(dirname "\$0")"
source "${BUILD_ENV_DIR}/bin/activate"
exec "${NINJA}" -C "${BUILD_DIR}" "\$@"
END
    chmod a+x "ninja"
}

function activate_build_env() {
    generate_build_env_cksum # re-used by finalize_build_env
    [[ -r "${BUILD_ENV_DIR}/.cksum" ]] || return 1
    read -r <"${BUILD_ENV_DIR}/.cksum" || true
    [[ "$REPLY" == "$CURRENT_ENV_CKSUM" ]] || return 1

    [[ -r "${BUILD_ENV_DIR}/bin/activate" ]] || return 1
    info "Using existing build environment: ${BUILD_ENV_DIR}"
    source "${BUILD_ENV_DIR}/bin/activate"
    PYTHON="python"
}

function configure_python_env() {
    progress "Setting up Python venv"
    "$PYTHON" -m venv "$BUILD_ENV_DIR"
    info "ok"

    progress "Installing Python build dependencies"
    "${BUILD_ENV_DIR}/bin/pip" install --disable-pip-version-check --require-virtualenv --quiet \
        -r "${CHIP_ROOT}/scripts/setup/requirements.build.txt" \
        -c "${CHIP_ROOT}/scripts/setup/constraints.txt"
    info "ok"
}

function generate_build_env_cksum() {
    # Conservatively assume that any change to these files invalidates a cached build environment
    CURRENT_ENV_CKSUM="$(cat "$0" "${CHIP_ROOT}/scripts/setup/requirements.build.txt" "${CHIP_ROOT}/scripts/setup/zap.version" | cksum)"
    [[ -n "$CURRENT_ENV_CKSUM" ]] || fail "Failed to generate build environment checksum"
}

function finalize_build_env() {
    echo "$CURRENT_ENV_CKSUM" >"${BUILD_ENV_DIR}/.cksum"
    source "${BUILD_ENV_DIR}/bin/activate"
    PYTHON="python"
}

function download_zap() {
    local version platform
    read -r version <"${CHIP_ROOT}/scripts/setup/zap.version"
    case "$OSTYPE" in
    linux*) platform=linux ;;
    darwin*) platform=mac ;;
    *) fail "Unable to determine zap platform for OSTYPE='$OSTYPE'" ;;
    esac
    local url="https://github.com/project-chip/zap/releases/download/${version}/zap-${platform}.zip"

    progress "Installing zap-cli from $url"
    "$PYTHON" - "$url" "${BUILD_ENV_DIR}/bin" <<'END'
import sys, urllib.request, zipfile
file, *_ = urllib.request.urlretrieve(sys.argv[1])
with zipfile.ZipFile(file) as zip:
    zip.extract(next(i for i in zip.infolist() if i.filename == 'zap-cli'), sys.argv[2])
END
    chmod a+x "${BUILD_ENV_DIR}/bin/zap-cli" # ZipFile.extract() does not handle permissions
    info "ok"
}

function check_python() {
    progress "Checking for Python 3"
    if have_binary python3; then
        PYTHON="$(hash -t python3)"
    elif have_binary python; then
        PYTHON="$(hash -t python)"
        local ver="$("$PYTHON" --version)"
        if [[ "$ver" != "Python 3."* ]]; then
            info "need Python 3 but found $ver"
            return 1
        fi
    else
        info "not found"
        return 1
    fi
    info "$PYTHON"
}

function check_binary() { # binary [VAR]
    progress "Checking for $1"
    if ! have_binary "$1"; then
        info "not found"
        return 1
    fi
    local path="$(hash -t "$1")"
    [[ -n "$2" ]] && eval "$2=\$path"
    info "$path"
}

function have_binary() { # binary
    hash "$1" 2>/dev/null
}

function ensure_no_clobber() { # file
    CONFIGURE_MARKER="Auto-generated by configure, do not edit"
    [[ -s "$1" ]] || return 0
    read -r -n 512 -d '' <"$1" || true
    [[ "${REPLY/$CONFIGURE_MARKER/}" != "$REPLY" ]] && return 0
    fail "Won't overwrite file not generated by configure: $1"
}

function info() { # message
    echo "$*" >&2
}

function progress() { # message
    echo -n "$*... " >&2
}

function fail() { # message
    echo "Error: $*" >&2
    exit 1
}

main "$@"
