{%- macro encode_value(source, encodable, depth) -%}
  {%- if encodable.is_nullable -%}
    {{encode_value(source, encodable.without_nullable(), depth + 1)}}?
  {%- elif encodable.is_optional -%}
    Optional<{{encode_value(source, encodable.without_optional(), depth + 1)}}>
  {%- elif encodable.is_list -%}
    List<{{encode_value(source, encodable.without_list(), depth + 1)}}>
  {%- elif encodable.is_struct -%}
    {%- set struct = encodable.get_underlying_struct() -%}
    chip.devicecontroller.cluster.structs.{{source.name}}Cluster{{struct.name}}
  {%- else -%}
    {{encodable.kotlin_type}}
  {%- endif -%}
{%- endmacro -%}

{%- macro encode_tlv(encodable, tag, name, depth) %}
  {%- if encodable.is_nullable -%}
    if ({{name}} == null) { tlvWriter.putNull({{tag}}) }
    else {
      {{encode_tlv(encodable.without_nullable(), tag, name, depth + 1)}}
    }
  {%- elif encodable.is_optional -%}
    if ({{name}}.isPresent) {
      val opt{{name}} = {{name}}.get()
      {{encode_tlv(encodable.without_optional(), tag, "opt" + name, depth + 1)}}
    }
  {%- elif encodable.is_list -%}
      tlvWriter.startList({{tag}})
      val iter{{name}} = {{name}}.iterator()
      while(iter{{name}}.hasNext()) {
        val next = iter{{name}}.next()
        {{encode_tlv(encodable.without_list(), "AnonymousTag", "next", depth + 1)}}
      }
      tlvWriter.endList()
  {%- elif encodable.is_struct -%}
      {{name}}.toTlv({{tag}}, tlvWriter)
  {%- else -%}
      tlvWriter.put({{tag}}, {{name}})
  {%- endif -%}
{%- endmacro -%}

{%- macro decode_tlv(source, encodable, tag, depth) %}
  {%- if encodable.is_nullable -%}
    try {
      {{decode_tlv(source, encodable.without_nullable(), tag, depth + 1)}}
    } catch (e: TlvParsingException) {
      tlvReader.getNull({{tag}})
      null
    }
  {%- elif encodable.is_optional -%}
    try {
      Optional.of({{decode_tlv(source, encodable.without_optional(), tag, depth + 1)}})
    } catch (e: TlvParsingException) {
      Optional.empty()
    }
  {%- elif encodable.is_list -%}
    {%- set encodablewithoutlist = encodable.without_list() -%}
    mutableListOf<{{encode_value(source, encodablewithoutlist, depth + 1)}}>().apply {
      tlvReader.enterList({{tag}})
      while(true) {
        try {
          this.add({{decode_tlv(source, encodablewithoutlist, "AnonymousTag", depth + 1)}})
        } catch (e: TlvParsingException) {
          break
        }
      }
      tlvReader.exitContainer()
    }
  {%- elif encodable.is_struct -%}
      {%- set struct = encodable.get_underlying_struct() -%}
      chip.devicecontroller.cluster.structs.{{source.name}}Cluster{{struct.name}}.fromTlv({{tag}}, tlvReader)
  {%- else -%}
      tlvReader.get{{encodable.kotlin_type}}({{tag}})
  {%- endif -%}
{%- endmacro -%}

{%- macro contextSpecificTag(id) -%}
  ContextSpecificTag({{id}})
{%- endmacro -%}

/*
 *
 *    Copyright (c) 2023 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package chip.devicecontroller.cluster.eventstructs

import chip.devicecontroller.cluster.*
import chip.tlv.AnonymousTag
import chip.tlv.ContextSpecificTag
import chip.tlv.Tag
import chip.tlv.TlvParsingException
import chip.tlv.TlvReader
import chip.tlv.TlvWriter

import java.util.Optional

class {{cluster.name}}Cluster{{event.name}}Event (
  {%- for field in event.fields -%}
    {%- set encodable = field | asEncodable(typeLookup) %}
    val {{field.name}}: {{encode_value(cluster, encodable, 0)}}
    {%- if loop.index0 < loop.length - 1 -%}{{","}}{%- endif -%}
  {%- endfor -%}) {
  override fun toString() : String {
    val builder: StringBuilder = StringBuilder()
    builder.append("{{cluster.name}}Cluster{{event.name}}Event {\n")
    {%- for field in event.fields %}
    builder.append("\t{{field.name}} : ${{field.name}}\n")
    {%- endfor %}
    builder.append("}\n")
    return builder.toString()
  }

  fun toTlv(tag: Tag, tlvWriter: TlvWriter) {
    tlvWriter.startStructure(tag)
    {% for field in event.fields %}
      {%- set encodable = field | asEncodable(typeLookup) %}
      {%- set tag = contextSpecificTag(field.code) -%}
      {{encode_tlv(encodable, tag, field.name, 0)}}
    {% endfor -%}
    tlvWriter.endStructure()
  }

  companion object {
    fun fromTlv(tag: Tag, tlvReader: TlvReader) : {{cluster.name}}Cluster{{event.name}}Event {
      tlvReader.enterStructure(tag)
      {% for field in event.fields %}
        {%- set encodable = field | asEncodable(typeLookup) %}
        {%- set decodable = field | asEncodable(typeLookup) %}
        {%- set tag = contextSpecificTag(field.code) -%}
        val {{field.name}}: {{encode_value(cluster, encodable, 0)}} = {{decode_tlv(cluster, decodable, tag, 0)}}
      {% endfor %}
      tlvReader.exitContainer()

      return {{cluster.name}}Cluster{{event.name}}Event(
        {%- for field in event.fields -%}
          {%- set encodable = field | asEncodable(typeLookup) -%}
          {{field.name}}
          {%- if loop.index0 < loop.length - 1 -%}{{", "}}{%- endif -%}
        {%- endfor -%}
      )
    }
  }
}
